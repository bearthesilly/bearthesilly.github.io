这次的内容可能概念比较多，学生可能需要好好消化一下，所以我没有放太多内容（比如字符串）进来。计划 l7 讲指针的最后一点点内容 + 字符串，然后 l8 可以再讲讲字符串和动态内存 (malloc/free)，l9 讲 struct，C 就差不多结束了。

P10 `(char *)p + i * sizeof(T)` 这里的 `(char *)p` 是将 `p` 转换成 `char *` 类型，这是因为 `char` 一定是一个 byte，所以转换成 `char *` 之后就变成了字节上的计算，`+ i * sizeof(T)` 就是加上了这么多字节。

P11 `p + i` 不一定等价于 `&a[i]`，这里出于详略的考虑没有解释这一点。如果 `i` 等于数组长度 `N`，`p + i` 只是计算出“尾后”（"past-the-end"）位置的地址，这是合法的，而 `&a[i]` 是先取出 `a[i]` 这个元素再取它的地址，这里的 `a[i]` 就已经是越界访问，是 undefined behavior。

P15 指针运算只能在一个数组及其“尾后”位置范围内发生，超过这个范围都是 undefined behavior。注意，这跟解引用无效指针、数组越界访问不同，指针运算仅仅是计算一个地址，只要它超出了一个数组及其尾后范围，就是 undefined behavior，哪怕我们不去解引用这个计算出来的地址。

P20 事实上，不是“指针也能用下标”，标准上的下标运算符就是给指针定义的，当我们在数组上用下标的时候，这个数组发生了向指针的隐式转换。这种转换在很多地方都会发生，以至于一些人说“数组名就是指针”，但这是错误的。数组是数组，指针是指针，它们之间只是可以隐式转换而已。

P24 简单解释一下 to[j++] = from[i]; 这个写法（主要是 `to[j++]`），并且推荐大家学习。

P30 我的记忆方式：首先记住，存在这两种写法，并且它们声明的类型是不同的。那么 `int (*parr)[N]` 为什么要加括号呢？想必是为了强调“指针”与 `parr` 的关系更近一些，所以 `parr` 是一个指针，剩下的东西是它指向的对象的类型。另一种则相反，`arrp` 是一个数组，剩下的部分 `int*` 就是数组里的元素类型。

P39 HW1 的第四题就是求一列数的次大值和次小值，在这里提醒他们这一列数是不需要开数组存储的。一般来说，如果我们处理第 i 个元素的时候前 i-1 个元素就再也不会用了，那就不需要数组。