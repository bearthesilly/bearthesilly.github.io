关于运算符，这节课先讲加减乘除模、++ 和 --，下节课正式讲优先级、结合性、求值顺序以及其它运算符。

关于控制流，这节课先讲 if-else, while, break, continue, for，下节课讲 do-while 和 switch。

P5 这节课只讲上半部分，下半部分位运算以后再讲，可能是下节课或者习题课。

P7 加减乘除运算符都是为两个具有相同类型的运算对象定义的，因此加减乘除表达式中的两个运算对象一定会先被转换成同一个类型。当两个运算对象的类型是 T 时，运算的结果类型也是 T。这里涉及到的类型转换规则较为复杂，在链接中可以看到完整的叙述，我们不需要去记住所有的东西，只要记住几个常见的即可。

P11 一个小整数和一个大整数一起做运算，结果一定是那个大整数类型吗？不一定。一个充分条件是它们具有同样的 signed-ness，并且那个大整数至少是 int 或 unsigned int。如果它们（的 rank）都比 int 小，首先会发生“整型提升” (integer promotion)，先全都提升成 int 或者 unsigned int，然后再做运算。

P12 注意，标准并没有为诸如“一个整数除以一个浮点数”这样的运算提供单独的定义。一个整数除以一个浮点数时，那个整数就会被转换为浮点数，然后执行浮点数除法，这完全涵盖在我们第 7 页所介绍的规则中。

P21 当标准规定某一行为是 undefined behavior 时，就意味着你不能对其行为做任何假定。比如带符号整数溢出时，不能认为“我们会得到一个 two's complement 意义下的值”，也不能认为“我们会得到一个值，只是不知道它是多少而已”。程序完全可能在这里崩溃，或者这行代码直接被编译器去除，或者发生其它什么事情，这一切都是有可能的。还有一个典型的 undefined behavior 就是使用未初始化的值：
```c
int main(void) {
  int x; // uninitialized
  printf("%d\n", x);
}
```
这个程序不一定会输出一个值，它完全有可能直接崩溃，或者什么都不做就退出等等。不要对 undefined behavior 做任何假定，探讨 undefined behavior 的可能的结果也没有任何意义。此外，编译器是可以假定你的程序不含 undefined behavior 的，也就可以对 undefined behavior 任意处置。

P24 "result" 是这个表达式的值，比如下一页中的例子就展示了如何使用这个表达式的值。这个表达式的值并不一定是变量 `a` 的值，更不是程序的输出或者函数的 return value 等等。初学者易混淆这些概念。

P25 后置递增/递减运算符，其 side effect 是将变量的值 +1/-1，其返回值是那个变量在递增/递减之前的值。不可以说“后置递增运算符是先返回后递增，前置递增运算符是先递增后返回”，这种说法本身不合逻辑（“先返回后递增”，已经返回了，还怎么递增？），并且也属于编译器的实现细节，没人规定编译器在这里必须怎样做。

P27 这里的 `if`, `while`, `for` 语句，都涉及到了条件的判断。C 语言中，在 C23 之前对 `bool`, `true`, `false` 的支持并不到位，甚至在 C99 之前 `bool` 这个类型都不存在。C 语言对于“条件”是否成立的判断从来都是将它和整数 `0` 比较，如果相等就是“不成立”，否则就是“成立”。C++ 会将条件表达式 contextually convert to bool，然后看它是 true 还是 false。
