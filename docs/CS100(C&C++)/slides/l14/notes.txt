受限于页面大小， slides 中的代码格式（缩进、换行、空格等）可能会比较怪异，不要学习这些代码格式。

P6 C++ 中的 struct 并不是只有 C 的 struct 那些功能。事实上， C++ 的 struct 和 class 的能力范围是一样的，仅有两个区别：
- 默认的成员访问权限， class 是 private ， struct 是 public 。
- 默认的继承访问权限， class 是 private ， struct 是 public 。
这里我们还未讲到继承。除了这两点之外，它们没有任何区别，能用 class 完成的事情 struct 都能完成。

P5 这个 slides 里的所有 member 都是 non-static member 。事实上“Every member belongs to an object”只对 non-static member 成立，包括后面提到的 this 指针也只在 non-static member 里存在。 non-static member 和 static member 类似于 Python 里的 instance method 和 class method 。

P11 在汇编层面上，左边的代码真的就是像右边这样处理的，隐式的 `this` 参数会成为这个函数的第一个参数。历史上的第一个 C++ 编译器叫做 Cfront ，由 Bjarne Stroustrup 于 1983 年完成。它之所以叫做 Cfront ，是因为它就是将当时的 C++ 代码翻译成 C 代码，然后调用 C 编译器来编译。 Cfront 对于成员函数的处理方式就是像这一页展示的这样，将成员函数翻译成普通函数，将隐式的 `this` 参数显式地写出来，并把所有成员函数调用 `a.mem(args)` 都翻译成 `mem(&a, args)` 。我可能会在习题课上展示一个基于 Clang 写的小工具，模仿当年的 Cfront 生成翻译后的代码。

P12 `this` 和 Python 的 `self` 的关系就如同 `auto &self = *this;` 。

P13 `const` 成员函数不能修改数据成员，除非那个成员被标记为 `mutable` 。

P13-14 关于 `const` 成员函数的规则很多，但是中心思想很简单： `const` 是一把锁，只能加锁，不能解锁。
- 一个 `const` 对象本身就带锁。
- 进入一个 `const` 成员函数就意味着这个对象带了锁。
- 如果一个对象带锁，它的所有数据成员（除非是 `mutable` 的）都带锁。
在一个 `const` 成员函数中，不能在 `*this` 上调用非 `const` 成员函数，因为它们有可能修改自己（这就是在解锁）。但是也许可以调用其它对象的非 `const` 成员函数，这取决于那个对象是否带有 `const` 。要理解清楚这个“锁”是加在了谁的身上。
P13 先列出这些规则， P14 从 `this` 指针的角度解释这些规则的本质。本质上， `const` 成员函数就是让 `this` 指针带有底层 `const` ，所以 `*this` 带 `const` ， `this->mem` 也带 `const` 。牢记在成员函数中对自身的任何成员的访问都是隐式地经过 `this` 的，那么一切规则就都能推出来了。

P15-16 一个函数是否应该是 `const` 成员函数，是取决于它**逻辑上**是否修改这个对象的状态，而不是看它的定义中是否修改了数据成员。所以哪怕不给出这些函数的定义，我们也应该能判断它们是否应该带 `const` 。这一点（"bitwise constness vs logical constness"）在 Effective C++ Item 3 有详细的解释，我会在习题课上讲。

P20 构造函数没有返回值类型，这是标准上的说法，尽管它表现确实像是返回值类型为 `void` 的函数。在构造函数里可以写 `return;` ，不能 return 一个值。而且在 Clang AST 里可以看到，构造函数的确是被当做返回值类型为 `void` 的函数来处理的，但这是编译器内部的设计，我们只谈语言标准。

构造函数必须，也一定会，初始化所有的数据成员，并且这些数据成员的初始化必然发生在控制流进入函数体之前，并且它们一定是按照它们在类内声明的顺序被初始化的。这对所有类的所有构造函数都成立，无论它的初始值列表是怎么写的，无论它是自定义的还是编译器合成的。

P30 这里的 p3 是声明了一个函数，不接受参数，返回值类型为 Point2d 。很明显， C++ 的初始化语法和函数声明语法在这里发生了冲突，不得不选择一个。这是 C++ 语法本身的缺陷。

P36 这里特别强调 "in a normal design" 。在一般情况下，一个“学生”似乎不应该有一个默认值，但是凡事总有例外。软件工程中，没有永远最好的设计，一切都要根据实际情况而定。

P37 一个错误如果能在运行时显式地报告出来，就不要被隐藏起来。如果能在编译时被发现，就不要等到运行时才出现。编译器是我们的好帮手，该让它报错的时候就要让它报错。