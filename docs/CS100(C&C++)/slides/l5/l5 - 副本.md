# CS100 Lecture 5

Variables <span style="color: black; font-family: Times New Roman; font-size: 1.05em;">II</span>, Pointers and Arrays <span style="color: black; font-family: Times New Roman; font-size: 1.05em;">I</span>

## Contents

- Variables
  - Local `static` variables
  - Initialization
  - `const` type qualifier
- Pointers
- Arrays

## Local `static` variables

```c
void start_game(Player *p1, Player *p2, int difficulty, GameWorld *world) {
  static bool called = false;
  if (called)
    report_an_error("You cannot start the game twice!");
  called = true;
  // ...
}
```

The lifetime of a local `static` variable is **as long as** that of a global variable. *(They both have [static storage duration](https://en.cppreference.com/w/c/language/storage_duration#Storage_duration).)*

- A local `static` variable is initialized **during program startup**, and is destroyed **on program termination**.

It behaves just like a global variable, but its name is inside a function, which does not pollute the global name space.

## Initialization

If we declare a variable without explicit initialization, what is the value of it?

Experiment:


```c
#include <stdio.h>

int global;

int main(void) {
  int local;
  static int local_static;
  printf("%d, %d, %d\n", global, local,
         local_static);
  return 0;
}
```

- Compiled without `-O2` (a kind of optimization):
  
  ```
  0, 22031, 0
  ```
- Compiled with `-O2`:

  ```
  0, 0, 0
  ```

## Implicit initialization [Very important]

If a variable is declared without explicit initialization:

- For local non-`static` variables, they are initialized to **indeterminate values**. In other words, they are **uninitialized**.
- For global or local `static` variables, they are [**empty-initialized**](https://en.cppreference.com/w/c/language/initialization#Empty_initialization) ${}^{\textcolor{red}{1}}$:
  - Pointers are initialized to *null pointer values* of their types. (later in this lecture)
  - Objects of integral types are initialized to `0`.
  - Objects of floating types are initialized to positive zero (`0.0`).
  - Other cases will be discussed in later lectures.
  
  \* Intuitively, such variables are initialized to some kind of "zero" ${}^{\textcolor{red}{2}}$. This is called [zero-initialization](https://en.cppreference.com/w/cpp/language/zero_initialization) in C++.

## Uninitialized garbage can be deadly!

**[Best practice]** <u>Always initialize the variable.</u>

Except in certain cases, e.g.

```c
// in some function
int n;           // uninitialized
scanf("%d", &n); // A value is assigned to `n` immediately. This is OK.
// Now the value of `n` is not indeterminate. It can be used normally.
```

## `const` type qualifier

Each type `T` (not `const`-qualified) has a `const`-qualified version of that type, written as `T const` or `const T`.

Any direct modification of variables with `const`-qualified types is not allowed:

```c
const int n = 100; // Type of `n` is `const int`.
++n; // Error.
```

(Any indirect modification of `const` variables is undefined behavior; see in later lectures.)

A `const` variable cannot be modified after initialization.

Therefore, an uninitialized `const` local non-`static` variable is almost a non-stop ticket to undefined behavior.

```c
// in some function
const int n; // `n` has indeterminate values
n = 42; // Error: cannot modify a const variable.
scanf("%d", &n); // Error: cannot modify a const variable.
```

In C++, `const` variables of built-in types must be initialized.

# Pointers

## Pointers

A pointer *points to* a variable. The **value** of a pointer is the address of the variable that it points to.


```c
int i = 42;
int* pi = &i;
printf("%d\n", *pi);
```
- `int* pi;` declares a pointer named `pi`.
  - The type of `pi` is `int*`.
  - The type of the variable that `pi` points to ("pointee") is `int`.
- `&` is the **address-of operator**, used for taking the address of a variable.
- `*` in the expression `*pi` is the **indirection (dereference) operator**, used for obtaining the variable that a pointer points to.

A pointer *points to* a variable.

We can access and modify a variable through its address (or a pointer pointing to it).

```c
int num = 3;
int* ptr = &num;
printf("%d\n", *ptr);  // 3
*ptr = 10;
printf("%d\n", num);   // 10
++num;
printf("%d\n", *ptr);  // 11
```

## Declare a pointer

To declare a pointer: `PointeeType* ptr;`

- The type of `ptr` is `PointeeType*`.
  - Pointer types with different pointee types are **different types**: `int*` and `double*` are different.
- The asterisk `*` can be placed near either `PointeeType` or `ptr`:
  - `PointeeType* ptr;` and `PointeeType *ptr;` are the same declaration.
  - `PointeeType * ptr;`, `PointeeType       *   ptr;` and `PointeeType*ptr;` are also correct.

The asterisk `*` can be placed near either `PointeeType` or `ptr`:
- `PointeeType* ptr;` may be more intuitive?

However, when declaring more than one pointers in one declaration statement, an asterisk is needed **for every identifier**:

```c
int* p1, p2, p3;   // `p1` is of type `int*`, but `p2` and `p3` are ints.
int *q1, *q2, *q3; // `q1`, `q2` and `q3` all have the type `int*`.
int* r1, r2, *r3;  // `r1` and `r3` are of the type `int*`,
                   // while `r2` is an int.
```

**[Best practice]** <u>Either `PointeeType *ptr` or `PointeeType* ptr` is ok. Choose one style and stick to it. But if you choose the second one, never declare more than one pointers in one declaration statement.</u>

## `&` and `*`

`&var` returns the address of the variable `var`.
- The result type is `Type *`, where `Type` is the type of `var`.
- `var` must be an object that has an identity (an *lvalue*) ${}^{\textcolor{red}{3}}$: `&42` or `&(a + b)` are not allowed.

`*expr` returns **the variable** whose address is the value of `expr`.
- `expr` must have a pointer type `PointeeType *`. The result type is `PointeeType`.
- **The variable** is returned, not only its value. This means that we can modify the returned variable: `++*ptr` is allowed.

## `*`

In a **declaration** `PointeeType *ptr`, `*` is a part of the pointer type `PointeeType *`.

In an **expression** like `*ptr`, `*` is the **indirection (dereference) operator** used to obtain the variable whose address is the value of `ptr`.

Do not mix them up!

## The null pointer

The **null pointer value** is the "zero" value for pointer types ${}^{\textcolor{red}{4}}$.

- It can be obtained from the macro [`NULL`](https://en.cppreference.com/w/c/types/NULL), which is available from many standard library header files (e.g. `<stddef.h>`, `<stdio.h>`, `<stdlib.h>`):
  
  ```c
  int *ptr = NULL; // `ptr` is a null pointer.
  ```

- It can also be obtained from the integer literal `0`.
  
  ```c
  double *ptr = 0; // same as `double *ptr = NULL;`
  ```

- Conversion from a null pointer to an integer type results in `0`.

Note: Better null pointer values (`nullptr`) are available [in C23](https://en.cppreference.com/w/c/language/nullptr) and [in C++11](https://en.cppreference.com/w/cpp/language/nullptr).

The **null pointer value** is the "zero" value for pointer types ${}^{\textcolor{red}{4}}$.

A null pointer compares unequal to any pointer pointing to an object.

It is used for representing a pointer that "points nowhere".

**Dereferencing a null pointer is undefined behavior, and often causes severe runtime errors!**

- Because it is not pointing to an object.

```c
int *ptr = NULL;
printf("%d\n", *ptr); // undefined behavior
*ptr = 42; // undefined behavior
```

## Implicit initialization of pointers

If a pointer is not explicitly initialized:

- Global or local `static`: Initialized to the null pointer value.
- Local non-`static`: Initialized to indeterminate values, or in other words, **uninitialized**.
  - Uninitialized pointers are often called **wild pointers**.

A wild pointer do not point to a specific object, and is not a null pointer either.

**Dereferencing a wild pointer is undefined behavior, and often causes severe runtime errors.**

**[Best practice]** <u>Avoid wild pointers.</u>

## Pointers that are not dereferenceable

A pointer `ptr` is dereferenceable. $\Leftrightarrow$ `*ptr` has no undefined behavior. $\Leftrightarrow$ `ptr` points to an existing object.

A pointer that does not point to an existing object may be

- uninitialized (wild), or
- a null pointer, or
- dangling (We will discuss this in later lectures.), or
- holding some other meaningless address: `int *p = 123`

Dereferencing such a pointer is undefined behavior, and usually causes severe runtime errors.

- Recall the "short-circuit" evaluation of binary logical operators:
  
  ```c
  if (ptr != NULL && *ptr == 42) { /* ... */ }
  ```

  When `ptr` is a null pointer, the right-hand side operand `*ptr == 42` won't be evaluated, so `ptr` is not dereferenced.

## Argument passing

What is the output? Is the value of `i` changed to `42`?


```c
void fun(int x) {
   x = 42;
 }
 int main(void) {
   int i = 30;
   fun(i);
   printf("%d\n", i); // 30
 }  
```
The output is still `30`. `i` is not changed.

- The parameter `x` is initialized as if `int x = i;`, thus obtaining the **value** of `i`.
  - `x` and `i` are two independent variables.
- Modification on `x` does not influence `i`.

# Arrays

## Arrays

An array is a sequence of `N` objects of an *element type* `ElemType` stored **contiguously** in memory, where `N` $\in\mathbb Z_+$ is the *length* of it.

```c
ElemType arr[N];
```

`N` must be a **constant expression** whose value is known at compile-time.

```c
int a1[10];      // OK. A literal is a constant expression.
#define MAXN 10
int a2[MAXN];    // OK. `MAXN` is replaced with `10` by the preprocessor.
int n; scanf("%d", &n);
int a[n];        // A C99 VLA (Variable-Length Array), whose length is
                 // determined at runtime.
```

For now, we do not recommend the use of VLAs. We will talk more about it in recitations.

An array is a sequence of `N` objects of an *element type* `ElemType` stored **contiguously** in memory, where `N` $\in\mathbb Z_+$ is the *length* of it.

```c
ElemType arr[N]; // The type of `arr` is `ElemType [N]`.
```

The type of an array consists of two parts:

1. the element type `ElemType`, and
2. the length of the array `[N]`.

```c
ElemType arr[N];
```

Use `arr[i]` to obtain the `i`-th element of `arr`, where `i` $\in[0,N)$.


```c
int a[10];

bool find(int value) {
  for (int i = 0; i < 10; ++i)
    if (a[i] == value)
      return true;
  return false;
}
```

```c
int main(void) {
  int n; scanf("%d", &n);
  for (int i = 0; i < n; ++i)
    scanf("%d", &a[i]);
  for (int i = 0; i < n; ++i)
    a[i] *= 2;
  // ...
}
```
The subscript `i` is an integer within the range $[0,N)$. **Array subscript out of range is undefined behavior, and usually causes severe runtime errors.**

The compiler may assume that the program is free of undefined behaviors:

If an array is declared without explicit initialization:

- Global or local `static`: Empty-initialization $\Rightarrow$ Every element is empty-initialized.
- Local non-`static`: Every element is initialized to indeterminate values (uninitialized).

Arrays can be initialized from [brace-enclosed lists](https://en.cppreference.com/w/c/language/array_initialization#Initialization_from_brace-enclosed_lists):

- Initialize the beginning few elements:
  
  ```c
  int a[10] = {2, 3, 5, 7}; // Correct: Initializes a[0], a[1], a[2], a[3]
  int b[2] = {2, 3, 5};     // Error: Too many initializers
  int c[] = {2, 3, 5};      // Correct: 'c' has type int[3].
  int d[100] = {};          // Correct in C++ and since C23.
  ```
- Initialize designated elements (since C99):
  
  ```c
  int e[10] = {[0] = 2, 3, 5, [7] = 7, 11, [4] = 13};
  ```

If an array is explicitly initialized, all the elements that are not explicitly initialized are **empty-initialized**.

```c
int main(void) {
  int a[10] = {1, 2, 3}; // a[3], a[4], ... are all initialized to zero.
  int b[100] = {0};      // All elements of b are initialized to zero.
  int c[100] = {1};      // c[0] is initialized to 1,
                         // and the rest are initialized to zero.
}
```

**`= {x}` is not initializing all elements to `x`!**

## Nested arrays

The C answer to "multidimensional arrays" is **nested arrays**, which is in fact **arrays of arrays**:

```c
int a[10][20];

bool find(int value) {
  for (int i = 0; i < 10; ++i)
    for (int j = 0; j < 20; ++j)
      if (a[i][j] == value)
        return true;
  return false;
}
```

---

## Initialization of nested arrays

```c
int a[4][3] = { // array of 4 arrays of 3 ints each (4x3 matrix)
    { 1 },      // row 0 initialized to {1, 0, 0}
    { 0, 1 },   // row 1 initialized to {0, 1, 0}
    { [2]=1 },  // row 2 initialized to {0, 0, 1}
};              // row 3 initialized to {0, 0, 0}
int b[4][3] = {    // array of 4 arrays of 3 ints each (4x3 matrix)
  1, 3, 5, 2, 4, 6, 3, 5, 7 // row 0 initialized to {1, 3, 5}
};                          // row 1 initialized to {2, 4, 6}
                            // row 2 initialized to {3, 5, 7}
                            // row 3 initialized to {0, 0, 0}
int y[4][3] = {[0][0]=1, [1][1]=1, [2][0]=1};  // row 0 initialized to {1, 0, 0}
                                               // row 1 initialized to {0, 1, 0}
                                               // row 2 initialized to {1, 0, 0}
                                               // row 3 initialized to {0, 0, 0}
```

