
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.0, mkdocs-material-9.5.25">
    
    
      
        <title>CS100 Lecture 2 - csrookie's website</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.6543a935.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#cs100-lecture-2" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../index.html" title="csrookie&#39;s website" class="md-header__button md-logo" aria-label="csrookie's website" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            csrookie's website
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              CS100 Lecture 2
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m14.3 16-.7-2h-3.2l-.7 2H7.8L11 7h2l3.2 9h-1.9M20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69m-9.15 3.96h2.3L12 9l-1.15 3.65Z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to system preference"  type="radio" name="__palette" id="__palette_2">
    
      <label class="md-header__button md-icon" title="Switch to system preference" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12c0-2.42-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../index.html" title="csrookie&#39;s website" class="md-nav__button md-logo" aria-label="csrookie's website" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    csrookie's website
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../index.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Course (Curriculum)
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Course (Curriculum)
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1" >
        
          
          <label class="md-nav__link" for="__nav_2_1" id="__nav_2_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    高等数学上
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_1">
            <span class="md-nav__icon md-icon"></span>
            高等数学上
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8A/%E5%86%99%E5%9C%A8%E6%9C%80%E5%89%8D%E9%9D%A2/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    写在最前面
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1_2" >
        
          
          <label class="md-nav__link" for="__nav_2_1_2" id="__nav_2_1_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    第一&二章 函数 极限与连续
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_1_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_1_2">
            <span class="md-nav__icon md-icon"></span>
            第一&二章 函数 极限与连续
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8A/%27%E8%AF%81%E6%98%8E%27%E6%80%BB%E7%BB%93/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第一章证明总结
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8A/%E9%80%92%E6%8E%A8%E6%95%B0%E5%88%97%E7%9A%84%E6%9E%81%E9%99%90/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    递推数列的极限
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8A/%E6%9E%81%E9%99%90%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5%E9%A2%98/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    极限中的概念题
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8A/%E8%BF%9E%E7%BB%AD%E6%80%A7%20%E9%97%B4%E6%96%AD%E7%82%B9%20%E6%B8%90%E8%BF%91%E7%BA%BF/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    连续性 间断点 渐近线
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8A/%E5%A4%B9%E9%80%BC%E5%87%86%E5%88%99%E6%B1%82%E6%9E%81%E9%99%90/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    夹逼准则求极限
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8A/%E6%B1%82%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    求函数极限
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8A/%E6%9E%81%E9%99%90%E4%B8%8E%E8%BF%9E%E7%BB%AD%E9%9A%8F%E7%AC%94/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    极限与连续随笔
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1_3" >
        
          
          <label class="md-nav__link" for="__nav_2_1_3" id="__nav_2_1_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    第三&四章 导数与微分 微分中值与导数应用
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_1_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_1_3">
            <span class="md-nav__icon md-icon"></span>
            第三&四章 导数与微分 微分中值与导数应用
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8A/%E5%AF%BC%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%A6%82%E5%BF%B5%E4%B8%93%E9%A2%98/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    导数定义与概念专题
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8A/%E7%AC%AC%E4%BA%8C%E4%B8%89%E5%9B%9B%E7%AB%A0%E5%A5%BD%E9%A2%98/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第二&三&四章好题
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1_4" >
        
          
          <label class="md-nav__link" for="__nav_2_1_4" id="__nav_2_1_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    第五章 积分
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_1_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_1_4">
            <span class="md-nav__icon md-icon"></span>
            第五章 积分
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8A/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%AE%9A%E7%A7%AF%E5%88%86%E6%A6%82%E5%BF%B5/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    不定积分与定积分概念
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8A/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%93%E9%A2%98/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    不定积分专题
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8A/%E5%AE%9A%E7%A7%AF%E5%88%86%E5%AE%9A%E4%B9%89%E6%B1%82%E6%9E%81%E9%99%90/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    定积分定义求极限
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8A/%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86%E6%95%9B%E6%95%A3%E6%80%A7/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    反常积分敛散性
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8A/%E7%A7%AF%E5%88%86%E4%B8%8D%E7%AD%89%E5%BC%8F/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    积分不等式
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8A/%E7%A7%AF%E5%88%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    积分及其应用
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8A/%E7%A7%AF%E5%88%86%E7%9A%84%E5%BA%94%E7%94%A8%26%E5%87%BD%E6%95%B0%E5%BD%A2%E6%80%81/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    积分的应用&函数形态
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8A/%E7%A7%AF%E5%88%86%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    积分递推公式
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8A/%E6%89%8B%E6%B3%95%26painpoint/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    手法&painpoint
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1_6" >
        
          
          <label class="md-nav__link" for="__nav_2_1_6" id="__nav_2_1_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    第六章 微分方程
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_1_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_1_6">
            <span class="md-nav__icon md-icon"></span>
            第六章 微分方程
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8A/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    微分方程
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8A/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AF%87/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    期末复习篇
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8A/%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6%E5%A5%BD%E9%A2%98/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    一元积分学好题
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2" >
        
          
          <label class="md-nav__link" for="__nav_2_2" id="__nav_2_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    高等数学下
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2">
            <span class="md-nav__icon md-icon"></span>
            高等数学下
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B/%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E6%80%BB%E7%BB%93/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第七章 向量空间与空间解析几何
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2" >
        
          
          <label class="md-nav__link" for="__nav_2_2_2" id="__nav_2_2_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    第八章 多元函数的微分学
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2">
            <span class="md-nav__icon md-icon"></span>
            第八章 多元函数的微分学
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    多元函数
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B/%E5%81%8F%E5%AF%BC%E6%95%B0%E8%AE%A1%E7%AE%97/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    偏导数计算
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B/%E5%B7%B2%E7%9F%A5%E5%81%8F%E5%AF%BC%E5%8F%8D%E6%B1%82%E5%87%BD%E6%95%B0/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    已知偏导反求函数
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B/%E5%85%A8%E5%BE%AE%E5%88%86%E7%9A%84%E5%88%A4%E5%AE%9A%E4%B8%8E%E8%AE%A1%E7%AE%97/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    全微分的判定与计算
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B/%E9%9A%90%E5%87%BD%E6%95%B0%E5%AD%98%E5%9C%A8%E5%AE%9A%E7%90%86/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    隐函数存在定理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E6%9E%81%E5%80%BC/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    多元函数极值
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_3" >
        
          
          <label class="md-nav__link" for="__nav_2_2_3" id="__nav_2_2_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    第九章 重积分
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_2_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_3">
            <span class="md-nav__icon md-icon"></span>
            第九章 重积分
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B/%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    二重积分
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B/%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    二重积分中值定理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B/%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E5%A5%BD%E9%A2%98/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    二重积分好题
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B/%E6%9C%9F%E4%B8%AD%E6%80%BB%E7%BB%93/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    期中总结
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B/%E9%AB%98%E6%95%B0%E5%A5%BD%E9%A2%98%E4%B8%8A/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    高数好题上
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_6" >
        
          
          <label class="md-nav__link" for="__nav_2_2_6" id="__nav_2_2_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    第十章 曲线积分和曲面积分
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_2_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_6">
            <span class="md-nav__icon md-icon"></span>
            第十章 曲线积分和曲面积分
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B/%E6%9B%B2%E7%BA%BF%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    曲线与曲面积分
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B/%E6%9B%B2%E7%BA%BF%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86%E6%80%BB%E7%BB%93/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    曲线与曲面积分总结
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B/%E6%9B%B2%E7%BA%BF%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86%E8%8D%9F%E8%90%83/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    曲线与曲面积分荟萃
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_7" >
        
          
          <label class="md-nav__link" for="__nav_2_2_7" id="__nav_2_2_7_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    第十一章 级数
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_2_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_7">
            <span class="md-nav__icon md-icon"></span>
            第十一章 级数
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0%E5%92%8C%E5%88%A4%E5%88%AB%E6%B3%95/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    无穷级数和判别法
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0%E9%80%89%E6%8B%A9%E9%A2%98%E4%B8%8E%E5%8F%8D%E4%BE%8B/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    无穷级数选择题与反例
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B/%E5%B9%82%E5%87%BD%E6%95%B0/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    幂函数
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B/%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    傅里叶级数
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B/%E9%AB%98%E6%95%B0%E5%A5%BD%E9%A2%98%E4%B8%8B/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    高数好题下
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_3" >
        
          
          <label class="md-nav__link" for="__nav_2_3" id="__nav_2_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    离散数学
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_3">
            <span class="md-nav__icon md-icon"></span>
            离散数学
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E5%86%99%E5%9C%A8%E6%9C%80%E5%89%8D%E9%9D%A2.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    写在最前面
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_3_2" >
        
          
          <label class="md-nav__link" for="__nav_2_3_2" id="__nav_2_3_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    上半部分
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_3_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_3_2">
            <span class="md-nav__icon md-icon"></span>
            上半部分
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8A%E5%8D%8A%E9%83%A8%E5%88%86/Lec1/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec1
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8A%E5%8D%8A%E9%83%A8%E5%88%86/Lec2%263/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec2&3
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8A%E5%8D%8A%E9%83%A8%E5%88%86/Lec4/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec4
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8A%E5%8D%8A%E9%83%A8%E5%88%86/Lec5/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec5
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8A%E5%8D%8A%E9%83%A8%E5%88%86/Lec6/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec6
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8A%E5%8D%8A%E9%83%A8%E5%88%86/Lec7/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec7
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8A%E5%8D%8A%E9%83%A8%E5%88%86/Lec8/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec8
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8A%E5%8D%8A%E9%83%A8%E5%88%86/Lec9/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec9
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8A%E5%8D%8A%E9%83%A8%E5%88%86/Lec10/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec10
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8A%E5%8D%8A%E9%83%A8%E5%88%86/Lec11/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec11
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8A%E5%8D%8A%E9%83%A8%E5%88%86/Lec12/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec12
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8A%E5%8D%8A%E9%83%A8%E5%88%86/Lec13%2614/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec13&14
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8A%E5%8D%8A%E9%83%A8%E5%88%86/Lec15/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec15
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8A%E5%8D%8A%E9%83%A8%E5%88%86/%E9%9A%8F%E7%AC%94%26%E5%A5%BD%E9%A2%98/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    随笔&好题
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_3_3" >
        
          
          <label class="md-nav__link" for="__nav_2_3_3" id="__nav_2_3_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    下半部分
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_3_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_3_3">
            <span class="md-nav__icon md-icon"></span>
            下半部分
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%88%86/Lec1/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec1
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%88%86/Lec2/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec2
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%88%86/Lec3/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec3
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%88%86/Lec4/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec4
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%88%86/Lec5/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec5
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%88%86/Lec6/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec6
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%88%86/Lec7/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec7
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%88%86/Lec8/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec8
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%88%86/Lec9/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec9
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%88%86/Lec10/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec10
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%88%86/Lec11/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec11
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%88%86/Lec12/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec12
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%88%86/Lec13/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec13
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%88%86/Lec14/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec14
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_4" >
        
          
          <label class="md-nav__link" for="__nav_2_4" id="__nav_2_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    线性代数
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_4">
            <span class="md-nav__icon md-icon"></span>
            线性代数
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%86%99%E5%9C%A8%E6%9C%80%E5%89%8D%E9%9D%A2.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    写在最前面
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    课堂笔记
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E8%A1%8C%E5%88%97%E5%BC%8F%E4%B8%8E%E4%BC%B4%E9%9A%8F%E7%9F%A9%E9%98%B5/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    行列式与伴随矩阵
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E6%89%8B%E6%B3%95%E4%B8%8E%E5%A5%BD%E9%A2%98/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    手法与好题
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%AB%A0%E8%8A%82%E5%9B%9E%E9%A1%BE/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    章节回顾
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E6%80%BB%E5%A4%8D%E4%B9%A0/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    总复习
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_5" >
        
          
          <label class="md-nav__link" for="__nav_2_5" id="__nav_2_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    概率论
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_5">
            <span class="md-nav__icon md-icon"></span>
            概率论
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%A6%82%E7%8E%87%E8%AE%BA/%E5%86%99%E5%9C%A8%E6%9C%80%E5%89%8D%E9%9D%A2.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    写在最前面
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_5_2" >
        
          
          <label class="md-nav__link" for="__nav_2_5_2" id="__nav_2_5_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Lec-handwriting
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_5_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_5_2">
            <span class="md-nav__icon md-icon"></span>
            Lec-handwriting
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%A6%82%E7%8E%87%E8%AE%BA/L1-handwriting.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec1-handwriting
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%A6%82%E7%8E%87%E8%AE%BA/L2-handwriting.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec2-handwriting
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%A6%82%E7%8E%87%E8%AE%BA/L3-handwriting.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec3-handwriting
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%A6%82%E7%8E%87%E8%AE%BA/L4-handwriting.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec4-handwriting
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%A6%82%E7%8E%87%E8%AE%BA/L5-handwriting.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec5-handwriting
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%A6%82%E7%8E%87%E8%AE%BA/L6-handwriting.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec6-handwriting
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%A6%82%E7%8E%87%E8%AE%BA/L7-handwriting.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec7-handwriting
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%A6%82%E7%8E%87%E8%AE%BA/L8-handwriting.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec8-handwriting
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%A6%82%E7%8E%87%E8%AE%BA/L9-handwriting.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec9-handwriting
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%A6%82%E7%8E%87%E8%AE%BA/L10-handwriting.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec10-handwriting
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_5_3" >
        
          
          <label class="md-nav__link" for="__nav_2_5_3" id="__nav_2_5_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Note
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_5_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_5_3">
            <span class="md-nav__icon md-icon"></span>
            Note
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%A6%82%E7%8E%87%E8%AE%BA/SI140-note/Lec1.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec1
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%A6%82%E7%8E%87%E8%AE%BA/SI140-note/Lec2-3.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec2-3
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%A6%82%E7%8E%87%E8%AE%BA/SI140-note/Lec4-5-6.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec4-5-6
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%A6%82%E7%8E%87%E8%AE%BA/SI140-note/Lec7-8.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec7-8
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%A6%82%E7%8E%87%E8%AE%BA/SI140-note/Lec9-10-11.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec9-10-11
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%A6%82%E7%8E%87%E8%AE%BA/SI140-note/%E6%9C%9F%E4%B8%AD%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    期中部分总结
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%A6%82%E7%8E%87%E8%AE%BA/SI140-note/Chapter4.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter4
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%A6%82%E7%8E%87%E8%AE%BA/SI140-note/Chapter5.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter5
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%A6%82%E7%8E%87%E8%AE%BA/SI140-note/Chapter6.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter6
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%A6%82%E7%8E%87%E8%AE%BA/SI140-note/Chapter7-8.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter7-8
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%A6%82%E7%8E%87%E8%AE%BA/SI140-note/Chapter9.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter9
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%A6%82%E7%8E%87%E8%AE%BA/SI140-note/Chapter10.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter10
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%A6%82%E7%8E%87%E8%AE%BA/SI140-note/%E6%9C%9F%E6%9C%AB%E6%80%BB%E5%A4%8D%E4%B9%A0.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    期末总复习
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%A6%82%E7%8E%87%E8%AE%BA/SI140-note/Skill.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Skill
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_6" >
        
          
          <label class="md-nav__link" for="__nav_2_6" id="__nav_2_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    CS100(C&C++)
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_6">
            <span class="md-nav__icon md-icon"></span>
            CS100(C&C++)
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_6_1" >
        
          
          <label class="md-nav__link" for="__nav_2_6_1" id="__nav_2_6_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    课件
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_6_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_6_1">
            <span class="md-nav__icon md-icon"></span>
            课件
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l0/l0.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L0
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l1/l1.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L1
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l2/l2.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L2
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l3/l3.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L3
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l4/l4.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L4
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l5/l5.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L5
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l6/l6.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L6
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l7/l7.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L7
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l8/l8.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L8
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l9/l9.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L9
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l10/l10.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L10
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l11/l11.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L11
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l12/l12.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L12
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l13/l13.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L13
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l14/l14.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L14
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l15/l15.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L15
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l16/l16.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L16
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l17/l17.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L17
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l18/l18.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L18
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l19/l19.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L19
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l20/l20.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L20
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l21/l21.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L21
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l22/l22.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L22
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l23/l23.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L23
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l24/l24.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L24
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l25/l25.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L25
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l26/l26.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L26
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l27/l27.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L27
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="slides/l28/l28.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L28
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="C%2B%2B%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C++自学note
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="core.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    core
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="%E8%AF%BE%E5%A0%82.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    课堂note
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_7" >
        
          
          <label class="md-nav__link" for="__nav_2_7" id="__nav_2_7_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    数据结构与算法
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_7">
            <span class="md-nav__icon md-icon"></span>
            数据结构与算法
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Data_Structure_and_Algorithm/%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    基本结构与算法分析
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Data_Structure_and_Algorithm/%E6%90%9C%E7%B4%A2%E4%B8%8E%E6%8E%92%E5%BA%8F.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    搜索与排序
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Data_Structure_and_Algorithm/%E7%AE%97%E6%B3%95.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    算法
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Data_Structure_and_Algorithm/%E8%BF%9B%E9%98%B6%E4%B8%8E%E6%8B%93%E5%B1%95misc.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    进阶与拓展
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_8" >
        
          
          <label class="md-nav__link" for="__nav_2_8" id="__nav_2_8_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    信号与系统
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_8">
            <span class="md-nav__icon md-icon"></span>
            信号与系统
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/%E5%86%99%E5%9C%A8%E6%9C%80%E5%89%8D%E9%9D%A2.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    写在最前面
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_8_2" >
        
          
          <label class="md-nav__link" for="__nav_2_8_2" id="__nav_2_8_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    slides
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_8_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_8_2">
            <span class="md-nav__icon md-icon"></span>
            slides
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/Chapter%201.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter1
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/Chapter%202.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter2
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/Chapter%203.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter3
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/Chapter%204.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter4
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/Chapter%205.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter5
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/Chapter%206.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter6
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/Chapter%207.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter7
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/Chapter%209.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter9
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/Chapter%2010.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter10
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_8_3" >
        
          
          <label class="md-nav__link" for="__nav_2_8_3" id="__nav_2_8_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Note
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_8_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_8_3">
            <span class="md-nav__icon md-icon"></span>
            Note
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/Note/Chapter1LecNote.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter1LecNote
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/Note/Chapter2LecNote.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter2LecNote
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/Note/Chapter3LecNote.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter3LecNote
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/Note/Chapter3Review.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter3Review
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/Note/Chapter4Review.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter4Review
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/Note/Chapter5Review.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter5Review
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/Note/Chapter6Review.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter6Review
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/Note/Chapter8Review.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter8Review
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/Note/Chapter9Review.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter9Review
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/Note/Chapter10Review.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter10Review
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/Note/%E6%9C%9F%E4%B8%ADcheatsheet.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    期中cheatsheet
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/Note/%E6%9C%9F%E6%9C%ABcheatsheet.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    期末cheatsheet
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_9" >
        
          
          <label class="md-nav__link" for="__nav_2_9" id="__nav_2_9_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    普通物理
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_9">
            <span class="md-nav__icon md-icon"></span>
            普通物理
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%99%AE%E9%80%9A%E7%89%A9%E7%90%86/%E5%86%99%E5%9C%A8%E6%9C%80%E5%89%8D%E9%9D%A2.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    写在最前面
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_9_2" >
        
          
          <label class="md-nav__link" for="__nav_2_9_2" id="__nav_2_9_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    slides
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_9_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_9_2">
            <span class="md-nav__icon md-icon"></span>
            slides
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%99%AE%E9%80%9A%E7%89%A9%E7%90%86/Lect2_Kinematics%20%E8%B4%A8%E7%82%B9%E8%BF%90%E5%8A%A8%E5%AD%A6.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec2
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%99%AE%E9%80%9A%E7%89%A9%E7%90%86/Lect3_Dynamics%20%E8%B4%A8%E7%82%B9%E5%8A%A8%E5%8A%9B%E5%AD%A6-1.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec3
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%99%AE%E9%80%9A%E7%89%A9%E7%90%86/Lect4_Dynamics%20%E8%B4%A8%E7%82%B9%E5%8A%A8%E5%8A%9B%E5%AD%A6-2.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec4
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%99%AE%E9%80%9A%E7%89%A9%E7%90%86/Lect5_Work_energy%20%E5%8A%9F%E5%92%8C%E8%83%BD.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec5
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%99%AE%E9%80%9A%E7%89%A9%E7%90%86/Lect6_Potential%20Energy_%E5%8A%BF%E8%83%BD.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec6
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%99%AE%E9%80%9A%E7%89%A9%E7%90%86/Lect7_Momentum_%E5%8A%A8%E9%87%8F-%E9%A2%84%E4%B9%A0.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec7
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%99%AE%E9%80%9A%E7%89%A9%E7%90%86/Lect8_Collision%20and%20elasticity%20%E7%A2%B0%E6%92%9E%E5%92%8C%E5%BC%B9%E6%80%A7.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec8
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%99%AE%E9%80%9A%E7%89%A9%E7%90%86/Lect9%20%E5%88%9A%E4%BD%93.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec9
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%99%AE%E9%80%9A%E7%89%A9%E7%90%86/Lect10%20%E5%8A%9B%E7%9F%A9%E3%80%81%E8%A7%92%E5%8A%A8%E9%87%8F.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec10
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%99%AE%E9%80%9A%E7%89%A9%E7%90%86/Lect11%20%E5%B9%B3%E8%A1%A1%E3%80%81%E6%B5%81%E4%BD%93%E5%8A%9B%E5%AD%A6.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec11
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%99%AE%E9%80%9A%E7%89%A9%E7%90%86/Lect12%20%E4%B8%87%E6%9C%89%E5%BC%95%E5%8A%9B.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec12
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%99%AE%E9%80%9A%E7%89%A9%E7%90%86/Lect13_Oscillation%20%E6%8C%AF%E5%8A%A8.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec13
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%99%AE%E9%80%9A%E7%89%A9%E7%90%86/Lect14_MechanicalWave-2024.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec14
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%99%AE%E9%80%9A%E7%89%A9%E7%90%86/Lect15-Mechanical%20Wave-2-2024%E6%9B%B4%E6%96%B0%E7%89%88.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec15
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%99%AE%E9%80%9A%E7%89%A9%E7%90%86/Lect16_Sound%20and%20Hearing-2024%281%29.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec16
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%99%AE%E9%80%9A%E7%89%A9%E7%90%86/Lect17_Temperature%2Band%2BHeat%202024%281%29.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec17
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%99%AE%E9%80%9A%E7%89%A9%E7%90%86/Lect18_Thermal%2BProperties_2024.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec18
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%99%AE%E9%80%9A%E7%89%A9%E7%90%86/Lect19_First%2BThermodynamics%2BLaw_2024-%E6%9B%B4%E6%AD%A3%E7%89%882.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lec19
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%99%AE%E9%80%9A%E7%89%A9%E7%90%86/%E7%83%AD%E5%AD%A6%E5%A4%8D%E4%B9%A0.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    热学复习
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%99%AE%E9%80%9A%E7%89%A9%E7%90%86/%E6%8C%AF%E5%8A%A8%E5%92%8C%E6%B3%A2%E5%8A%A8%E5%A4%8D%E4%B9%A0.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    振动和波动复习
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_9_3" >
        
          
          <label class="md-nav__link" for="__nav_2_9_3" id="__nav_2_9_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Review
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_9_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_9_3">
            <span class="md-nav__icon md-icon"></span>
            Review
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%99%AE%E9%80%9A%E7%89%A9%E7%90%86/%E6%9C%9F%E4%B8%AD%E6%80%BB%E7%BB%93.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    期中总结
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%99%AE%E9%80%9A%E7%89%A9%E7%90%86/%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    期末总结
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_10" >
        
          
          <label class="md-nav__link" for="__nav_2_10" id="__nav_2_10_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    人工智能
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_10_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_10">
            <span class="md-nav__icon md-icon"></span>
            人工智能
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/Search.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Search
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/CSP.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CSP
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/Adversial_Search.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Adversial_Search
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/Propositional_Logic.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Propositional_Logic
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/First_Order_Logic.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    First_Order_Logic
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_10_6" >
        
          
          <label class="md-nav__link" for="__nav_2_10_6" id="__nav_2_10_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Bayes_Net
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_10_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_10_6">
            <span class="md-nav__icon md-icon"></span>
            Bayes_Net
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/BN1.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BN1
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/BN2.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BN2
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/Markov_Decision.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Markov Decision Process
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/Reinforcement_learning.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Reinforcement Learning
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_11" >
        
          
          <label class="md-nav__link" for="__nav_2_11" id="__nav_2_11_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    机器学习
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_11_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_11">
            <span class="md-nav__icon md-icon"></span>
            机器学习
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_11_1" >
        
          
          <label class="md-nav__link" for="__nav_2_11_1" id="__nav_2_11_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    神经网络
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_11_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_11_1">
            <span class="md-nav__icon md-icon"></span>
            神经网络
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86/feature_engineering.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    feature_engineering
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86/CNN.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CNN
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86/practical_aspects.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    practical_aspects
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86/RNN.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    RNN
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86/Transformer.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Transformer
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_12" >
        
          
          <label class="md-nav__link" for="__nav_2_12" id="__nav_2_12_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    CA
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_12_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_12">
            <span class="md-nav__icon md-icon"></span>
            CA
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../CA/Info-Representation.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Info-Representation
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../CA/C_Language.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C_Language
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../CA/RISC-V.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    RISC-V
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../CA/CALL.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CALL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../CA/Digital_Circuit.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Digital_Cirtuit
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../CA/Datapath_Controller.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Datapath_Controller
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_13" >
        
          
          <label class="md-nav__link" for="__nav_2_13" id="__nav_2_13_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    论证与写作
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_13_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_13">
            <span class="md-nav__icon md-icon"></span>
            论证与写作
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%AE%BA%E8%AF%81%E4%B8%8E%E5%86%99%E4%BD%9C/%E4%B8%AD%E5%9B%BD%E7%A4%BE%E4%BC%9A%E7%A7%91%E5%AD%A6%E5%BC%95%E6%96%87%E8%A7%84%E5%AE%9A.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    中国社会科学引文规定
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%AE%BA%E8%AF%81%E4%B8%8E%E5%86%99%E4%BD%9C/%E5%8F%8D%E6%80%9D%E6%80%A7%E5%86%99%E4%BD%9C%E7%BB%83%E4%B9%A0%E8%A6%81%E6%B1%82.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    反思性写作练习要求
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%AE%BA%E8%AF%81%E4%B8%8E%E5%86%99%E4%BD%9C/02%E7%AC%AC%E4%BA%8C%E8%AE%B2%20%E5%A6%82%E4%BD%95%E5%86%99%E4%BD%9C%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%EF%BC%88%E4%B8%80%EF%BC%89.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    02第二讲 如何写作学术论文（一）
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%AE%BA%E8%AF%81%E4%B8%8E%E5%86%99%E4%BD%9C/03%E7%AC%AC%E4%B8%89%E8%AE%B2%20%E5%A6%82%E4%BD%95%E5%86%99%E4%BD%9C%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%EF%BC%88%E4%BA%8C%EF%BC%89.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    03第三讲 如何写作学术论文（二）
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%AE%BA%E8%AF%81%E4%B8%8E%E5%86%99%E4%BD%9C/04%E7%AC%AC%E5%9B%9B%E8%AE%B2%20%E8%AE%A4%E8%AF%86%E8%AE%BA%E8%AF%81.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    04第四讲 认识论证
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Course (Extracurriculum)
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Course (Extracurriculum)
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1" >
        
          
          <label class="md-nav__link" for="__nav_3_1" id="__nav_3_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Deep Learning
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1">
            <span class="md-nav__icon md-icon"></span>
            Deep Learning
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../deeplearning_note/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%87%AA%E5%AD%A6.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Partition One: Fundamental + Convolution
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../sequence%20model/sequence_model.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Partition Two: Sequence Model
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../transformer_note/transformer_note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Transformer
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2" >
        
          
          <label class="md-nav__link" for="__nav_3_2" id="__nav_3_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    GAMES101
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_2">
            <span class="md-nav__icon md-icon"></span>
            GAMES101
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../GAMES101/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Note
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../GAMES101/note_hw.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Homework
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3" >
        
          
          <label class="md-nav__link" for="__nav_3_3" id="__nav_3_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    动手学深度学习
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_3">
            <span class="md-nav__icon md-icon"></span>
            动手学深度学习
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3_1" >
        
          
          <label class="md-nav__link" for="__nav_3_3_1" id="__nav_3_3_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    预备知识
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_3_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_3_1">
            <span class="md-nav__icon md-icon"></span>
            预备知识
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    数据操作与数据预处理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%B1%82%E5%AF%BC.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    矩阵计算与自动求导
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3_2" >
        
          
          <label class="md-nav__link" for="__nav_3_3_2" id="__nav_3_3_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    线性神经网络
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_3_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_3_2">
            <span class="md-nav__icon md-icon"></span>
            线性神经网络
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    线性回归
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/softmax.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    softmax
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3_3" >
        
          
          <label class="md-nav__link" for="__nav_3_3_3" id="__nav_3_3_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    多层感知机
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_3_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_3_3">
            <span class="md-nav__icon md-icon"></span>
            多层感知机
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA/%E6%84%9F%E7%9F%A5%E6%9C%BA.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    感知机
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA/%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9_%E6%AC%A0%E6%8B%9F%E5%90%88_%E8%BF%87%E6%8B%9F%E5%90%88.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    模型选择&欠/过拟合
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA/%E6%9D%83%E9%87%8D%E8%A1%B0%E9%80%80.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    权重衰退
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3_4" >
        
          
          <label class="md-nav__link" for="__nav_3_3_4" id="__nav_3_3_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    注意力机制
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_3_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_3_4">
            <span class="md-nav__icon md-icon"></span>
            注意力机制
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/%E6%B3%A8%E6%84%8F%E5%8A%9B.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    注意力
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/%E5%A4%9A%E5%A4%B4%E6%B3%A8%E6%84%8F%E5%8A%9B.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    多头注意力
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E4%B8%8E%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    自注意力与位置编码
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/Transformer.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Transformer
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Blog
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            Blog
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../machine_learning/Datawhale/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Datawhale
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Blog/PointNet/analysis.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    PointNet
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Blog/PointMAE/analysis.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    PointMAE
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Blog/NeRF%26Instant_NGP/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    NeRF&Instant_NGP
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Blog/3DGS/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3DGS
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Blog/3DGS_reproduction/note.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3DGS_reproduction
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Blog/AAAI2025/log.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Intern_Blog
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../Zhangzhi_Xiong_CV.pdf" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CV
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#contents" class="md-nav__link">
    <span class="md-ellipsis">
      Contents
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="cs100-lecture-2">CS100 Lecture 2</h1>
<p>Variables <span style="color: black; font-family: Times New Roman; font-size: 1.05em;">I</span> and Arithmetic Types</p>
<h2 id="contents">Contents</h2>
<ul>
<li>Variable declaration</li>
<li>Arithmetic types</li>
<li>Bits and bytes</li>
<li>Integer types</li>
<li>Real floating types</li>
<li>Character types</li>
<li>Boolean type</li>
</ul>
<h1 id="variable-declaration">Variable declaration</h1>
<h2 id="type-of-a-variable">Type of a variable</h2>
<p>Every variable in C has a type.</p>
<ul>
<li>The type is <strong>fully deterministic</strong> and <strong>cannot be changed</strong>.</li>
<li>The type is <strong>known even when the program is not run</strong>.</li>
<li>The type is known at <strong>compile-time</strong>.</li>
<li>C is <strong>statically-typed</strong>.   C has a <strong>static type system</strong>.</li>
<li>In contrast, Python is <strong>dynamically-typed</strong>.</li>
</ul>
<h2 id="statically-typed-vs-dynamically-typed">Statically-typed vs dynamically-typed</h2>
<p>Python: dynamically typed</p>
<pre><code class="language-python">a = 42       # Type of a is int.
a = &quot;hello&quot;  # Type of a becomes str.
</code></pre>
<p>C: statically-typed</p>
<pre><code class="language-c">int a = 42;  // Type of a is int.
a = &quot;hello&quot;; // Error! Types mismatch!
</code></pre>
<p>The type of a variable</p>
<ul>
<li>is explicitly written on declaration, and is known at compile-time, and cannot be changed</li>
</ul>
<p>A type-related error in C is <em>(usually)</em> a <strong>compile error</strong>:</p>
<ul>
<li>It stops the compiler. The executable will not be generated.</li>
</ul>
<h2 id="declare-a-variable">Declare a variable</h2>
<p>To declare a variable, we need to specify its <strong>type</strong> and <strong>name</strong>.</p>
<pre><code class="language-c">Type name;
</code></pre>
<p>We may declare multiple variables of a same type in one declaration statement, separated by <code>,</code>:</p>
<pre><code class="language-c">int x, y; // Declares two variables `x` and `y`, both having type `int`.
</code></pre>
<p>A <strong>variable declaration</strong> can be placed</p>
<ul>
<li>inside a function, which declares a <strong>local variable</strong>, or</li>
<li>outside of any functions, which declares a <strong>global variable</strong>.</li>
</ul>
<h2 id="readability-matters">Readability matters</h2>
<p><strong>[Best practice]</strong> <u>Declare the variable when you first use it!</u></p>
<ul>
<li>If the declaration and use of the variable are too separated, it will become much more difficult to figure out what they are used for as the program goes longer.</li>
</ul>
<p><strong>[Best practice]</strong> <u>Use meaningful names!</u></p>
<ul>
<li>The program would be a mess if polluted with names like <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>x</code>, <code>y</code>, <code>cnt</code>, <code>cnt_2</code>, <code>flag1</code>, <code>flag2</code>, <code>flag3</code> everywhere.</li>
<li>Use meaningful names: <code>sumOfScore</code>, <code>student_cnt</code>, <code>open_success</code>, ...</li>
</ul>
<p><strong>Readability is very important.</strong> Many students debug day and night simply because their programs are not human-readable.</p>
<h2 id="use-of-global-variables">Use of global variables</h2>
<p>One reason for using global variables is to have them shared between functions:</p>
<pre><code class="language-c">void work(void) {
  // Error: `input` was not decared
  // in this scope.
  printf(&quot;%d\n&quot;, input);
}
int main(void) {
  int input;
  scanf(&quot;%d&quot;, &amp;input);
  work();
}
</code></pre>
<h2 id="initialize-a-variable">Initialize a variable</h2>
<p>A variable can be <strong>initialized</strong> on declaration.</p>
<pre><code class="language-c">int x = 42; // Declares the variable `x` of type `int`,
            // and initializes its value to 42.
int a = 0, b, c = 42; // Declares three `int` variables, with `a` initialized
                      // to 0, `c` initialized to 42, and `b` uninitialized.
</code></pre>
<p>This is syntactically <strong>different</strong> (though seems equivalent) to</p>
<pre><code class="language-c">int x;  // Declares `x`, uninitialized.
x = 42; // Assigns 42 to `x`.
</code></pre>
<p><strong>[Best practice]</strong> <u>Initialize the variable if possible. Prefer initialization to later assignment.</u></p>
<h1 id="arithmetic-types">Arithmetic types</h1>
<h2 id="integer-types">Integer types</h2>
<p>Is <code>int</code> equivalent to 正整数?</p>
<ul>
<li>Is there a limitation on the numbers that <code>int</code> can represent?</li>
</ul>
<p>Experiment:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
  int x = 1;
  while (1) {
    printf(&quot;%d\n&quot;, x);
    x *= 2; // x = x * 2
    getchar();
  }
}
</code></pre>
<ul>
<li><code>1073741824
  -2147483648
  0
  0</code></li>
</ul>
<h2 id="bits-and-bytes">Bits and bytes</h2>
<p>Information is stored in computers <strong>in binary</strong>.</p>
<ul>
<li><span class="arithmatex">\(42_{\text{ten}}=101010_{\text{two}}\)</span>.</li>
</ul>
<p>A <strong>bit</strong> is either <span class="arithmatex">\(0\)</span> or <span class="arithmatex">\(1\)</span>.</p>
<ul>
<li>The binary representation of <span class="arithmatex">\(42\)</span> consists of <span class="arithmatex">\(6\)</span> bits.</li>
</ul>
<p>A <strong>byte</strong> is <span class="arithmatex">\(8\)</span> bits <span class="arithmatex">\({}^{\textcolor{red}{2}}\)</span> grouped together like <span class="arithmatex">\(10001001\)</span>.</p>
<ul>
<li>At least <span class="arithmatex">\(1\)</span> byte is needed to store <span class="arithmatex">\(42\)</span>.</li>
<li>At least <span class="arithmatex">\(3\)</span> bytes are needed to store <span class="arithmatex">\(142857_{\text{ten}}=100010111000001001_{\text{two}}\)</span></li>
</ul>
<p>A 32-bit number: <span class="arithmatex">\(2979269462_{\text{ten}}=10110001100101000000101101010110_{\text{two}}\)</span>.</p>
<p><a align="center">
  <img src="C:\Users\23714\Desktop\CS100-slides-spring2024-master\CS100-slides-spring2024-master\l2\img\32bitint.png">
</a></p>
<h2 id="integer-types_1">Integer types</h2>
<p>An integer type in C is either <strong>signed</strong> or <strong>unsigned</strong>, and has a <strong>width</strong> denoting the number of bits that can be used to represent values.</p>
<p>Suppose we have an integer type of <span class="arithmatex">\(n\)</span> bits in width.</p>
<ul>
<li>If the type is <strong>signed</strong> <span class="arithmatex">\({}^{\textcolor{red}{3}}\)</span>, the range of values that can be represented is <span class="arithmatex">\(\left[-2^{n-1},2^{n-1}-1\right]\)</span>.</li>
<li>
<p>If the type is <strong>unsigned</strong>, the range of values that can be represented is <span class="arithmatex">\(\left[0, 2^n-1\right]\)</span>.</p>
</li>
<li>
<p>The keyword <code>int</code> is optional in types other than <code>int</code>:</p>
</li>
<li>e.g. <code>short int</code> and <code>short</code> name the same type.</li>
<li>
<p>e.g. <code>unsigned int</code> and <code>unsigned</code> name the same type.</p>
</li>
<li>
<p>"Unsigned-ness" needs to be written explicitly: <code>unsigned int</code>, <code>unsigned long</code>, ...</p>
</li>
<li>Types without the keyword <code>unsigned</code> are signed by default:</li>
<li>e.g. <code>signed int</code> and <code>int</code> name the same type.</li>
<li>e.g. <code>signed long int</code>, <code>signed long</code>, <code>long int</code> and <code>long</code> name the same type.</li>
</ul>
<h2 id="width-of-integer-types">Width of integer types</h2>
<div align="center">


| type        | width (at least) | width (usually) |
| ----------- | ---------------- | --------------- |
| `short`     | 16 bits          | 16 bits         |
| `int`       | 16 bits          | 32 bits         |
| `long`      | 32 bits          | 32 or 64 bits   |
| `long long` | 64 bits          | 64 bits         |
| </div>
<pre><code>  |                  |                 |
</code></pre>
<ul>
<li>A signed type has the same width as its <code>unsigned</code> counterpart.</li>
<li><strong>It is also guaranteed that <code>sizeof(short)</code> <span class="arithmatex">\(\leqslant\)</span> <code>sizeof(int)</code> <span class="arithmatex">\(\leqslant\)</span> <code>sizeof(long)</code> <span class="arithmatex">\(\leqslant\)</span> <code>sizeof(long long)</code>.</strong></li>
<li><code>sizeof(T)</code> is the number of <strong>bytes</strong> that <code>T</code> holds.</li>
</ul>
<h2 id="implementation-defined-behaviors">Implementation-defined behaviors</h2>
<p>The standard states that the exact width of the integer types is <strong>implementation-defined</strong>.</p>
<ul>
<li><strong>Implementation</strong>: The compiler and the standard library.</li>
<li>An implementation-defined behavior depends on the compiler and the standard library, and is often also related to the hosted environment (e.g. the operating system).</li>
</ul>
<h2 id="which-one-should-i-use">Which one should I use?</h2>
<p><strong><code>int</code> is the most optimal integer type for the platform.</strong></p>
<ul>
<li>Use <code>int</code> for integer arithmetic by default.</li>
<li>Use <code>long long</code> if the range of <code>int</code> is not large enough.</li>
<li>Use smaller types (<code>short</code>, or even <code>unsigned char</code>) for memory-saving or other special purposes.</li>
<li>Use <code>unsigned</code> types for special purposes. We will see some in later lectures.</li>
</ul>
<h2 id="real-floating-types">Real floating types</h2>
<p>"Floating-point": The number's radix point can "float" anywhere to the left, right, or between the significant digits of the number.</p>
<p>Real floating-point types can be used to represent <em>some</em> real values.</p>
<ul>
<li>Real floating-point types <span class="arithmatex">\(\neq\mathbb R\)</span>.</li>
</ul>
<h2 id="which-one-should-i-use_1">Which one should I use?</h2>
<p>Use <code>double</code> for real floating-point arithmetic by default.</p>
<ul>
<li>In some cases the precision of <code>float</code> is not enough.</li>
<li>Don't worry about efficiency! <code>double</code> arithmetic is not necessarily slower than <code>float</code>.</li>
</ul>
<p><strong>Do not use floating-point types for integer arithmetic!</strong></p>
<h2 id="scanfprintf"><code>scanf</code>/<code>printf</code></h2>
<div style="display: grid; grid-template-columns: 1fr 1fr;">
  <div align="center">


| type        | format specifier |
| ----------- | ---------------- |
| `short`     | `%hd`            |
| `int`       | `%d`             |
| `long`      | `%ld`            |
| `long long` | `%lld`           |
| </div>      |                  |

  <div align="center">


| type                 | format specifier |
| -------------------- | ---------------- |
| `unsigned short`     | `%hu`            |
| `unsigned`           | `%u`             |
| `unsigned long`      | `%lu`            |
| `unsigned long long` | `%llu`           |
| </div>               |                  |
| </div>
<pre><code>           |                  |
</code></pre>
<ul>
<li><code>%f</code> for <code>float</code>, <code>%lf</code> for <code>double</code>, and <code>%Lf</code> for <code>long double</code>.</li>
</ul>
<h2 id="character-types">Character types</h2>
<p>The C standard provides three <strong>different</strong> character types: <code>signed char</code>, <code>unsigned char</code> and <code>char</code>.</p>
<p>Let <code>T</code> <span class="arithmatex">\(\in\{\)</span><code>signed char</code>, <code>unsigned char</code>, <code>char</code><span class="arithmatex">\(\}\)</span>. It is guaranteed that</p>
<p><code>1 == sizeof(T) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long)</code>.</p>
<ul>
<li><strong><code>T</code> takes exactly 1 byte</strong>.</li>
</ul>
<p>Question: What is the valid range of <code>signed char</code>? <code>unsigned char</code>?</p>
<ul>
<li><code>signed char</code>: <span class="arithmatex">\([-128, 127]\)</span>.</li>
<li><code>unsigned char</code>: <span class="arithmatex">\([0, 255]\)</span>.</li>
</ul>
<p>What? A character is an integer?</p>
<h2 id="ascii-american-standard-code-for-information-interchange">ASCII (American Standard Code for Information Interchange)</h2>
<p><a align="center">
  <img src="C:\Users\23714\Desktop\CS100-slides-spring2024-master\CS100-slides-spring2024-master\l2\img\ascii_table.png" width=900 >
</a></p>
<p>Important things to remember:</p>
<ul>
<li><span class="arithmatex">\([\)</span><code>'0'</code><span class="arithmatex">\(,\)</span><code>'9'</code><span class="arithmatex">\(]=[48, 57]\)</span>.</li>
<li><span class="arithmatex">\([\)</span><code>'A'</code><span class="arithmatex">\(,\)</span><code>'Z'</code><span class="arithmatex">\(]=[65, 90]\)</span>.</li>
<li><span class="arithmatex">\([\)</span><code>'a'</code><span class="arithmatex">\(,\)</span><code>'z'</code><span class="arithmatex">\(]=[97, 122]\)</span>.</li>
</ul>
<h2 id="best-practice-avoid-magic-numbers">[Best practice] <u>Avoid magic numbers</u></h2>
<p>What is the meaning of <code>32</code> here? <span class="arithmatex">\(\Rightarrow\)</span> a magic number.</p>
<pre><code class="language-c">char to_uppercase(char x) {
  return x - 32;
}
</code></pre>
<p>Write it in a more human-readable way:</p>
<pre><code class="language-c">char to_uppercase(char x) {
  return x - ('a' - 'A');
}
</code></pre>
<h2 id="escape-sequence">Escape sequence</h2>
<p>Some special characters are not directly representable: newline, tab, quote, ...</p>
<div style="display: grid; grid-template-columns: 1fr 1fr;">
  <div align="center">


| escape sequence | description  |
| --------------- | ------------ |
| `\'`            | single quote |
| `\"`            | double quote |
| `\\`            | backslash    |
| </div>          |              |

  <div align="center">


| escape sequence | description     |
| --------------- | --------------- |
| `\n`            | newline         |
| `\r`            | carriage return |
| `\t`            | horizontal tab  |
| </div>          |                 |
| </div>
<pre><code>      |                 |
</code></pre>
<h2 id="character-types_1">Character types</h2>
<p><code>char</code>, <code>signed char</code> and <code>unsigned char</code> are <strong>three different types</strong>.</p>
<ul>
<li>Whether <code>char</code> is signed or unsigned is <strong>implementation-defined</strong>.</li>
<li>If <code>char</code> is signed (unsigned), it represents the same set of values as the type <code>signed char</code> (<code>unsigned char</code>), but <strong>they are not the same type</strong>.</li>
<li>In contrast, <code>T</code> and <code>signed T</code> are the same type for <code>T</code> <span class="arithmatex">\(\in\{\)</span><code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code><span class="arithmatex">\(\}\)</span>.</li>
</ul>
<p>For almost all cases, use <code>char</code> (or, sometimes <code>int</code>) to represent characters.</p>
<p><code>signed char</code> and <code>unsigned char</code> are used for other purposes.</p>
<p>To read/print a <code>char</code> using <code>scanf</code>/<code>printf</code>, use <code>%c</code>.</p>
<h2 id="boolean-type-bool-since-c99">Boolean type: <code>bool</code> (since C99)</h2>
<p>A type that represents true/false, 0/1, yes/no, ...</p>
<p>To access the name <code>bool</code>, <code>true</code> and <code>false</code>, <code>&lt;stdbool.h&gt;</code> is needed. (until C23)</p>
<p>Example: Define a function that accepts a character and returns whether that character is a lowercase letter.</p>
<div style="display: grid; grid-template-columns: 1fr 1fr;">
  <div>


Before C99, using `int`, `0` and `1`:


<pre><code class="language-c">int is_lowercase(char c) {
  if (c &gt;= 'a' &amp;&amp; c &lt;= 'z')
    return 1;
  else
    return 0;
}
</code></pre>


  <div>


Since C99, using `bool`, `false` and `true`:


<pre><code class="language-c">bool is_lowercase(char c) {
  if (c &gt;= 'a' &amp;&amp; c &lt;= 'z')
    return true;
  else
    return false;
}
</code></pre>


<div style="display: grid; grid-template-columns: 1fr 1fr;">
  <div>


Before C99, using `int`, `0` and `1`:


<pre><code class="language-c">int is_lowercase(char c) {
  if (c &gt;= 'a' &amp;&amp; c &lt;= 'z')
    return 1;
  else
    return 0;
}
</code></pre>


  <div>


Since C99, using `bool`, `false` and `true`:


<pre><code class="language-c">bool is_lowercase(char c) {
  if (c &gt;= 'a' &amp;&amp; c &lt;= 'z')
    return true;
  else
    return false;
}
</code></pre>


Both return values can be used as follows:


<pre><code class="language-c">char c; scanf(&quot;%c&quot;, &amp;c);
if (is_lowercase(c)) {
  // do something when c is lowercase ...
}
</code></pre>


# CS100 Lecture 3

Operators and Control Flow <span style="color: black; font-family: Times New Roman; font-size: 1.05em;">I</span>

## Contents

- Operators
  - `+`, `-`, `*`, `/`, `%`
  - Compound assignment operators
  - Signed integer overflow
  - `++` and `--`
- Control flow
  - `if`-`else`
  - `while`
  - `for`

---

# Operators

## The calculator

Accept input of the form `x op y`, where `x` and `y` are floating-point numbers and `op` $\in\{$ `'+'`, `'-'`, `'*'`, `'/'` $\}$. Print the result.

<div style="display: grid; grid-template-columns: 1fr 1fr;">
  <div>



<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
  double x, y;
  char op;
  scanf(&quot;%lf %c %lf&quot;, &amp;x, &amp;op, &amp;y);
  if (op == '+')
    printf(&quot;%lf\n&quot;, x + y);
  else if (op == '-')
    printf(&quot;%lf\n&quot;, x - y);
</code></pre>




<pre><code class="language-c">  else if (op == '*')
    printf(&quot;%lf\n&quot;, x * y);
  else if (op == '/')
    printf(&quot;%lf\n&quot;, x / y);
  else
    printf(&quot;Invalid operator.\n&quot;);
  return 0;
}
</code></pre>


## `+`, `-`, `*`, `/`, `%`

- `+` and `-` have two versions: unary (`+a`, `-a`) and binary (`a+b`, `a-b`).

  - The unary `+`/`-` and binary `+`/`-` are **different operators**, although they use the same notation.

- Operator precedence:

  $\{$ unary `+`, unary `-` $\}>\{$ `*`, `/`, `%` $\}>\{$ binary `+`, binary `-` $\}$

  e.g. `a + b * c` is interpreted as `a + (b * c)`, instead of `(a + b) * c`.

  $\Rightarrow$ We will talk more about operator precedence later.

## Binary `+`, `-` and `*`, `/`

`a + b`, `a - b`, `a * b`, `a / b`

Before the evaluation of such an expression, the operands (`a`, `b`) undergo a sequence of **type conversions**.

- The [detailed rules of the conversions](https://en.cppreference.com/w/c/language/conversion#Usual_arithmetic_conversions) are very complex,
  - including *promotions*, conversions between `signed` and `unsigned` types, conversions between integers and floating-point types, etc.
  - We only need to remember some common ones.
- In the end, the operands will be converted to **a same type**, denoted `T`. **The result type is also `T`.**

`a + b`, `a - b`, `a * b`, `a / b`

If any one operand is of floating-point type and the other is an integer, **the integer will be implicitly converted to that floating-point type**.

Example:


<pre><code class="language-c">double pi = 3.14;
int diameter = 20;
WhatType c = pi * diameter; // What is the type of this result?
</code></pre>


`a + b`, `a - b`, `a * b`, `a / b`

If any one operand is of floating-point type and the other is an integer, **the integer will be implicitly converted to that floating-point type**.

Example:


<pre><code class="language-c">double pi = 3.14;
int diameter = 20;
double c = pi * diameter; // 62.8
</code></pre>


The value of `diameter` is implicitly converted to a value of type `double`. Then, a floating-point multiplication is performed, yielding a result of type `double`.

\* Does this rule make sense? - Yes, because $\mathbb Z\subseteq\mathbb R$.

`a + b`, `a - b`, `a * b`, `a / b`

If any one operand is of floating-point type and the other is an integer, **the integer will be implicitly converted to that floating-point type**, and the result type is that floating-point type.

Similarly, if the operands are of types `int` and `long long`, the `int` value will be implicitly converted to `long long`, and the result type is `long long`. ${}^{\textcolor{red}{1}}$

## Division: `a / b`

Assume `a` and `b` are of the same type `T` (after conversions as mentioned above).

- Then, the result type is also `T`.

Two cases:

- If `T` is a floating-point type, this is a floating-point division.
  - The result is no surprising.
- If `T` is an integer type, this is an integer division.
  - The result is **truncated towards zero** (since C99 and C++11) ${}^{\textcolor{red}{2}}$.
  - What is the result of `3 / -2`?

Let `a` and `b` be two integers.

- What is the difference between `a / 2` and `a / 2.0`?
- What does `(a + 0.0) / b` mean? What about `1.0 * a / b`?



If `T` is an integer type, this is an integer division.

  - The result is **truncated towards zero** (since C99 and C++11) ${}^{\textcolor{red}{2}}$.
  - What is the result of `3 / -2`?
    - `-1.5` truncated towards zero, which is `-1`.


What is the difference between `a / 2` and `a / 2.0`?

  - `a / 2` yields an integer, while `a / 2.0` yields a `double`.

What does `(a + 0.0) / b` mean? What about `1.0 * a / b`?

  - Both use floating-point division to compute $\dfrac ab$. The floating-point numbers `0.0` and `1.0` here cause the conversion of the other operands.

## Remainder: `a % b`

Example: `15 % 4 == 3`.

**`a` and `b` must have integer types.**

If `a` is negative, is the result negative? What if `b` is negative? What if both are negative?

Example: `15 % 4 == 3`.

**`a` and `b` must have integer types.**

For any integers `a` and `b`, the following always holds:

<div align="center">



<pre><code class="language-c">(a / b) * b + (a % b) == a
</code></pre>


</div>

## Compound assignment operators

`+=`, `-=`, `*=`, `/=`, `%=`

- `a op= b` is equivalent to `a = a op b`.
- e.g. `x *= 2` is equivalent to `x = x * 2`.
- **[Best practice]** <u>Learn to use these operators, to make your code clear and simple.</u>

## Signed integer overflow

If a **signed integer type** holds a value that is not in the valid range, **overflow** is caused.

Suppose `int` is 32-bit and `long long` is 64-bit.

Do the following computations cause overflow?


<pre><code class="language-c">int ival = 100000; long long llval = ival;
int result1 = ival * ival;               // (1) overflow
long long result2 = ival * ival;         // (2) overflow
long long result3 = llval * ival;        // (3) not overflow
long long result4 = llval * ival * ival; // (4) not overflow
</code></pre>


(1) $\left(10^5\right)^2=10^{10}>2^{31}-1$.

(2) The result type of the multiplication `ival * ival` is **`int`**, which causes overflow. This is not affected by the type of `result2`.

(3) Since `llval` is of type `long long`, the value of `ival` will be implicitly converted to `long long`, and then the multiplication yields a `long long` value.

(4) `*` is **left-associative**, so the expression `a * b * c` is interpreted as `(a * b) * c`.

$\Rightarrow$ We will talk about associativity in later lectures.

---

## Undefined behavior

Signed integer overflow is : **There are no restrictions on the behavior of the program.** Compilers are not required to diagnose undefined behavior (although many simple situations are diagnosed), and the compiled program is not required to do anything meaningful.

- It may yield some garbage values, or zero, or anything else;
- or, this statement may be removed if the compiler is clever enough;
- or, the program may crash;
- or, any other results beyond imagination.

More on undefined behaviors in recitations.



Unsigned integer arithmetic is always performed *modulo $2^n$*, where $n$ is the number of bits in that integer type.

For example, for `unsigned int` (assuming it is 32-bit)

- adding one to $2^{32}-1$ gives $0$ because $2^{32}\equiv 0\pmod{2^{32}}$, and
- subtracting one from $0$ gives $2^{32}-1$ because $-1\equiv 2^{32}-1\pmod{2^{32}}$.

\* "wrap-around"

## Increment/decrement operators

Unary operators that increment/decrement the value of a variable by `1`.

Postfix form: `a++`, `a--`

Prefix form: `++a`, `--a`

- `a++` and `++a` increment the value of `a` by `1`.
- `a--` and `--a` decrement the value of `a` by `1`.

The result of the **postfix** increment/decrement operators is the value of `a` **before incrementation/decrementation**.

**\* What does "result" mean?**



Unary operators that increment/decrement the value of a variable by `1`.

Postfix form: `a++`, `a--`

The result of the **postfix** increment/decrement operators is the value of `a` **before incrementation/decrementation**.


<pre><code class="language-c">int x = 42;
printf(&quot;%d\n&quot;, x++); // x becomes 43, but 42 is printed.
int y = x++; // y is initialized with 43. x becomes 44.
</code></pre>


Unary operators that increment/decrement the value of a variable by `1`.

Prefix form: `++a`, `--a`

The result of the **prefix** increment/decrement operators is the value of `a` **after incrementation/decrementation**.


<pre><code class="language-c">int x = 42;
printf(&quot;%d\n&quot;, ++x); // x becomes 43, and 43 is printed.
int y = ++x; // y is initialized with 44. x becomes 44.
</code></pre>


# CS100 Lecture 4

Operators and Control Flow <span style="color: black; font-family: Times New Roman; font-size: 1.05em;">II</span>, Functions

## Contents

- Operators
  - Operator precedence, associativity and evaluation order
  - Comparison operators `<`, `<=`, `>`, `>=`, `==`, `!=`
  - Logical operators `&&`, `||`, `!`
  - Conditional operator `?:`
  - Assignment operator `=`
- Control Flow
  - `do`-`while`
  - `switch`-`case`
- Functions

# Operators

---

## Operator precedence

[Operator precedence](https://en.cppreference.com/w/c/language/operator_precedence) defines the order in which operators are bound to their arguments.

Example: `*` and `/` have higher precedence than `+` and `-`, so `a + b * c` is interpreted as `a + (b * c)` instead of `(a + b) * c`.

**Operator precedence does not determine [evaluation order](https://en.cppreference.com/w/c/language/eval_order).**

- `f() + g() * h()` is interpreted as `f() + (g() * h())`, but the order in which `f`, `g` and `h` are called is **unspecified**.

## Associativity

Each operator is either **left-associative** or **right-associative**.

Operators with the same precedence have the same associativity.

Example: `+` and `-` are **left-associative**, so `a - b + c` is interpreted as `(a - b) + c`, instead of `a - (b + c)`.

**Associativity does not determine [evaluation order](https://en.cppreference.com/w/c/language/eval_order).**

- `f() - g() + h()` is interpreted as `(f() - g()) + h()`, but the order in which `f`, `g` and `h` are called is **unspecified**.

## Evaluation order

Unless otherwise stated, the order in which the operands are evaluated is **unspecified**.

- We will see that `&&`, `||` and `?:` (and also `,`, in recitations) have specified evaluation order of their operands.

Examples: In the following expressions, it is **unspecified** whether `f` is called before `g`.

- `f() + g()`
- `f() == g()`
- `some_function(f(), g())` (Note that the `,` here is not the [comma operator](https://en.cppreference.com/w/c/language/operator_other#Comma_operator).)
- ...

## Evaluation order and undefined behavior

Let `A` and `B` be two expressions. **The behavior is undefined if**

- the order in which `A` and `B` are evaluated is unspecified ${}^{\textcolor{red}{1}}$, and
- both `A` and `B` modify an object, or one modifies an object and the other uses its value ${}^{\textcolor{red}{2}}$.

Examples:


<pre><code class="language-c">i = ++i + i++; // undefined behavior
i = i++ + 1;   // undefined behavior
printf(&quot;%d, %d\n&quot;, i, i++); // undefined behavior
</code></pre>


Recall that **undefined behavior** means "everything is possible". We cannot make any assumptions about the behavior of the program.

---

## Terminology: Return type/value of an operator

When it comes to "the return type/value of an operator", we are actually viewing the operator as a function:


<pre><code class="language-c">int operator_plus(int a, int b) {
  return a + b;
}
int operator_postfix_inc(int &amp;x) { // We must use a C++ notation here.
  int old = x;
  x += 1;
  return old;
}
</code></pre>


The "return value" of an operator is the value of the expression it forms.

The "return type" of an operator is the type of its return value.

## [Comparison operators](https://en.cppreference.com/w/c/language/operator_comparison)

Comparison operators are binary operators that test a condition and return `1` if that condition is logically **true** and `0` if it is logically **false**.

<div style="display: grid; grid-template-columns: 1fr 1fr;">
  <div align="center">


| Operator | Operator name |
| -------- | ------------- |
| `a == b` | equal to      |
| `a != b` | not equal to  |
| `a < b`  | less than     |

  </div>

  <div align="center">


| Operator | Operator name            |
| -------- | ------------------------ |
| `a > b`  | greater than             |
| `a <= b` | less than or equal to    |
| `a >= b` | greater than or equal to |

  </div>
</div>

For most cases, the operands `a` and `b` are also converted to a same type, just as what happens for `a + b`, `a - b`, ...

Note: Comparison operators in C **cannot be chained**.

Example: `a < b < c` is interpreted as `(a < b) < c` (due to left-associativity), which means to

- compare `(a < b)` first, whose result is either `0` or `1`, and then
- compare `0 < c` or `1 < c`.

**To test $a<b<c$, use `a < b && b < c`.**

## [Logical operators](https://en.cppreference.com/w/c/language/operator_logical)

Logical operators apply standard  boolean algebra operations to their operands.

<div align="center">


| Operator | Operator name | Example    |
| -------- | ------------- | ---------- |
| `!`      | logical NOT   | `!a`       |
| `&&`     | logical AND   | `a && b`   |
| `\|\|`   | logical OR    | `a \|\| b` |
| </div>   |               |            |

`!a`, `a && b`, `a || b`

<div style="display: grid; grid-template-columns: 1fr 1fr;">
  <div>


Recall the boolean algebra:

<div align="center">


| $A$    | $B$   | $\neg A$ | $A\land B$ | $A\lor B$ |
| ------ | ----- | -------- | ---------- | --------- |
| True   | True  | False    | True       | True      |
| True   | False | False    | False      | True      |
| False  | True  | True     | False      | True      |
| False  | False | True     | False      | False     |
| </div> |       |          |            |           |
| </div> |       |          |            |           |

  <div>


For C logical operators:

<div align="center">


| `a`    | `b`    | `!a` | `a && b` | `a \|\| b` |
| ------ | ------ | ---- | -------- | ---------- |
| `!= 0` | `!= 0` | `0`  | `1`      | `1`        |
| `!= 0` | `== 0` | `0`  | `0`      | `1`        |
| `== 0` | `!= 0` | `1`  | `0`      | `1`        |
| `== 0` | `== 0` | `1`  | `0`      | `0`        |
| </div> |        |      |          |            |
| </div> |        |      |          |            |
| </div> |        |      |          |            |

Precedence: `!` $>$ comparison operators $>$ `&&` $>$ `||`.

Typical example: lexicographical comparison of two pairs $(a_1, b_1)$ and $(a_2,b_2)$


<pre><code class="language-c">int less(int a1, int b1, int a2, int b2) {
  return a1 &lt; a2 || (a1 == a2 &amp;&amp; b1 &lt; b2);
}
</code></pre>


The parentheses are optional here, but it improves readability.

## Avoid abuse of parentheses

Too many parentheses **reduce** readability:


<pre><code class="language-c">int less(int a1, int b1, int a2, int b2) {
  return (((a1) &lt; (a2)) || (((a1) == (a2)) &amp;&amp; ((b1) &lt; (b2))));
  // Is this a1 &lt; b1 || (a1 == b1 &amp;&amp; a2 &lt; b2)
  //      or (a1 &lt; b1 || a1 == b1) &amp;&amp; a2 &lt; b2 ?
}
</code></pre>


**[Best practice]** <u>Use **one** pair of parentheses when two binary logical operators meet.</u>

## Short-circuit evaluation

`a && b` and `a || b` perform **short-circuit evaluation**:

- For `a && b`, `a` is evaluated first. If `a` compares equal to zero (is logically **false**), `b` is not evaluated.
  - $\mathrm{False}\land p\equiv\mathrm{False}$
- For `a || b`, `a` is evaluated first. If `a` compares not equal to zero (is logically **true**), `b` is not evaluated.
  - $\mathrm{True}\lor p\equiv\mathrm{True}$

**The evaluation order is specified!**

## Conditional operator

Syntax: `condition ? expressionT : expressionF`,

where `condition` is an expression of scalar type.

**The evaluation order is specified!**

- First, `condition` is evaluated.
- If `condition` compares not equal to zero (is logically **true**), `expressionT` is evaluated, and the result is the value of `expressionT`.
- Otherwise (if `condition` compares equal to zero, which is logically **false**), `expressionF` is evaluated, and the result is the value of `expressionF`.

## Conditional operator `?:`

Syntax: `condition ? expressionT : expressionF`,

Example: `to_uppercase(c)` returns the uppercase form of `c` if `c` is a lowercase letter, or `c` itself if it is not.


<pre><code class="language-c">char to_uppercase(char c) {
  if (c &gt;= 'a' &amp;&amp; c &lt;= 'z')
    return c - ('a' - 'A');
  else
    return c;
}
</code></pre>


Use `?:` to rewrite it:


<pre><code class="language-c">char to_uppercase(char c) {
  return c &gt;= 'a' &amp;&amp; c &lt;= 'z' ? c - ('a' - 'A') : c;
}
</code></pre>


  </div>
</div>

Syntax: `condition ? expressionT : expressionF`

Use it to replace some simple and short `if`-`else` statement.

**Avoid abusing it!** Nested conditional operators reduces readability significantly.


<pre><code class="language-c">int result = a &lt; b ? (a &lt; c ? a : c) : (b &lt; c ? b : c); // Um ...
</code></pre>


**[Best practice]** <u>Avoid more than two levels of nested conditional operators.</u>

## Assignment operator `=`

`lhs = rhs`

The assignment operator **returns the value of `lhs` after assignment**.

Moreover, the assignment operator is **right-associative**, making it possible to write "chained" assignments:


<pre><code class="language-c">int a = 0, b = 1, c = 2;
a = b = c; // interpreted as a = (b = c)
           // Both a and b are assigned with 2.
</code></pre>


# Control Flow

## `do`-`while`

<div style="display: grid; grid-template-columns: 1fr 1fr;">
  <div>


Syntax: `do loop_body while (condition);`

Executes `loop_body` repeatedly until the value of `condition` compares equal to zero (is logically **false**).

Example:


<pre><code class="language-c">int i = 0;
do {
  printf(&quot;%d&quot;, i++);
} while (i &lt; 5);
</code></pre>


Output: `01234`

Note that in each iteration, the condition is tested **after** the body is executed.


<pre><code class="language-c">int i = 0;
do {
  printf(&quot;%d&quot;, i++);
} while (i &lt; n);
</code></pre>


Even if `n == 0`, `0` is printed. The loop body is always executed at least once.

Rewrite a `do`-`while` loop using a `while` loop.


<pre><code class="language-c">do {
  // loop_body
} while (condition);
</code></pre>


Use `while (1)` and `break`:


<pre><code class="language-c">while (1) {
  // loop_body
  if (!condition)
    break;
}
</code></pre>


## `switch`-`case`

`switch (expression) { ... }`



<pre><code class="language-c">switch (op) {
case '+':
  printf(&quot;%lf\n&quot;, a + b); break;
case '-':
  printf(&quot;%lf\n&quot;, a - b); break;
case '*':
  printf(&quot;%lf\n&quot;, a * b); break;
case '/':
  printf(&quot;%lf\n&quot;, a / b); break;
default:
  printf(&quot;Invalid operator!\n&quot;);
  break;
}
</code></pre>



- First, `expression` is evaluated.
- Control finds the `case` label to which `expression` compares equal, and then goes to that label.
- Starting from the selected label, **all subsequent statements are executed until a `break;` or the end of the `switch` statement is reached.**
- Note that `break;` here has a special meaning.


- If no `case` label is selected and `default:` is present, the control goes to the `default:` label.

- `default:` is optional, and often appears in the end, though not necessarily.

- `break;` is often needed. Modern compilers often warn against a missing `break;``



The expression in a `case` label must be an integer [*constant expression*](https://en.cppreference.com/w/c/language/constant_expression), whose value is known at compile-time, such as `42`, `'a'`, `true`, ...


<pre><code class="language-c">int n; scanf(&quot;%d&quot;, &amp;n);
int x = 42;
switch (value) {
  case 3.14: // Error: It must have an integer type.
    printf(&quot;It is pi.\n&quot;);
  case n:    // Error: It must be a constant expression (known at compile-time)
    printf(&quot;It is equal to n.\n&quot;);
  case 42:   // OK.
    printf(&quot;It is equal to 42.\n&quot;);
  case x:    // Error: `x` is a variable, not treated as &quot;constant expression&quot;.
    printf(&quot;It is equal to x.\n&quot;);
}
</code></pre>


Another example: Determine whether a letter is vowel or consonant.


<pre><code class="language-c">switch (letter) {
  case 'a':
  case 'e':
  case 'i':
  case 'o':
  case 'u':
    printf(&quot;%c is vowel.\n&quot;, letter);
    break;
  default:
    printf(&quot;%c is consonant.\n&quot;, letter);
}
</code></pre>


# Functions

## Call and return

<div style="display: grid; grid-template-columns: 1fr 1fr;">
  <div>



<pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

double divide(int a, int b) {
  if (b == 0) {
    fprintf(stderr, &quot;Division by zero!\n&quot;);
    exit(EXIT_FAILURE);
  }
  return 1.0 * a / b;
}

int main(void) {
  int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
  double result = divide(x, y);
  printf(&quot;%lf\n&quot;, result);
  // ...
}
</code></pre>


  </div>

  <div>


- For the *call expression* `divide(x, y)`: First the arguments `x` and `y` are passed into `divide` as if the parameters are initialized ${}^{\textcolor{red}{3}}$ as follows:

  ```c
  int a = x;
  int b = y;
  ```

  Then control is transferred into the function `divide`, starting from the first statement.
  </div>
  </div>

`return` does two things:

- passes a value out to the *call site*.
  - This value is the result of the **call expression**.
  - Such a value does not exist if the function return type is `void`.
- transfers the control to the *call site*.
  </div>
  </div>


- The parentheses `()` in the expression `divide(x, y)` is the **function-call operator**.
- Even if the function accepts no parameters, the function-call operator should not be omitted.
- A statement like `f;` without the function-call operator is **valid**.
  - It is a statement that has no effect, just like `5;`, `2+3;`, `;` or `{}`.
    </div>
    </div>



If a function has return type `void`, the function does not pass a value to the call site.

For a non-`void` function:

- A `return something;` statement must be executed to return something.
- If control reaches the end of the function without a `return` statement, the return value is undefined. **The behavior is undefined** if such value is used.


<pre><code class="language-c">int do_something(int i) {
  printf(&quot;%d\n&quot;, i);
}
</code></pre>



<pre><code>a.c: In function ‘do_something’:
a.c:5:1: warning: control reaches end of non-void function [-Wreturn-type]
    5 | }
</code></pre>


The last `if (x > 0)` is not needed:


<pre><code class="language-c">int abs_int(int x) {
  if (x &lt; 0)
    return -x;
  else if (x == 0)
    return 0;
  else // x &gt; 0 must hold. No need to test it
    return x;
}
</code></pre>


It can be simplified as


<pre><code class="language-c">int abs_int(int x) {
  return x &lt; 0 ? -x : x;
}
</code></pre>


## Function declaration and definition

A **definition** of a function contains the function body.


<pre><code class="language-c">int sum(int a, int b) {
  return a + b;
}
</code></pre>


A **declaration** of a function contains only its return type, its name and the types of its parameters, ended with `;`.

The following statements declare **the same function**:


<pre><code class="language-c">int sum(int, int);
int sum(int x, int y);
int sum(int a, int);
</code></pre>


- A function should have only one definition, but can be declared many times.
- A definition is also a declaration, since it contains all the information that a declaration has.
- When a function is called, its declaration must be present.


<pre><code class="language-c">int sum(int, int);      // declares the function
int main(void) {
  int x = sum(2, 3);    // ok
}
int sum(int x, int y) { // gives its definition afterwards
  return x + y;
}
</code></pre>


## Scopes

<div style="display: grid; grid-template-columns: 1fr 1fr;">
  <div>



<pre><code class="language-c">int add(int x, int y) {
  return x + y;
}
int square(int x) {
  return x * x;
}
int main(void) {
  int x; scanf(&quot;%d&quot;, &amp;x);
  printf(&quot;%d\n&quot;, square(x));
  if (x == 42) {
    int x = 35;
    printf(&quot;%d\n&quot;, square(square(x)));
  }
  for (int x = 1; x &lt;= 10; ++x)
    printf(&quot;%d\n&quot;, square(x + 1));
  return 0;
}
</code></pre>


  <div>


- The scopes form a tree structure:

- ```
  global---add
         |-square
         |-main---if
                |-for
  ```

## Name lookup


- The scopes form a tree structure:

- ```
  global---add
         |-square
         |-main---if
                |-for
  ```

- When a name `x` is referenced, the **name lookup** for `x` is performed:

  - Only the declarations before the current position can be seen.
  - Lookup is performed from the innermost scope to the outer scopes, until a declaration is found.


- A declaration in an inner scope may hide a declaration in an outer scope that introduces the same name.

## Scopes and name lookup

**[Best practice]** <u>Declare a variable right before the use of it.</u> Declare it in a scope as small as possible.

**[Best practice]** <u>Don't worry about the same names in different scopes.</u>


<pre><code class="language-c">// The three `i`'s are local to the three loops. They will not collide.
for (int i = 0; i &lt; n; ++i)
  do_something(i);
for (int i = 0; i &lt; n; ++i)
  do_another_thing(i);
if (condition()) {
  for (int i = 0; i &lt; n; ++i)
    do_something_else(i);
}
</code></pre>


# CS100 Lecture 5

Variables <span style="color: black; font-family: Times New Roman; font-size: 1.05em;">II</span>, Pointers and Arrays <span style="color: black; font-family: Times New Roman; font-size: 1.05em;">I</span>

## Contents

- Variables
  - Local `static` variables
  - Initialization
  - `const` type qualifier
- Pointers
- Arrays

## Local `static` variables


<pre><code class="language-c">void start_game(Player *p1, Player *p2, int difficulty, GameWorld *world) {
  static bool called = false;
  if (called)
    report_an_error(&quot;You cannot start the game twice!&quot;);
  called = true;
  // ...
}
</code></pre>


The lifetime of a local `static` variable is **as long as** that of a global variable. *(They both have [static storage duration](https://en.cppreference.com/w/c/language/storage_duration#Storage_duration).)*

- A local `static` variable is initialized **during program startup**, and is destroyed **on program termination**.

It behaves just like a global variable, but its name is inside a function, which does not pollute the global name space.

## Initialization

If we declare a variable without explicit initialization, what is the value of it?

Experiment:



<pre><code class="language-c">#include &lt;stdio.h&gt;

int global;

int main(void) {
  int local;
  static int local_static;
  printf(&quot;%d, %d, %d\n&quot;, global, local,
         local_static);
  return 0;
}
</code></pre>



- Compiled without `-O2` (a kind of optimization):

  ```
  0, 22031, 0
  ```

- Compiled with `-O2`:

  ```
  0, 0, 0
  ```

## Implicit initialization [Very important]

If a variable is declared without explicit initialization:

- For local non-`static` variables, they are initialized to **indeterminate values**. In other words, they are **uninitialized**.

- For global or local `static` variables, they are [**empty-initialized**](https://en.cppreference.com/w/c/language/initialization#Empty_initialization) ${}^{\textcolor{red}{1}}$:

  - Pointers are initialized to *null pointer values* of their types. (later in this lecture)
  - Objects of integral types are initialized to `0`.
  - Objects of floating types are initialized to positive zero (`0.0`).
  - Other cases will be discussed in later lectures.

  \* Intuitively, such variables are initialized to some kind of "zero" ${}^{\textcolor{red}{2}}$. This is called [zero-initialization](https://en.cppreference.com/w/cpp/language/zero_initialization) in C++.

## Uninitialized garbage can be deadly!

**[Best practice]** <u>Always initialize the variable.</u>

Except in certain cases, e.g.


<pre><code class="language-c">// in some function
int n;           // uninitialized
scanf(&quot;%d&quot;, &amp;n); // A value is assigned to `n` immediately. This is OK.
// Now the value of `n` is not indeterminate. It can be used normally.
</code></pre>


## `const` type qualifier

Each type `T` (not `const`-qualified) has a `const`-qualified version of that type, written as `T const` or `const T`.

Any direct modification of variables with `const`-qualified types is not allowed:


<pre><code class="language-c">const int n = 100; // Type of `n` is `const int`.
++n; // Error.
</code></pre>


(Any indirect modification of `const` variables is undefined behavior; see in later lectures.)

A `const` variable cannot be modified after initialization.

Therefore, an uninitialized `const` local non-`static` variable is almost a non-stop ticket to undefined behavior.


<pre><code class="language-c">// in some function
const int n; // `n` has indeterminate values
n = 42; // Error: cannot modify a const variable.
scanf(&quot;%d&quot;, &amp;n); // Error: cannot modify a const variable.
</code></pre>


In C++, `const` variables of built-in types must be initialized.

# Pointers

## Pointers

A pointer *points to* a variable. The **value** of a pointer is the address of the variable that it points to.



<pre><code class="language-c">int i = 42;
int* pi = &amp;i;
printf(&quot;%d\n&quot;, *pi);
</code></pre>


- `int* pi;` declares a pointer named `pi`.
  - The type of `pi` is `int*`.
  - The type of the variable that `pi` points to ("pointee") is `int`.
- `&` is the **address-of operator**, used for taking the address of a variable.
- `*` in the expression `*pi` is the **indirection (dereference) operator**, used for obtaining the variable that a pointer points to.

A pointer *points to* a variable.

We can access and modify a variable through its address (or a pointer pointing to it).


<pre><code class="language-c">int num = 3;
int* ptr = &amp;num;
printf(&quot;%d\n&quot;, *ptr);  // 3
*ptr = 10;
printf(&quot;%d\n&quot;, num);   // 10
++num;
printf(&quot;%d\n&quot;, *ptr);  // 11
</code></pre>


## Declare a pointer

To declare a pointer: `PointeeType* ptr;`

- The type of `ptr` is `PointeeType*`.
  - Pointer types with different pointee types are **different types**: `int*` and `double*` are different.
- The asterisk `*` can be placed near either `PointeeType` or `ptr`:
  - `PointeeType* ptr;` and `PointeeType *ptr;` are the same declaration.
  - `PointeeType * ptr;`, `PointeeType       *   ptr;` and `PointeeType*ptr;` are also correct.

The asterisk `*` can be placed near either `PointeeType` or `ptr`:

- `PointeeType* ptr;` may be more intuitive?

However, when declaring more than one pointers in one declaration statement, an asterisk is needed **for every identifier**:


<pre><code class="language-c">int* p1, p2, p3;   // `p1` is of type `int*`, but `p2` and `p3` are ints.
int *q1, *q2, *q3; // `q1`, `q2` and `q3` all have the type `int*`.
int* r1, r2, *r3;  // `r1` and `r3` are of the type `int*`,
                   // while `r2` is an int.
</code></pre>


**[Best practice]** <u>Either `PointeeType *ptr` or `PointeeType* ptr` is ok. Choose one style and stick to it. But if you choose the second one, never declare more than one pointers in one declaration statement.</u>

## `&` and `*`

`&var` returns the address of the variable `var`.

- The result type is `Type *`, where `Type` is the type of `var`.
- `var` must be an object that has an identity (an *lvalue*) ${}^{\textcolor{red}{3}}$: `&42` or `&(a + b)` are not allowed.

`*expr` returns **the variable** whose address is the value of `expr`.

- `expr` must have a pointer type `PointeeType *`. The result type is `PointeeType`.
- **The variable** is returned, not only its value. This means that we can modify the returned variable: `++*ptr` is allowed.

## `*`

In a **declaration** `PointeeType *ptr`, `*` is a part of the pointer type `PointeeType *`.

In an **expression** like `*ptr`, `*` is the **indirection (dereference) operator** used to obtain the variable whose address is the value of `ptr`.

Do not mix them up!

## The null pointer

The **null pointer value** is the "zero" value for pointer types ${}^{\textcolor{red}{4}}$.

- It can be obtained from the macro [`NULL`](https://en.cppreference.com/w/c/types/NULL), which is available from many standard library header files (e.g. `<stddef.h>`, `<stdio.h>`, `<stdlib.h>`):

  ```c
  int *ptr = NULL; // `ptr` is a null pointer.
  ```

- It can also be obtained from the integer literal `0`.

  ```c
  double *ptr = 0; // same as `double *ptr = NULL;`
  ```

- Conversion from a null pointer to an integer type results in `0`.

Note: Better null pointer values (`nullptr`) are available [in C23](https://en.cppreference.com/w/c/language/nullptr) and [in C++11](https://en.cppreference.com/w/cpp/language/nullptr).

The **null pointer value** is the "zero" value for pointer types ${}^{\textcolor{red}{4}}$.

A null pointer compares unequal to any pointer pointing to an object.

It is used for representing a pointer that "points nowhere".

**Dereferencing a null pointer is undefined behavior, and often causes severe runtime errors!**

- Because it is not pointing to an object.


<pre><code class="language-c">int *ptr = NULL;
printf(&quot;%d\n&quot;, *ptr); // undefined behavior
*ptr = 42; // undefined behavior
</code></pre>


## Implicit initialization of pointers

If a pointer is not explicitly initialized:

- Global or local `static`: Initialized to the null pointer value.
- Local non-`static`: Initialized to indeterminate values, or in other words, **uninitialized**.
  - Uninitialized pointers are often called **wild pointers**.

A wild pointer do not point to a specific object, and is not a null pointer either.

**Dereferencing a wild pointer is undefined behavior, and often causes severe runtime errors.**

**[Best practice]** <u>Avoid wild pointers.</u>

## Pointers that are not dereferenceable

A pointer `ptr` is dereferenceable. $\Leftrightarrow$ `*ptr` has no undefined behavior. $\Leftrightarrow$ `ptr` points to an existing object.

A pointer that does not point to an existing object may be

- uninitialized (wild), or
- a null pointer, or
- dangling (We will discuss this in later lectures.), or
- holding some other meaningless address: `int *p = 123`

Dereferencing such a pointer is undefined behavior, and usually causes severe runtime errors.

- Recall the "short-circuit" evaluation of binary logical operators:

  ```c
  if (ptr != NULL && *ptr == 42) { /* ... */ }
  ```

  When `ptr` is a null pointer, the right-hand side operand `*ptr == 42` won't be evaluated, so `ptr` is not dereferenced.

## Argument passing

What is the output? Is the value of `i` changed to `42`?



<pre><code class="language-c">void fun(int x) {
   x = 42;
 }
 int main(void) {
   int i = 30;
   fun(i);
   printf(&quot;%d\n&quot;, i); // 30
 }  
</code></pre>


The output is still `30`. `i` is not changed.

- The parameter `x` is initialized as if `int x = i;`, thus obtaining the **value** of `i`.
  - `x` and `i` are two independent variables.
- Modification on `x` does not influence `i`.

# Arrays

## Arrays

An array is a sequence of `N` objects of an *element type* `ElemType` stored **contiguously** in memory, where `N` $\in\mathbb Z_+$ is the *length* of it.


<pre><code class="language-c">ElemType arr[N];
</code></pre>


`N` must be a **constant expression** whose value is known at compile-time.


<pre><code class="language-c">int a1[10];      // OK. A literal is a constant expression.
#define MAXN 10
int a2[MAXN];    // OK. `MAXN` is replaced with `10` by the preprocessor.
int n; scanf(&quot;%d&quot;, &amp;n);
int a[n];        // A C99 VLA (Variable-Length Array), whose length is
                 // determined at runtime.
</code></pre>


For now, we do not recommend the use of VLAs. We will talk more about it in recitations.

An array is a sequence of `N` objects of an *element type* `ElemType` stored **contiguously** in memory, where `N` $\in\mathbb Z_+$ is the *length* of it.


<pre><code class="language-c">ElemType arr[N]; // The type of `arr` is `ElemType [N]`.
</code></pre>


The type of an array consists of two parts:

1. the element type `ElemType`, and
2. the length of the array `[N]`.


<pre><code class="language-c">ElemType arr[N];
</code></pre>


Use `arr[i]` to obtain the `i`-th element of `arr`, where `i` $\in[0,N)$.



<pre><code class="language-c">int a[10];

bool find(int value) {
  for (int i = 0; i &lt; 10; ++i)
    if (a[i] == value)
      return true;
  return false;
}
</code></pre>




<pre><code class="language-c">int main(void) {
  int n; scanf(&quot;%d&quot;, &amp;n);
  for (int i = 0; i &lt; n; ++i)
    scanf(&quot;%d&quot;, &amp;a[i]);
  for (int i = 0; i &lt; n; ++i)
    a[i] *= 2;
  // ...
}
</code></pre>


The subscript `i` is an integer within the range $[0,N)$. **Array subscript out of range is undefined behavior, and usually causes severe runtime errors.**

The compiler may assume that the program is free of undefined behaviors:

If an array is declared without explicit initialization:

- Global or local `static`: Empty-initialization $\Rightarrow$ Every element is empty-initialized.
- Local non-`static`: Every element is initialized to indeterminate values (uninitialized).

Arrays can be initialized from [brace-enclosed lists](https://en.cppreference.com/w/c/language/array_initialization#Initialization_from_brace-enclosed_lists):

- Initialize the beginning few elements:

  ```c
  int a[10] = {2, 3, 5, 7}; // Correct: Initializes a[0], a[1], a[2], a[3]
  int b[2] = {2, 3, 5};     // Error: Too many initializers
  int c[] = {2, 3, 5};      // Correct: 'c' has type int[3].
  int d[100] = {};          // Correct in C++ and since C23.
  ```

- Initialize designated elements (since C99):

  ```c
  int e[10] = {[0] = 2, 3, 5, [7] = 7, 11, [4] = 13};
  ```

If an array is explicitly initialized, all the elements that are not explicitly initialized are **empty-initialized**.


<pre><code class="language-c">int main(void) {
  int a[10] = {1, 2, 3}; // a[3], a[4], ... are all initialized to zero.
  int b[100] = {0};      // All elements of b are initialized to zero.
  int c[100] = {1};      // c[0] is initialized to 1,
                         // and the rest are initialized to zero.
}
</code></pre>


**`= {x}` is not initializing all elements to `x`!**

## Nested arrays

The C answer to "multidimensional arrays" is **nested arrays**, which is in fact **arrays of arrays**:


<pre><code class="language-c">int a[10][20];

bool find(int value) {
  for (int i = 0; i &lt; 10; ++i)
    for (int j = 0; j &lt; 20; ++j)
      if (a[i][j] == value)
        return true;
  return false;
}
</code></pre>


---

## Initialization of nested arrays


<pre><code class="language-c">int a[4][3] = { // array of 4 arrays of 3 ints each (4x3 matrix)
    { 1 },      // row 0 initialized to {1, 0, 0}
    { 0, 1 },   // row 1 initialized to {0, 1, 0}
    { [2]=1 },  // row 2 initialized to {0, 0, 1}
};              // row 3 initialized to {0, 0, 0}
int b[4][3] = {    // array of 4 arrays of 3 ints each (4x3 matrix)
  1, 3, 5, 2, 4, 6, 3, 5, 7 // row 0 initialized to {1, 3, 5}
};                          // row 1 initialized to {2, 4, 6}
                            // row 2 initialized to {3, 5, 7}
                            // row 3 initialized to {0, 0, 0}
int y[4][3] = {[0][0]=1, [1][1]=1, [2][0]=1};  // row 0 initialized to {1, 0, 0}
                                               // row 1 initialized to {0, 1, 0}
                                               // row 2 initialized to {1, 0, 0}
                                               // row 3 initialized to {0, 0, 0}
</code></pre>


# CS100 Lecture 6

Pointers and Arrays <span style="color: black; font-family: Times New Roman; font-size: 1.05em;">II</span>

## Contents

Pointers and Arrays

- Pointer arithmetic
- Array-to-pointer conversion
- Pass an array to a function
- Pass a nested array to a function
- Do we need an array?

# Pointers and Arrays

## Pointer arithmetic

Let `p` be a pointer of type `T *` and let `i` be an integer.

- `p + i` returns the address equal to the value of `(char *)p + i * sizeof(T)`. In other words, pointer arithmetic uses the unit of the pointed-to type.
- If we let `p = &a[0]` (where `a` is an array of type `T [N]`), then
  - `p + i` is equivalent to `&a[i]`, and
  - `*(p + i)` is equivalent to `a[i]`.

- Arithmetic operations `i + p`, `p += i`, `p - i`, `p -= i`, `++p`, `p++`, `--p`, `p--` are defined in the same way.

## Array-to-pointer conversion

If we let `p = &a[0]` (where `a` is an array of type `T [N]`), then

- `p + i` is equivalent to `&a[i]`, and
- `*(p + i)` is equivalent to `a[i]`.

Considering the close relationship between arrays and pointers, an array can be **implicitly converted** to a pointer to the first element: **`a` $\rightarrow$ `&a[0]`, `T [N]` $\rightarrow$ `T *`**.

- `p = &a[0]` can be written as `p = a` directly.
- `*a` is equivalent to `a[0]`.

We can use pointers to traverse an array:


<pre><code class="language-c">int a[10];

bool find(int value) {
  for (int *p = a; p &lt; a + 10; ++p)
    if (*p == value)
      return true;
  return false;
}
</code></pre>


## Subtraction of pointers

Let `a` be an array of length `N`. If `p1 == a + i` and `p2 == a + j` (where `i` and `j` are nonnegative integers), the expression `p1 - p2`

- has the value equal to `i - j`, and
- has the type `ptrdiff_t`, which is a **signed** integer type declared in `<stddef.h>`.
  - The size of `ptrdiff_t` is implementation-defined. For example, it might be 64-bit on a 64-bit machine, and 32-bit on a 32-bit machine.
- Here `i`, `j` $\in[0,N]$ (closed interval), i.e. `p1` or `p2` may point to the *"past-the-end"* position of `a`.

## Pointer arithmetic

Pointer arithmetic can only happen within the range of an array and its "past-the-end" position (indexed $[0,N]$). For other cases, **the behavior is undefined**.

Examples of undefined behaviors:

- `p1 - p2`, where `p1` and `p2` point to the positions of two different arrays.
- `p + 2 * N`, where `p` points to some element in an array of length `N`.
- `p - 1`, where `p` points to the first element `a[0]` of some array `a`.

Note that the evaluation of the innocent-looking expression `p - 1`, without dereferencing it, is still undefined behavior and may fail on some platforms.

## Pass an array to a function

The only way ${}^{\textcolor{red}{1}}$ of passing an array to a function is to **pass the address of its first element**.

The following declarations are equivalent:


<pre><code class="language-c">void fun(int *a);
void fun(int a[]);
void fun(int a[10]);
void fun(int a[2]);
</code></pre>


In all these declarations, the type of the parameter `a` is `int *`.

- How do you verify that?

## Pass an array to a function


<pre><code class="language-c">void fun(int a[100]);
</code></pre>


The type of the parameter `a` is `int *`. How do you verify that?


<pre><code class="language-c">void fun(int a[100]) {
  printf(&quot;%d\n&quot;, (int)sizeof(a));
}
</code></pre>


Output: (On 64-bit Ubuntu 22.04, GCC 13)


<pre><code>8
</code></pre>


- If the type of `a` is `int[100]` as declared, the output should be `400` (assuming `int` is 32-bit).

## Pass an array to a function

Even if you declare the parameter as an array (either `T a[N]` or `T a[]`), its type is still a pointer `T*`: **You are allowed to pass anything of type `T*` to it.**

- Array of element type `T` with any length is allowed to be passed to it.


<pre><code class="language-c">void print(int a[10]) {
  for (int i = 0; i &lt; 10; ++i)
    printf(&quot;%d\n&quot;, *(a + i));
}
int main(void) {
  int x[20] = {0}, y[10] = {0}, z[5] = {0}, w = 42;
  print(x);  // OK
  print(y);  // OK
  print(z);  // Allowed by the compiler, but undefined behavior!
  print(&amp;w); // Still allowed by the compiler, also undefined behavior!
}
</code></pre>


Even if you declare the parameter as an array (either `T a[N]` or `T a[]`), its type is still a pointer `T*`: **You are allowed to pass anything of type `T*` to it.**

- Array of element type `T` with any length is allowed to be passed to it.

The length `n` of the array is often passed explicitly as another argument, so that the function can know how long the array is.


<pre><code class="language-c">void print(int *a, int n) {
  for (int i = 0; i &lt; n; ++i)
    printf(&quot;%d\n&quot;, *(a + i));
}
</code></pre>


## Subscript on pointers


<pre><code class="language-c">void print(int *a, int n) {
  for (int i = 0; i &lt; n; ++i)
    printf(&quot;%d\n&quot;, a[i]); // Look at this!
}
</code></pre>


Subscript on pointers is also allowed! `a[i]` is equivalent to `*(a + i)`. ${}^{\textcolor{red}{2}}$

## Return an array?

There is no way of returning an array from the function.

Returning the address of its first element is ok, **but be careful**:


This is OK:


<pre><code class="language-c">int a[10];

int *foo(void) {
  return a;
}
</code></pre>



This returns an **invalid address**! (Why?)


<pre><code class="language-c">int *foo(void) {
  int a[10] = {0};
  return a;
}
</code></pre>


## Return an array?

These two functions have made the same mistake: **returning the address of a local variable**.



<pre><code class="language-c">int *foo(void) {
  int a[10] = {0};
  return a;
}
int main(void) {
  int *a = foo();
  a[0] = 42; // undefined behavior
}
</code></pre>




<pre><code class="language-c">int *fun(void) {
  int x = 42;
  return &amp;x;
}
int main(void) {
  // undefined behavior
  printf(&quot;%d\n&quot;, *fun());
}
</code></pre>


- When the function returns, all the parameters and local objects are destroyed.
  - `a` and `x` no longer exist.
- The objects on the returned addresses are **"dead"** when the function returns!

## Pointer type (revisited)

The type of a pointer is `PointeeType *`.

For two different types `T1` and `T2`, the pointer types `T1 *` and `T2 *` are **different types**, although they may point to the same location.


<pre><code class="language-c">int i = 42;
float *fp = &amp;i;
++*fp; // Undefined behavior. It is not ++i.
</code></pre>


In C, pointers of different types can be implicitly converted to each other (with possibly a warning). This is **extremely unsafe** and an error in C++.

Dereferencing a pointer of type `T1 *` when it is actually pointing to a `T2` is *almost always* undefined behavior.

- We will see one exception in the next lecture. ${}^{\textcolor{red}{3}}

## Pass a nested array to a function

When passing an array to a function, we make use of the **array-to-pointer conversion**:

- `Type [N]` will be implicitly converted to `Type *`.

A "2d-array" is an "array of array":

- `Type [N][M]` is an array of `N` elements, where each element is of type `Type [M]`.
- `Type [N][M]` should be implicitly converted to a "pointer to `Type[M]`".

What is a "pointer to `Type[M]`"?

---

## Pointer to array


A pointer to an array of `N` `int`s:


<pre><code class="language-c">int (*parr)[N];
</code></pre>



An array of `N` pointers (pointing to `int`):


<pre><code class="language-c">int *arrp[N];
</code></pre>


Too confusing! How can I remember them?

- `int (*parr)[N]` has a pair of parentheses around `*` and `parr`, so
  - `parr` is a pointer (`*`), and
  - points to something of type `int[N]`.
- Then the other one is different:
  - `arrp` is an array, and
  - stores `N` pointers, with pointee type `int`.

## Pass a nested array to a function


<pre><code class="language-c">void print(int (*a)[5], int n) {
  for (int i = 0; i &lt; n; ++i) {
    for (int j = 0; j &lt; 5; ++j)
      printf(&quot;%d &quot;, a[i][j]);
    printf(&quot;\n&quot;);
  }
}
int main(void) {
  int a[2][5] = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}};
  int b[3][5] = {0};
  print(a, 2); // OK
  print(b, 3); // OK
}
</code></pre>


In each of the following declarations, what is the type of `a`? Does it accept an argument of type `int[N][M]`?

1. `void fun(int a[N][M])`: A pointer to `int[M]`. Yes.
2. `void fun(int (*a)[M])`: Same as 1.
3. `void fun(int (*a)[N])`: A pointer to `int[N]`. **Yes iff `N == M`.**
4. `void fun(int **a)`: A pointer to `int *`. **No.**
5. `void fun(int *a[])`: Same as 4.
6. `void fun(int *a[N])`: Same as 4.
7. `void fun(int a[100][M])`: Same as 1.
8. `void fun(int a[N][100])`: A pointer to `int[100]`. Yes iff `M == 100`.

# CS100 Lecture 7

Pointers and Arrays <span style="color: black; font-family: Times New Roman; font-size: 1.05em;">III</span>, Dynamic memory, Strings

## Contents

- Pointers and Arrays
  - Pointers and `const`
  - The `void *` type
- Dynamic memory
- Strings

# Pointers and Arrays

## Pointer to `const`

A pointer to `const` is a pointer whose pointee type is `const`-qualified:


<pre><code class="language-c">const int x = 42;
int *pi = &amp;x; // Dangerous: It discards the const qualifier.
const int *cpi = &amp;x; // Better.
</code></pre>


The type of `cpi` is `const int *` (or equivalently, `int const *`), which is a pointer to `const int`.

## `const` is a "lock"

`const` is like a lock, guarding against modifications to the variable.

It is very dangerous to let a pointer to non-`const` point to a `const` variable: It is an attempt to remove the lock!

- Warning in C, error in C++.


<pre><code class="language-c">const int x = 42;
int *pi = &amp;x; // Dangerous: It discards the const qualifier.
const int *cpi = &amp;x; // Better.
++*pi; // No error is generated by the compiler, but actually undefined behavior.
</code></pre>


Any indirect modification to a `const` variable is **undefined behavior**.

`const` is like a lock, guarding against modifications to the variable.

A pointer to `const` can point to a non-`const` variable: This is adding a lock.


<pre><code class="language-c">int x = 42;
int *pi = &amp;x;
const int *cpi = &amp;x; // OK.
++*pi; // Correct, same as ++x.
++*cpi; // Error!
</code></pre>


- **A pointer to `const` *thinks* that it is pointing to a `const` variable.** Therefore, it does not allow you to modify the variable through it.

Such `const`ness on the **pointee type** is often called "low-level `const`ness".

## `const` can be helpful

It tells the compiler "this variable should not be modified!".


<pre><code class="language-c">int count(const int *a, int n, int value) {
  int cnt = 0;
  for (int i = 0; i &lt; n; ++i)
    if (a[i] = value) // Error: cannot modify a[i]
      ++cnt;
  return cnt;
}
</code></pre>


**[Best practice]** <u>Use `const` whenever possible.</u>

We will see more usage of `const` in C++.

---

## Top-level `const`ness

A pointer itself can also be `const`. The type of such pointer is `PointeeType *const`.

- Such `const`ness is often called "top-level `const`ness".


<pre><code class="language-c">int x = 42;
int *const pc = &amp;x;
++*pc; // OK.
int y = 30;
pc = &amp;y; // Error.
</code></pre>


A `const` pointer cannot switch to point to other variables after initialization.

A pointer can have both low-level and top-level `const`ness:


<pre><code class="language-c">const int *const cipc = &amp;x;
</code></pre>


## `void *`

A special pointer type:

- Any pointer can be implicitly converted to that type.

- A pointer of type `void *` can be implicitly converted to any pointer type.

  - This must happen explicitly in C++.

- Use `printf("%p", ptr);` to print the value of a pointer `ptr` of type `void *`.

  - If `ptr` is a pointer of some other type, a conversion is needed:

    ```c
    printf("%p", (void *)ptr);
    ```

**The C type system is weak. Many kinds of implicit conversions are very dangerous, although allowed by C.**

C does not have a static type system as powerful as C++'s. `void *` is often used to represent "pointer to anything", "location of some memory", or even "any object".

- Typically, the memory allocation function `malloc` (see below) returns `void *`, the address of the block of memory allocated.
  - Memory does not have types. - We say "a disk of 1TB" instead of "a disk that can hold $2^{38}$ `int`s".

---

# Dynamic memory

## A "dynamic array"

Create an "array" whose size is determined at runtime?

- We need a block of memory, the size of which can be determined at runtime.
- If we run out of memory, **we need to know**.
- We may require a pretty large chunk of memory.

---

## Stack memory vs heap (dynamic) memory


- Stack memory is generally smaller than heap memory.
- Stack memory is often used for storing local and temporary objects.
- Heap memory is often used for storing large objects, and objects with long lifetime.
- Operations on stack memory is faster than on heap memory.
- Stack memory is allocated and deallocated automatically, while heap memory needs manual management.
  </div>
  </div>

---

## Use [`malloc`](https://en.cppreference.com/w/c/memory/malloc) and [`free`](https://en.cppreference.com/w/c/memory/free)

Declared in `<stdlib.h>`.


<pre><code class="language-c">void *malloc(size_t size);
</code></pre>



<pre><code class="language-c">T *ptr = malloc(sizeof(T) * n); // sizeof(T) * n bytes
for (int i = 0; i != n; ++i)
  ptr[i] = /* ... */
// Now you can use `ptr` as if it points to an array of `n` objects of type `T`
// ...
free(ptr);
</code></pre>


To avoid **memory leaks**, the starting address of that block memory must be passed to `free` when the memory is not used anymore.

## Use [`malloc`](https://en.cppreference.com/w/c/memory/malloc) and [`free`](https://en.cppreference.com/w/c/memory/free)

Declared in `<stdlib.h>`.


<pre><code class="language-c">void free(void *ptr);
</code></pre>


Deallocates the space previously allocated by an allocation function (such as `malloc`).

**The behavior is undefined** if the memory area referred to by `ptr` has already been deallocated.

- In other words, "double `free`" is undefined behavior (and often causes severe runtime errors).

After `free(ptr)`, `ptr` no longer points to an existing object, so it is no longer dereferenceable.

- Often called a "dangling pointer".

---

## Use `malloc` and `free`

We can also create one single object dynamically (on heap):


<pre><code class="language-c">int *ptr = malloc(sizeof(int));
*ptr = 42;
printf(&quot;%d\n&quot;, *ptr);
// ...
free(ptr);
</code></pre>


But why? Why not just create one normal variable like `int ival = 42;`?

Benefit: The lifetime of a dynamically allocated object goes beyond a local scope.

It is not destroyed until we `free` it.


<pre><code class="language-c">int *create_array(void) {
  int a[N];
  return a; // Returns the address of the local object `a`.
            // When the function returns, `a` will be destroyed, so that
            // the returned address becomes invalid.
            // Dereferencing the returned address is undefined behavior.
}
int *create_dynamic_array(int n) {
  return malloc(sizeof(int) * n); // OK. The allocated memory is valid until
                                  // we free it.
}
</code></pre>


Create a "2-d array" on heap?



<pre><code class="language-c">int **p = malloc(sizeof(int *) * n);
for (int i = 0; i &lt; n; ++i)
  p[i] = malloc(sizeof(int) * m);
for (int i = 0; i &lt; n; ++i)
  for (int j = 0; j &lt; m; ++j)
    p[i][j] = /* ... */
// ...
for (int i = 0; i &lt; n; ++i)
  free(p[i]);
free(p);
</code></pre>




## Use [`calloc`](https://en.cppreference.com/w/c/memory/calloc)

Declared in `<stdlib.h>`


<pre><code class="language-c">void *calloc(size_t num, size_t each_size);
</code></pre>


Allocates memory for an array of `num` objects (each of size `each_size`), and initializes all bytes in the allocated storage to zero ${}^{\textcolor{red}{1}}$.

Similar as `malloc(num * each_size)`. ${}^{\textcolor{red}{2}}$ Returns a null pointer on failure.

## `malloc`, `calloc` and `free`

The behaviors of `malloc(0)`, `calloc(0, N)` and `calloc(N, 0)` are **implementation-defined**:

- They may or may not allocate memory.
- If no memory is allocated, a null pointer is returned.
- They may allocate *some* memory, for some reasons. In that case, the address of the allocated memory is returned.
  - You cannot dereference the returned pointer.
  - It still constitutes **memory leak** if such memory is not `free`d.

## Arrays vs `malloc`

- An array has limited lifetime (unless it is global or `static`). It is destroyed when control reaches the end of its scope.

- Objects allocated by `malloc` are not destroyed until their address is passed to `free`.

- The program crashes if the size of an array is too large (running out of stack memory). There is no way of recovery.

- Attempt to `malloc` a block of memory that is too large results in a null pointer. We can know if there is no enough heap memory by doing a null check.

  ```c
  int *ptr = malloc(1ull << 60); // unrealistic size
  if (!ptr)
    report_an_error("Out of memory.");
  ```

## Summary

Pointer to `const`

- A pointer to `const` ***thinks*** that it is pointing to a `const` variable (though it may not), so it prevents you from modifying the pointed-to variable through it.
- Use `const` whenever possible.

`void *`

- A pointer type that can contain anything.
- Often used for representing "any pointer", "any object", or memory address.

---

## Summay

Dynamic memory


<pre><code class="language-c">void *malloc(size_t size);
void *calloc(size_t num, size_t each_size);
void free(void *ptr);
</code></pre>


`malloc`: Allocates `size` bytes of **uninitialized** memory and returns its starting address.

`calloc`: Allocates `num * each_size` bytes of memory ${}^{\textcolor{red}{2}}$, each byte initialized to zero, and returns its starting address.

Both `malloc` and `calloc` return a null pointer on failure.

`free`: Deallocates the memory block starting at `ptr`.

---

# Strings

---

## C-style strings

C does not have a special construct for "string".

A string is a sequence of characters stored contiguously. We often use an array or a pointer to the first character to represent a string.

- It can be stored in an array, or in dynamically allocated memory.
- **It must be null-terminated: There should be a null character `'\0'` at the end.**


<pre><code class="language-c">char s[10] = &quot;abcde&quot;;  // s = {'a', 'b', 'c', 'd', 'e', '\0'}
printf(&quot;%s\n&quot;, s);     // prints abcde
printf(&quot;%s\n&quot;, s + 1); // prints bcde
s[2] = ';';            // s = &quot;ab;de&quot;
printf(&quot;%s\n&quot;, s);     // prints ab;de
s[2] = '\0';
printf(&quot;%s\n&quot;, s);     // prints ab
</code></pre>


The position of the first `'\0'` is the end of the string. Anything after that is discarded.

---

## The null character `'\0'`

`'\0'` is the "null character" whose [ASCII](https://en.cppreference.com/w/c/language/ascii) value is 0.

It is **the only way** to mark the end of a C-style string.

Every standard library function that handles strings will search for `'\0'` in that string.

- If there is no `'\0'`, they will search nonstop, and eventually go out of range (undefined behavior).


<pre><code class="language-c">char s[5] = &quot;abcde&quot;; // OK, but no place for '\0'.
printf(&quot;%s\n&quot;, s);   // undefined behavior (missing '\0')
</code></pre>


**Remember to allocate one more byte storage for `'\0'`!**

---

## Empty string

An empty string contains no characters before the null character.


<pre><code class="language-c">char empty[] = &quot;&quot;; // `empty` is of type char[1], which contains only '\0'.
printf(&quot;%s\n&quot;, empty); // Prints only a newline.
printf(&quot;&quot;); // Nothing is printed
</code></pre>


---

## String I/O

[`scanf`](https://en.cppreference.com/w/c/io/fscanf)/[`printf`](https://en.cppreference.com/w/c/io/fprintf): `"%s"`

- `%s` in `scanf` matches a sequence of **non-whitespace** characters.
  - Leading whitespaces are discarded.
  - Reading starts from the first non-whitespace character, and stops right before the next whitespace character.
  - `'\0'` will be placed at the end.

Suppose the input is `   123  456`:


<pre><code class="language-c">char str[100] = &quot;abcdef&quot;;
scanf(&quot;%s&quot;, str); // Reads &quot;123&quot;. `str` becomes {'1', '2', '3', '\0', 'e', 'f'}
printf(&quot;%s\n&quot;, str); // Prints &quot;123&quot;.
                     // 'e' and 'f' are not considered as part of the string.
</code></pre>


---

## String I/O

`scanf` is not memory safe:


<pre><code class="language-c">char str[10];
scanf(&quot;%s&quot;, str);
</code></pre>


- `str` is decayed (implicitly converted) to `char *` when passed as an argument.
- `scanf` receives only a pointer `char *`. **It has no idea how big the array is**.
- If the input content has more than 9 characters, it causes disaster!

That's why it is banned by MSVC. An alternative is to use `scanf_s`, but not necessarily supported by every compiler.

---

## String I/O

`gets` reads a string without bounds checking. **It has been removed since C11.**

- An alternative for `gets` that does bounds checking is `gets_s`, but not supported by every compiler.

**The best alternative: [`fgets`](https://en.cppreference.com/w/c/io/fgets).** It is more portable, more generic, and safer (with bounds checking).


<pre><code class="language-c">char str[100];
fgets(str, 100, stdin);
</code></pre>


`puts(str)`: Prints the string `str`, followed by a newline.

---

## String I/O

<u>Homework</u> Read the [cppreference documentation for `fgets`](https://en.cppreference.com/w/c/io/fgets). Answer the following questions:

- How many characters does it read at most?
- When does it stop?

---

## String manipulation / examination

Some common standard library functions: declared in `<string.h>`.

- `strlen(str)`: Returns the length of the string `str`.
- `strcpy(dest, src)`: Copies the string `src` to `dest`.
- `strcat(dest, src)`: Appends a copy of `src` to the end of `dest`.
- `strcmp(s1, s2)`: Compares two strings in lexicographical order.
- `strchr(str, ch)`: Finds the first occurrence of `ch` in `str`.

**This page is only a brief introduction which cannot be relied on.** The detailed documentations can be found [here](https://en.cppreference.com/w/c/string/byte).

## String manipulation / examination

**Read the documentation of a function before using it.**

- Is `'\0'` counted in `strlen`?
- Does `strcpy` put a null character at the end? What about `strncpy`?
- For `strcpy(dest, src)`, what will happen if `dest` and `src` refer to the same memory address? What if they overlap? What about `strcat`?
- What is the result of `strcmp`? Is it $\in\{-1,0,1\}$? Is it `true`/`false`?

If you use the function without making these clear, **you are heading for late-night debugging sessions!**

## String literals

A string literal is something like `"abcde"`, **surrounded by double quotes `"`**.

- The type of a string literal is `char [N+1]`, where `N` is the length of the string.
  - `+1` is for the terminating null character.
- **But a string literal will be placed in read-only memory!!**
  - In C++, its type is `const char [N+1]`, which is more reasonable.

When initializating a pointer with a string literal,


<pre><code class="language-c">char *p = &quot;abcde&quot;;
</code></pre>


we are actually letting `p` point to the address of the string literal．

Using a pointer to non-`const` to point to a string literal is **allowed in C** (not allowed in C++), but **very dangerous**:


<pre><code class="language-c">char *p = &quot;abcde&quot;; // OK
p[3] = 'a'; // No compile-error, but undefined behavior,
            // and possibly severe runtime-error.
</code></pre>


Correct ways:


Use low-level `const`ness to protect it:


<pre><code class="language-c">const char *str = &quot;abcde&quot;;
str[3] = 'a'; // compile-error
</code></pre>



**Copy** the contents into an array:


<pre><code class="language-c">char arr[] = &quot;abcde&quot;;
arr[3] = 'a'; // OK.
// `arr` contains a copy of &quot;abcde&quot;.
</code></pre>


## Array of strings


<pre><code class="language-c">const char *translations[] = {
  &quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;,
  &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;
};
</code></pre>



- `translations` is an array of pointers, where each pointer points to a string literal.
- `translations` **is not a 2-d array!**

# CS100 Lecture 8

Dynamic Memory and Strings Revisited

---

## Contents

- Recap
- Command line arguments
- Example: Read a string of unknown length



# Command line arguments

## Command line arguments

The following command executes `gcc.exe`, and tells it the file to be compiled and the name of the output:


<pre><code>gcc hello.c -o hello
</code></pre>


How are the arguments `hello.c`, `-o` and `hello` passed to `gcc.exe`?

- It is definitely different from "input".

## A new signature of `main`


<pre><code class="language-c">int main(int argc, char **argv) { /* body */ }
</code></pre>


Run this program with some arguments: `.\program one two three`


<pre><code class="language-c">int main(int argc, char **argv) {
  for (int i = 0; i &lt; argc; ++i)
    puts(argv[i]);
}
</code></pre>


Output:


<pre><code>.\program
one
two
three
</code></pre>



<pre><code class="language-c">int main(int argc, char **argv) { /* body */ }
</code></pre>


where

- `argc` is a non-negative value representing the number of arguments passed to the program from the environment in which the program is run.
- `argv` is a pointer to the first element of an array of `argc + 1` pointers, of which
  - the last one is null, and
  - the previous ones (if any) point to strings that represent the arguments.

If `argv[0]` is not null (or equivalently, if `argc > 0`), it points to a string representing the program name.

---

## Command line arguments


<pre><code class="language-c">int main(int argc, char **argv) { /* body */ }
</code></pre>


`argv` is **an array of pointers** that point to the strings representing the arguments:

# Example: Read a string of unknown length

## Read a string

`fgets(str, count, stdin)` reads a string, but at most `count - 1` characters.

`scanf("%s", str)` reads a string, but not caring about whether the input content is too long to fit into the memory that `str` points to.

For example, the following code is likely to crash if the input is `responsibility`:


<pre><code class="language-c">char word[6];
scanf(&quot;%s&quot;, word);
</code></pre>


`scanf` does nothing to prevent the disaster.

- It does not even know how long the array `word` is!

Suppose we want to read a sequence of non-whitespace characters, the length of which is unknown.

- Use `malloc` / `free` to allocate and deallocate memory dynamically.
- When the current buffer is not large enough, we allocate a larger one and copies the stored elements to it!


<pre><code class="language-c">char *read_string(void) {
  // ...
  while (!isspace(c)) {
    if (cur_pos == capacity - 1) { // `-1` is for '\0'.
      // ...
    }
    buffer[cur_pos++] = c;
    c = getchar();
  }

  // Now, `c` is a whitespace. This is not part of the contents we need.
  ungetc(c, stdin); // Put that whitespace back to the input.

  buffer[cur_pos] = '\0'; // Remember this!!!

  return buffer;
}
</code></pre>



<pre><code class="language-c">int main(void) {
  char *content = read_string();
  puts(content);
  free(content);
}
</code></pre>


Remember to `free` it after use!

# CS100 Lecture 9

`struct`, Recursion

---

## Contents

- `struct`
- Recursion

  - Factorial
  - Print a non-negative integer
  - Selection-sort

# `struct`

## `struct` type

The name of the type defined by a `struct` is `struct Name`.

- Unlike C++, the keyword `struct` here is necessary.


<pre><code class="language-c">struct Student stu; // `stu` is an object of type `struct Student`
struct Point3d polygon[1000]; // `polygon` is an array of 1000 objects,
                              // each being of type `struct Point3d`.
struct TreeNode *pNode; // `pNode` is a pointer to `struct TreeNode`.
</code></pre>


**\* The term "*object*" is used interchangeably with "*variable*".**

- *Objects* often refer to variables of `struct` (or `class` in C++) types.
- But in fact, there's nothing wrong to say "an `int` object".

---

## Members of a `struct`

Use `obj.mem`, the **member-access operator `.`** to access a member.


<pre><code class="language-c">struct Student stu;
stu.name = &quot;Alice&quot;;
stu.id = &quot;2024533000&quot;;
stu.entrance_year = 2024;
stu.dorm = 8;
printf(&quot;%d\n&quot;, student.dorm);
++student.entrance_year;
puts(student.name);
</code></pre>


## Dynamic allocation

Create an object of `struct` type dynamically: Just allocate `sizeof(struct Student)` bytes of memory.


<pre><code class="language-c">struct Student *pStu = malloc(sizeof(struct Student));
</code></pre>


Member access through a pointer: `ptr->mem`, or `(*ptr).mem` **(not `*ptr.mem`!).**


<pre><code class="language-c">pStu-&gt;name = &quot;Alice&quot;;
pStu-&gt;id = &quot;2024533000&quot;;
(*pStu).entrance_year = 2024; // equivalent to pStu-&gt;entrance_year = 2024;
printf(&quot;%d\n&quot;, pStu-&gt;entrance_year);
puts(pStu-&gt;name);
</code></pre>


As usual, don't forget to `free` after use.


<pre><code class="language-c">free(pStu);
</code></pre>


## Size of a `struct`


<pre><code class="language-c">struct Student {
  const char *name;
  const char *id;
  int entrance_year;
  int dorm;
};
</code></pre>



<pre><code class="language-c">struct Student *pStu = malloc(sizeof(struct Student));
</code></pre>


What is the value of `sizeof(struct Student)`?

## Size of `struct`

It is guaranteed that

$$
\mathtt{sizeof(struct\ \ X)}\geqslant\sum_{\mathtt{member}\in\mathtt{X}}\mathtt{sizeof(member)}.
$$

The inequality is due to **memory alignment requirements**, which is beyond the scope of CS100.

---

## Implicit initialization

What happens if an object of `struct` type is not explicitly initialized?


<pre><code class="language-c">struct Student gStu;

int main(void) {
  struct Student stu;
}
</code></pre>


---

## Implicit initialization

What happens if an object of `struct` type is not explicitly initialized?


<pre><code class="language-c">struct Student gStu;

int main(void) {
  struct Student stu;
}
</code></pre>


- Global or local `static`: "empty-initialization", which performs **member-wise** empty-initialization.
- Local non-`static`: every member is initialized to indeterminate values (in other words, uninitialized).

---

## Explicit initialization

Use an initializer list:


<pre><code class="language-c">struct Student stu = {&quot;Alice&quot;, &quot;2024533000&quot;, 2024, 8};
</code></pre>


**Use C99 designators:** (highly recommended)


<pre><code class="language-c">struct Student stu = {.name = &quot;Alice&quot;, .id = &quot;2024533000&quot;,
                      .entrance_year = 2024, .dorm = 8};
</code></pre>


The designators greatly improve the readability.

**[Best practice]** <u>Use designators, especially for `struct` types with lots of members.</u>

---

## Compound literals


<pre><code class="language-c">struct Student *student_list = malloc(sizeof(struct Student) * n);
for (int i = 0; i != n; ++i) {
  student_list[i].name = A(i); // A, B, C and D are some functions
  student_list[i].id = B(i);
  student_list[i].entrance_year = C(i);
  student_list[i].dorm = D(i);
}
</code></pre>


Use a **compound literal** to make it clear and simple:


<pre><code class="language-c">struct Student *student_list = malloc(sizeof(struct Student) * n);
for (int i = 0; i != n; ++i) {
  student_list[i] = (struct Student){.name = A(i), .id = B(i),
                                     .entrance_year = C(i), .dorm = D(i)};
}

</code></pre>


---

## `struct`-typed parameters

The semantic of argument passing is **copy**:


<pre><code class="language-c">void print_student(struct Student s) {
  printf(&quot;Name: %s, ID: %s, dorm: %d\n&quot;, s.name, s.id, s.dorm);
}

print_student(student_list[i]);
</code></pre>


In a call `print_student(student_list[i])`, the parameter `s` of `print_student` is initialized as follows:


<pre><code class="language-c">struct Student s = student_list[i];
</code></pre>


The copy of a `struct`-typed object: **Member-wise copy.**

---

## `struct`-typed parameters

In a call `print_student(student_list[i])`, the parameter `s` of `print_student` is initialized as follows:


<pre><code class="language-c">struct Student s = student_list[i];
</code></pre>


The copy of a `struct`-typed object: **Member-wise copy.** It is performed as if


<pre><code class="language-c">s.name = student_list[i].name;
s.id = student_list[i].id;
s.entrance_year = student_list[i].entrance_year;
s.dorm = student_list[i].dorm;
</code></pre>


---

## Return a `struct`-typed object

Strictly speaking, returning is also a **copy**:


<pre><code class="language-c">struct Student fun(void) {
  struct Student s = something();
  some_operations(s);
  return s;
}
student_list[i] = fun();
</code></pre>


The object `s` is returned as if


<pre><code class="language-c">student_list[i] = s;
</code></pre>


**But in fact, the compiler is more than willing to optimize this process.** We will talk more about this in C++.

---

## Array member


<pre><code class="language-c">struct A {
  int array[10];
  // ...
};
</code></pre>


Although an array cannot be copied, **an array member can be copied**.

The copy of an array is **element-wise copy**.



<pre><code class="language-c">int a[10];
int b[10] = a; // Error!
</code></pre>




<pre><code class="language-c">struct A a;
struct A b = a; // OK
</code></pre>


---

## Summary

A `struct` is a type consisting of a sequence of members.

- Member access: `obj.mem`, `ptr->mem` (equivalent to `(*ptr).mem`, but better)
- `sizeof(struct A)`, no less than the sum of size of every member.

  - But not necessarily equal, due to memory alignment requirements.
- Implicit initialization: recursively performed on every member.
- Initializer-lists, designators, compound literals.
- Copy of a `struct`: member-wise copy.
- Argument passing and returning: copy.

# Recursion

## Problem 1. Calculate $n!$


<pre><code class="language-c">int factorial(int n) {
  return n == 0 ? 1 : n * factorial(n - 1);
}
</code></pre>


**This is perfectly valid and reasonable C code!**

- The function `factorial` **recursively** calls itself.Problem 2. Print a non-negative integer

If we only have `getchar`, how can we read an integer?

- We have solved this in recitations.

If we only have `putchar`, how can we print an integer?

- Declared in `<stdio.h>`.
- `putchar(c)` prints a character `c`. That's it.

For convenience, suppose the integer is non-negative (unsigned).

---

## Print a non-negative integer

To print $x$:

- If $x < 10$, just print the digit and we are done.
- Otherwise ($x\geqslant 10$), we first print $\displaystyle\left\lfloor\frac{x}{10}\right\rfloor$, and then print the digit on the last place.


<pre><code class="language-c">void print(unsigned x) {
  if (x &lt; 10)
    putchar(x + '0'); // Remember ASCII?
  else {
    print(x / 10);
    putchar(x % 10 + '0');
  }
}
</code></pre>


---

## Simplify the code

To print $x$:

1. If $x\geqslant 10$, we first print $\displaystyle\left\lfloor\frac{x}{10}\right\rfloor$. Otherwise, do nothing.
2. Print $x\bmod 10$.


<pre><code class="language-c">void print(unsigned x) {
  if (x &gt;= 10)
    print(x / 10);
  putchar(x % 10 + '0');
}
</code></pre>


---

## Print a non-negative integer


To print $x$:

1. If $x\geqslant 10$, we first print $\displaystyle\left\lfloor\frac{x}{10}\right\rfloor$. Otherwise, do nothing.
2. Print $x\bmod 10$.


<pre><code class="language-c">void print(unsigned x) {
  if (x &gt;= 10)
    print(x / 10);
  putchar(x % 10 + '0');
}
</code></pre>


---

## Design a recursive algorithm

Suppose we are given a problem of scale $n$.

1. Divide the problem into one or more **subproblems**, which are of smaller scales.
2. Solve the subproblems **recursively** by calling the function itself.
3. Generate the answer to the big problem from the answers to the subproblems.

**\* Feels like mathematical induction?**

## Problem 3. Selection-sort

How do you sort a sequence of $n$ numbers? (In ascending order)

Do it **recursively**.



How do you sort a sequence of $n$ numbers $\langle a_0,\cdots,a_{n-1}\rangle$? (In ascending order)

Do it **recursively**: Suppose we are going to sort $\langle a_k,a_{k+1},\cdots,a_{n-1}\rangle$, for some $k$.

- If $k=n-1$, we are done.
- Otherwise ($k<n-1$):
  1. Find the minimal number $a_m=\min\left\{a_k,a_{k+1},\cdots,a_{n-1}\right\}$.
  2. Put $a_m$ at the first place by swapping it with $a_k$.
  3. Now $a_k$ is the smallest number in $\langle a_k,\cdots,a_{n-1}\rangle$. All we have to do is to sort the rest part $\langle a_{k+1},\cdots,a_{n-1}\rangle$ **recursively**.


<pre><code class="language-c">void sort_impl(int *a, int k, int n) {
  if (k == n - 1) return;

  int m = k;
  for (int i = k + 1; i &lt; n; ++i)
    if (a[i] &lt; a[m]) m = i;

  swap(&amp;a[m], &amp;a[k]); // the &quot;swap&quot; function we defined in previous lectures

  sort_impl(a, k + 1, n); // sort the rest part recursively
}
</code></pre>


# CS100 Lecture 11

## IOStream: Input and Output Stream

`std::cin >> x`: Reads something and stores it in the variable `x`.

- `x` can be of any supported type: integers, floating-points, characters, strings, ...
- **C++ has a way of identifying the type of `x` and selecting the correct way to read it.** We don't need the annoying `"%d"`, `"%f"`, ... anymore.
- **C++ functions have a way of obtaining the *reference* of the argument.** We don't need to take the address of `x`.

## Standard library file names

The names of C++ standard library files **have no extensions**: `<iostream>` instead of `<iostream.h>`, `<string>` instead of `<string.h>`.

## Namespace `std`

`std::cin` and `std::cout`: names from the standard library.

C++ has a large standard library with a lot of names declared.

To avoid **name collisions**, all the names from the standard library are placed in a **namespace** named `std`.

- You can write `using std::cin;` to introduce `std::cin` into **the current scope**, so that `cin` can be used without `std::`.
- You may write `using namespace std;` to introduce **all the names in `std`** into the current scope, but **you will be at the risk of name collisions again.**

**[Best practice]** <u>Use `<cxxx>` instead of `<xxx.h>` when you need the C standard library in C++.</u>

# `std::string`

Defined in the standard library file `<string>` **(not `<string.h>`, not `<cstring>`!!)**

## Define and initialize a string


<pre><code class="language-cpp">std::string str = &quot;Hello world&quot;;
// equivalent: std::string str(&quot;Hello world&quot;);
// equivalent: std::string str{&quot;Hello world&quot;}; (modern)
std::cout &lt;&lt; str &lt;&lt; std::endl;

std::string s1(7, 'a');
std::cout &lt;&lt; s1 &lt;&lt; std::endl; // aaaaaaa

std::string s2 = s1; // s2 is a copy of s1
std::cout &lt;&lt; s2 &lt;&lt; std::endl; // aaaaaaa

std::string s; // &quot;&quot; (empty string)
</code></pre>


Default-initialization of a `std::string` will produce **an empty string**, not indeterminate value and has no undefined behaviors!

## Strings

- The memory of `std::string` is **allocated and deallocated automatically**.
- We can insert or erase characters in a `std::string`. **The memory of storage will be adjusted automatically.**
- `std::string` **does not need an explicit `'\0'` at the end**. It has its way of recognizing the end.
- When you use `std::string`, **pay attention to its contents** instead of the implementation details.

## Length of a string

### Member function `s.size()` || Member function `s.empty()`

## Use `+=`

In C, `a = a + b` is equivalent to `a += b`. **This is not always true in C++.**

For two `std::string`s `s1` and `s2`, `s1 = s1 + s2` **is different from** `s1 += s2`.

- `s1 = s1 + s2` constructs a temporary object `s1 + s2` (so that the contents of `s1` are copied), and then assigns it to `s1`.
- `s1 += s2` appends `s2` directly to the end of `s1`, without copying `s1`.

## Traversing a string: Use range-based `for` loops.

Example: Print all the uppercase letters in a string.


<pre><code class="language-cpp">for (char c : s) // The range-based for loops
  if (std::isupper(c)) // in &lt;cctype&gt;
    std::cout &lt;&lt; c;
std::cout &lt;&lt; std::endl;
</code></pre>


Equivalent way: Use subscripts, which is verbose and inconvenient.

## String IO

Use `std::cin >> s` and `std::cout << s`, as simple as handling an integer.

- Does `std::cin >> s` ignore leading whitespaces? Does it read an entire line or just a sequence of non-whitespace characters? Do some experiments on it.

`std::getline(std::cin, s)`: Reads a string starting from the current character, and stops at the first `'\n'`.

- Is the ending `'\n'` consumed? Is it stored? Do some experiments.

# CS100 Lecture 12

References, `std::vector`

---

## Contents

- References
- `std::vector`

---

# References

---

## Declare a reference

A **reference** defines an **alternative name** for an object ("refers to" that object).

Similar to pointers, the type of a reference is `ReferredType &`, which consists of two things:

- `ReferredType` is the type of the object that it refers to, and
- `&` is the symbol indicating that it is a reference.

Example:


<pre><code class="language-cpp">int ival = 42;
int &amp;ri = ival; // `ri` refers to `ival`.
                // In other words, `ri` is an alternative name for `ival`.
std::cout &lt;&lt; ri &lt;&lt; '\n'; // prints the value of `ival`, which is `42`.
++ri;           // Same effect as `++ival;`.
</code></pre>


---

## Declare a reference


<pre><code class="language-cpp">int ival = 42;
int x = ival;              // `x` is another variable.
++x;                       // This has nothing to do with `ival`.
std::cout &lt;&lt; ival &lt;&lt; '\n'; // 42
int &amp;ri = ival;            // `ri` is a reference that refers to `ival`.
++ri;                      // This modification is performed on `ival`.
std::cout &lt;&lt; ival &lt;&lt; '\n'; // 43
</code></pre>


Ordinarily, when we initialize a variable, the value of the initializer is **copied** into the object we are creating.

When we define a reference, instead of copying the initializer's value, we **bind** the reference to its initializer.

---

## A reference is an alias

When we define a reference, instead of copying the initializer's value, we **bind** the reference to its initializer.


<pre><code class="language-cpp">int ival = 42;
int &amp;ri = ival;
++ri;           // Same as `++ival;`.
ri = 50;        // Same as `ival = 50;`.
int a = ri + 1; // Same as `int a = ival + 1;`.
</code></pre>


After a reference has been defined, **all** operations on that reference are actually operations on the object to which the reference is bound.


<pre><code class="language-cpp">ri = a;
</code></pre>


What is the meaning of this?

---

## A reference is an alias


<pre><code class="language-cpp">int ival = 42;
int &amp;ri = ival;
++ri;           // Same as `++ival;`.
ri = 50;        // Same as `ival = 50;`.
int a = ri + 1; // Same as `int a = ival + 1;`.
</code></pre>


When we define a reference, instead of copying the initializer's value, we **bind** the reference to its initializer.

After a reference has been defined, **all** operations on that reference are actually operations on the object to which the reference is bound.


<pre><code class="language-cpp">ri = a;
</code></pre>


- This is the same as `ival = a;`. **It is not rebinding `ri` to refer to `a`.**

---

## A reference must be initialized



<pre><code class="language-cpp">ri = a;
</code></pre>


- This is the same as `ival = a;`. **It is not rebinding `ri` to refer to `a`.**

Once initialized, a reference remains bound to its initial object. **There is no way to rebind a reference to refer to a different object.**

Therefore, **references must be initialized.**

---

## References must be bound to *existing objects* ("lvalues")

It is not allowed to bind a reference to temporary objects or literals ${}^{\textcolor{red}{1}}$:


<pre><code class="language-cpp">int &amp;r1 = 42;    // Error: binding a reference to a literal
int &amp;r2 = 2 + 3; // Error: binding a reference to a temporary object
int a = 10, b = 15;
int &amp;r3 = a + b; // Error: binding a reference to a temporary object
</code></pre>


In fact, the references we learn today are "lvalue references", which must be bound to *lvalues*. We will talk about *value categories* in later lectures.

---

## References are not objects

A reference is an alias. It is only an alternative name of another object, but the reference itself is **not an object**.

Therefore, there are no "references to references".


<pre><code class="language-cpp">int ival = 42;
int &amp;ri = ival; // binding `ri` to `ival`.
int &amp; &amp;rr = ri; // Error! No such thing!
</code></pre>


What is the meaning of this code? Does it compile?


<pre><code class="language-cpp">int &amp;ri2 = ri;
</code></pre>


---

## References are not objects

A reference is an alias. It is only an alternative name of another object, but the reference itself is **not an object**.

Therefore, there are no "references to references".


<pre><code class="language-cpp">int ival = 42;
int &amp;ri = ival; // binding `ri` to `ival`.
int &amp; &amp;rr = ri; // Error! No such thing!
</code></pre>


What is the meaning of this code? Does it compile?


<pre><code class="language-cpp">int &amp;ri2 = ri; // Same as `int &amp;ri2 = ival;`.
</code></pre>


- `ri2` is a reference that is bound to `ival`.
- **Any use of a reference is actually using the object that it is bound to!**

---

## References are not objects

A reference is an alias. It is only an alternative name of another object, but the reference itself is **not an object**.

Pointers must also point to objects. Therefore, there are no "pointers to references".


<pre><code class="language-cpp">int ival = 42;
int &amp;ri = ival; // binding `ri` to `ival`.
int &amp;*pr = &amp;ri; // Error! No such thing!
</code></pre>


What is the meaning of this code? Does it compile?


<pre><code class="language-cpp">int *pi = &amp;ri;
</code></pre>


---

## References are not objects

A reference is an alias. It is only an alternative name of another object, but the reference itself is **not an object**.

Pointers must also point to objects. Therefore, there are no "pointers to references".


<pre><code class="language-cpp">int ival = 42;
int &amp;ri = ival; // binding `ri` to `ival`.
int &amp;*pr = ri; // Error! No such thing!
</code></pre>


What is the meaning of this code? Does it compile?


<pre><code class="language-cpp">int *pi = &amp;ri; // Same as `int *pi = &amp;ival;`.
</code></pre>


---

## Reference declaration

Similar to pointers, the ampersand `&` only applies to one identifier.


<pre><code class="language-cpp">int ival = 42, &amp;ri = ival, *pi = &amp;ival;
// `ri` is a reference of type `int &amp;`, which is bound to `ival`.
// `pi` is a pointer of type `int *`, which points to `ival`.
</code></pre>


Placing the ampersand near the referred type does not make a difference:


<pre><code class="language-cpp">int&amp; x = ival, y = ival, z = ival;
// Only `x` is a reference. `y` and `z` are of type `int`.
</code></pre>


---

## `*` and `&`

Both symbols have many identities!

- In a **declaration** like `Type *x = expr`, `*` is **a part of the pointer type `Type *`**.
- In a **declaration** like `Type &r = expr`, `&` is **a part of the reference type `Type &`**.
- In an **expression** like `*opnd` where there is only one operand, `*` is the **dereference operator**.
- In an **expression** like `&opnd` where there is only one operand, `&` is the **address-of operator**.
- In an **expression** like `a * b` where there are two operands, `*` is the **multiplication operator**.
- In an **expression** like `a & b` where there are two operands, `&` is the **bitwise-and operator**.

---

## Example: Use references in range-`for`

Recall the range-based `for` loops (range-`for`):


<pre><code class="language-cpp">std::string str;
std::cin &gt;&gt; str;
int lower_cnt = 0;
for (char c : str)
  if (std::islower(c))
    ++lower_cnt;
std::cout &lt;&lt; &quot;There are &quot; &lt;&lt; lower_cnt &lt;&lt; &quot; lowercase letters in total.\n&quot;;
</code></pre>


The range-`for` loop in the code above traverses the string, and declares and initializes the variable `c` in each iteration as if ${}^{\textcolor{red}{2}}$


<pre><code class="language-cpp">for (std::size_t i = 0; i != str.size(); ++i) {
  char c = str[i]; // Look at this!
  if (std::islower(c))
    ++lower_cnt;
}
</code></pre>


---

## Example: Use references in range-`for`


<pre><code class="language-cpp">for (char c : str)
  // ...
</code></pre>


The range-`for` loop in the code above traverses the string, and declares and initializes the variable `c` in each iteration as if ${}^{\textcolor{red}{2}}$


<pre><code class="language-cpp">for (std::size_t i = 0; i != str.size(); ++i) {
  char c = str[i];
  // ...
}
</code></pre>


**Here `c` is a copy of `str[i]`. Therefore, modification on `c` does not affect the contents in `str`.**

---

## Example: Use references in range-`for`

What if we want to change all lowercase letters to their uppercase forms?


<pre><code class="language-cpp">for (char c : str)
  c = std::toupper(c); // This has no effect.
</code></pre>


**We need to declare `c` as a reference.**


<pre><code class="language-cpp">for (char &amp;c : str)
  c = std::toupper(c);
</code></pre>


This is the same as


<pre><code class="language-cpp">for (std::size_t i = 0; i != str.size(); ++i) {
  char &amp;c = str[i];
  c = std::toupper(c); // Same as `str[i] = std::toupper(str[i]);`.
}
</code></pre>


---

## Example: Pass by reference-to-`const`

Write a function that accepts a string and returns the number of lowercase letters in it:


<pre><code class="language-cpp">int count_lowercase(std::string str) {
  int cnt = 0;
  for (char c : str)
    if (std::islower(c))
      ++cnt;
  return cnt;
}
</code></pre>


To call this function:


<pre><code class="language-cpp">int result = count_lowercase(my_string);
</code></pre>


---

## Example: Pass by reference-to-`const`


<pre><code class="language-cpp">int count_lowercase(std::string str) {
  int cnt = 0;
  for (char c : str)
    if (std::islower(c))
      ++cnt;
  return cnt;
}
</code></pre>



<pre><code class="language-cpp">int result = count_lowercase(my_string);
</code></pre>


When passing `my_string` to `count_lowercase`, the parameter `str` is initialized as if


<pre><code class="language-cpp">std::string str = my_string;
</code></pre>


**The contents of the entire string `my_string` are copied!**

---

## Example: Pass by reference-to-`const`


<pre><code class="language-cpp">int result = count_lowercase(my_string);
</code></pre>


When passing `my_string` to `count_lowercase`, the parameter `str` is initialized as if


<pre><code class="language-cpp">std::string str = my_string;
</code></pre>


**The contents of the entire string `my_string` are copied!** Is this copy necessary?

---

## Example: Pass by reference-to-`const`


<pre><code class="language-cpp">int result = count_lowercase(my_string);
</code></pre>


When passing `my_string` to `count_lowercase`, the parameter `str` is initialized as if


<pre><code class="language-cpp">std::string str = my_string;
</code></pre>


**The contents of the entire string `my_string` are copied!** This copy is unnecessary, because `count_lowercase` is a read-only operation on `str`.

How can we avoid this copy?

---

## Example: Pass by reference-to-`const`


<pre><code class="language-cpp">int count_lowercase(std::string &amp;str) { // `str` is a reference.
  int cnt = 0;
  for (char c : str)
    if (std::islower(c))
      ++cnt;
  return cnt;
}
</code></pre>



<pre><code class="language-cpp">int result = count_lowercase(my_string);
</code></pre>


When passing `my_string` to `count_lowercase`, the parameter `str` is initialized as if


<pre><code class="language-cpp">std::string &amp;str = my_string;
</code></pre>


Which is just a reference initialization. No copy is performed.

---

## Example: Pass by reference-to-`const`


<pre><code class="language-cpp">int count_lowercase(std::string &amp;str) { // `str` is a reference.
  int cnt = 0;
  for (char c : str)
    if (std::islower(c))
      ++cnt;
  return cnt;
}
</code></pre>


However, this has a problem:


<pre><code class="language-cpp">std::string s1 = something(), s2 = some_other_thing();
int result = count_lowercase(s1 + s2); // Error: binding reference to
                                       // a temporary object.
</code></pre>


`a + b` is a temporary object, which `str` cannot be bound to.

---

## Example: Pass by reference-to-`const`

References must be bound to existing objects, not literals or temporaries.

**There is an exception to this rule: References-to-`const` can be bound to anything.**


<pre><code class="language-cpp">const int &amp;rci = 42; // OK.
const std::string &amp;rcs = a + b; // OK.
</code></pre>


`rcs` is bound to the temporary object returned by `a + b` as if


<pre><code class="language-cpp">std::string tmp = a + b;
const std::string &amp;rcs = tmp;
</code></pre>


$\Rightarrow$ We will talk more about references-to-`const` in recitations.

---

## Example: Pass by reference-to-`const`

***The*** answer:


<pre><code class="language-cpp">int count_lowercase(const std::string &amp;str) { // `str` is a reference-to-`const`.
  int cnt = 0;
  for (char c : str)
    if (std::islower(c))
      ++cnt;
  return cnt;
}
</code></pre>



<pre><code class="language-cpp">std::string a = something(), b = some_other_thing();
int res1 = count_lowercase(a);       // OK.
int res2 = count_lowercase(a + b);   // OK.
int res3 = count_lowercase(&quot;hello&quot;); // OK.
</code></pre>


---

## Benefits of passing by reference-to-`const`

Apart from the fact that it avoids copy, declaring the parameter as a reference-to-`const` also prevents some potential mistakes:


<pre><code class="language-cpp">int some_kind_of_counting(const std::string &amp;str, char value) {
  int cnt = 0;
  for (std::size_t i = 0; i != str.size(); ++i) {
    if (str[i] = value) // Ooops! It should be `==`.
      ++cnt;
    else {
      // do something ...
      // ...
    }
  }
  return cnt;
}
</code></pre>


`str[i] = value` will trigger a compile-error, because `str` is a reference-to-`const`.

---

## Benefits of passing by reference-to-`const`

1. Avoids copy.
2. Accepts temporaries and literals (*rvalues*).
3. The `const` qualification prevents accidental modifications to it.

**[Best practice]** <u>Pass by reference-to-`const` if copy is not necessary and the parameter should not be modified.</u>

---

## References vs pointers

<div style="display: grid; grid-template-columns: 1fr 1fr;">
  <div>


A reference

- is not itself an object. It is an alias of the object that it is bound to.

- cannot be rebound to another object after initialization.

- has no "default" or "zero" value. It must be bound to an object.
  </div>

  <div>

A pointer

- is an object that stores the address of the object it points to.
- can switch to point to another object at any time.
- can be set to a null pointer value `nullptr`.
  </div>
  </div>

Both a reference and a pointer can be used to refer to an object, but references are more convenient - no need to write the annoying `*` and `&`.

Note: `nullptr` is ***the*** null pointer value in C++. Do not use `NULL`.

---

# `std::vector`

Defined in the standard library file `<vector>`.

A "dynamic array".

---

## Class template

`std::vector` is a **class template**.

Class templates are not themselves classes. Instead, they can be thought of as instructions to the compiler for *generating* classes.

- The process that the compiler uses to create classes from the templates is called **instantiation**.

For `std::vector`, what kind of class is generated depends on the type of elements we want to store, often called **value type**. We supply this information inside a pair of angle brackets following the template's name:


<pre><code class="language-cpp">std::vector&lt;int&gt; v; // `v` is of type `std::vector&lt;int&gt;`
</code></pre>


---

## Create a `std::vector`

`std::vector` **is not a type itself**. It must be combined with some `<T>` to form a type.


<pre><code class="language-cpp">std::vector v;               // Error: missing template argument.
std::vector&lt;int&gt; vi;         // An empty vector of `int`s.
std::vector&lt;std::string&gt; vs; // An empty vector of strings.
std::vector&lt;double&gt; vd;      // An empty vector of `double`s.
std::vector&lt;std::vector&lt;int&gt;&gt; vvi; // An empty vector of vector of `int`s.
                                   // &quot;2-d&quot; vector.
</code></pre>


What are the types of `vi`, `vs` and `vvi`?

---

## Create a `std::vector`

`std::vector` **is not a type itself**. It must be combined with some `<T>` to form a type.


<pre><code class="language-cpp">std::vector v;               // Error: missing template argument.
std::vector&lt;int&gt; vi;         // An empty vector of `int`s.
std::vector&lt;std::string&gt; vs; // An empty vector of strings.
std::vector&lt;double&gt; vd;      // An empty vector of `double`s.
std::vector&lt;std::vector&lt;int&gt;&gt; vvi; // An empty vector of vector of `int`s.
                                   // &quot;2-d&quot; vector.
</code></pre>


What are the types of `vi`, `vs` and `vvi`?

- `std::vector<int>`, `std::vector<std::string>`, `std::vector<std::vector<int>>`.

---

## Create a `std::vector`

There are several common ways of creating a `std::vector`:


<pre><code class="language-cpp">std::vector&lt;int&gt; v{2, 3, 5, 7};     // A vector of `int`s,
                                    // whose elements are {2, 3, 5, 7}.
std::vector&lt;int&gt; v2 = {2, 3, 5, 7}; // Equivalent to ↑

std::vector&lt;std::string&gt; vs{&quot;hello&quot;, &quot;world&quot;}; // A vector of strings,
                                    // whose elements are {&quot;hello&quot;, &quot;world&quot;}.
std::vector&lt;std::string&gt; vs2 = {&quot;hello&quot;, &quot;world&quot;}; // Equivalent to ↑

std::vector&lt;int&gt; v3(10);     // A vector of ten `int`s, all initialized to 0.
std::vector&lt;int&gt; v4(10, 42); // A vector of ten `int`s, all initialized to 42.
</code></pre>


Note that all the elements in `v3` are initialized to `0`.

- We hate uninitialized values, so does the standard library.

---

## Create a `std::vector`

Create a `std::vector` as a copy of another one:


<pre><code class="language-cpp">std::vector&lt;int&gt; v{2, 3, 5, 7};
std::vector&lt;int&gt; v2 = v; // `v2`` is a copy of `v`
std::vector&lt;int&gt; v3(v);  // Equivalent
std::vector&lt;int&gt; v4{v};  // Equivalent
</code></pre>


**No need to write a loop!**

Copy assignment is also enabled:


<pre><code class="language-cpp">std::vector&lt;int&gt; v1 = something(), v2 = something_else();
v1 = v2;
</code></pre>


- Element-wise copy is performed automatically.
- Memory is allocated automatically. The memory used to store the old data of `v1` is deallocated automatically.

---

## C++17 CTAD

"**C**lass **T**emplate **A**rgument **D**eduction": As long as enough information is supplied in the initializer, **the value type can be deduced automatically by the compiler**.



<pre><code class="language-cpp">std::vector v1{2, 3, 5, 7}; // vector&lt;int&gt;
std::vector v2{3.14, 6.28}; // vector&lt;double&gt;
std::vector v3(10, 42);     // vector&lt;int&gt;, deduced from 42 (int)
std::vector v4(10);         // Error: cannot deduce template argument type
</code></pre>


<!-- std::vector v5(n, std::vector(m, 0.0)) in recitations -->

---

## Size of a `std::vector`

`v.size()` and `v.empty()`: same as those on `std::string`.


<pre><code class="language-cpp">std::vector v{2, 3, 5, 7};
std::cout &lt;&lt; v.size() &lt;&lt; '\n';
if (v.empty()) {
  // ...
}
</code></pre>


`v.clear()`: Remove all the elements.

---

## Append an element to the end of a `std::vector`

`v.push_back(x)`


<pre><code class="language-cpp">int n;
std::cin &gt;&gt; n;
std::vector&lt;int&gt; v;
for (int i = 0; i != n; ++i) {
  int x;
  std::cin &gt;&gt; x;
  v.push_back(x);
}
std::cout &lt;&lt; v.size() &lt;&lt; '\n'; // n
</code></pre>


---

## Remove the last element of a `std::vector`

`v.pop_back()`

Exercise: Given `v` of type `std::vector<int>`, remove all the consecutive even numbers in the end.

---

## Remove the last element of a `std::vector`

`v.pop_back()`

Exercise: Given `v` of type `std::vector<int>`, remove all the consecutive even numbers in the end.


<pre><code class="language-cpp">while (!v.empty() &amp;&amp; v.back() % 2 == 0)
  v.pop_back();
</code></pre>


`v.back()`: returns the ***reference*** to the last element.

- How is it different from "returning the *value* of the last element"?

---

## `v.back()` and `v.front()`

Return the references to the last and the first elements, respectively.

It is a **reference**, through which we can modify the corresponding element.


<pre><code class="language-cpp">v.front() = 42;
++v.back();
</code></pre>


For `v.back()`, `v.front()` and `v.pop_back()`, **the behavior is undefined** if `v` is empty. They do not perform any bounds checking.

---

## Range-based `for` loops

A `std::vector` can also be traversed using a **range-based `for` loop**.


<pre><code class="language-cpp">std::vector&lt;int&gt; vi = some_values();
for (int x : vi)
  std::cout &lt;&lt; x &lt;&lt; std::endl;
std::vector&lt;std::string&gt; vs = some_strings();
for (const std::string &amp;s : vs) // use reference-to-const to avoid copy
  std::cout &lt;&lt; s &lt;&lt; std::endl;
</code></pre>


Exercise: Use range-based `for` loops to count the number of uppercase letters in a `std::vector<std::string>`.

---

## Range-based `for` loops

Exercise: Use range-based `for` loops to count the number of uppercase letters in a `std::vector<std::string>`.


<pre><code class="language-cpp">int cnt = 0;
for (const std::string &amp;s : vs) { // Use reference-to-const to avoid copy
  for (char c : s) {
    if (std::isupper(c))
      ++cnt;
  }
}
</code></pre>


---

## Access through subscripts

`v[i]` returns the **reference** to the element indexed `i`.

- `i` $\in[0,N)$, where $N=$ `v.size()`.
- Subscript out of range is **undefined behavior**. `v[i]` performs no bounds checking.
  - In pursuit of efficiency, most operations on standard library containers do not perform bounds checking.
- A kind of "subscript" that has bounds checking: `v.at(i)`.
  - If `i` is out of range, *a `std::out_of_range` exception is thrown*.

---

## Feel the style of STL

Basic and low-level operations are performed automatically:

- Default initialization of `std::string` and `std::vector` results in an empty string / container, not indeterminate values.
- Copy of `std::string` and `std::vector` is done automatically, which performs member-wise copy.
- Memory management is done automatically.

Interfaces are consistent:

- `std::string` also has member functions like `.push_back(x)`, `.pop_back()`, `.at(i)`, `.size()`, `.clear()`, etc. which do the same things as on `std::vector`.
- Both can be traversed by range-`for`.

# CS100 Lecture 13

"C" in C++

---

## Contents

"C" in C++

- Type System
  - Stronger Type Checking
  - Explicit Casts
  - Type Deduction
- Functions
  - Default Arguments
  - Function Overloading
- Range-Based `for` Loops Revisited

---

## "Better C"

C++ was developed based on C.

From *The Design and Evolution of C++*:

> C++ is a general-purpose programming language that
>
> - **is a better C**,
> - supports data abstraction,
> - supports object-oriented programming.

C++ brought up new ideas and improvements of C, some of which also in turn influenced the development of C.

---

## "Better C"

- `bool`, `true` and `false` are built-in. No need to `#include <stdbool.h>`. `true` and `false` are of type `bool`, not `int`.
  - This is also true since C23.
- The return type of logical operators `&&`, `||`, `!` and comparison operators `<`, `<=`, `>`, `>=`, `==`, `!=` is `bool`, not `int`.
- The type of string literals `"hello"` is `const char [N+1]`, not `char [N+1]`.
  - Recall that string literals are stored in **read-only memory**. Any attempt to modify them results in undefined behavior.
- The type of character literals `'a'` is `char`, not `int`.

---

## "Better C"

- `const` variables initialized with literals are compile-time constants. They can be used as the length of arrays.

  ```cpp
  const int maxn = 1000;
  int a[maxn]; // a normal array in C++, but VLA in C
  ```

- `int fun()` declares a function accpeting no arguments. It is not accepting unknown arguments.

  - This is also true since C23.

---

# Type System

---

## Stronger type checking

Some arithmetic conversions are problematic: They are not value-preserving.


<pre><code class="language-c">int x = some_int_value();
long long y = x; // OK. Value-preserving
long long z = some_long_long_value();
int w = z;       // Is this OK?
</code></pre>


- Conversion from `int` to `long long` is value-preserving, without doubt.
- Conversion from `long long` to `int` may lose precision. ("narrowing")

However, no warning or error is generated for such conversions in C.

---

## Stronger type checking

Some arithmetic conversions are problematic: They are not value-preserving.


<pre><code class="language-cpp">long long z = some_long_long_value();
int w = z; // &quot;narrowing&quot; conversion
</code></pre>


Stroustrup had decided to ban all implicit narrowing conversions in C++. However,

> The experiment failed miserably. Every C program I looked at contained large numbers of assignments of `int`s to `char` variables. Naturally, since these were **working programs**, most of these assignments were perfectly safe. That is, either the value was small enough not to become truncated, or the truncation was expected or at least harmless in that particular context.

In the end, narrowing conversions are not banned completely in C++. They are not allowed only in a special context in modern C++. We will see it soon.

---

## Stronger type checking

Some type conversions (casts) can be very dangerous:


<pre><code class="language-c">const int x = 42, *pci = &amp;x;
int *pi = pci; // Warning in C, Error in C++
++*pi;         // undefined behavior
char *pc = pi; // Warning in C, Error in C++
void *pv = pi; char *pc2 = pv; // Even no warning in C! Error in C++.
int y = pc;    // Warning in C, Error in C++
</code></pre>


- For `T` $\neq$ `U`, `T *` and `U *` are different types. Treating a `T *` as `U *` leads to undefined behavior in most cases, but the C compiler gives only a warning!
- `void *` is a hole in the type system. You can cast anything to and from it **without even a warning**.

C++ does not allow the dangerous type conversions to happen ***implicitly***.

---

## Explicit Casts

C++ provides four **named cast operators**:

- `static_cast<Type>(expr)`
- `const_cast<Type>(expr)`
- `reinterpret_cast<Type>(expr)`
- `dynamic_cast<Type>(expr)` $\Rightarrow$ will be covered in later lectures.

In contrast, the C style explicit cast `(Type)expr` looks way too innocent.

"An ugly behavior should have an ugly looking."

---

## `const_cast`

Cast away low-level constness **(DANGEROUS)**:


<pre><code class="language-cpp">int ival = 42;
const int &amp;cref = ival;
int &amp;ref = cref; // Error: casting away low-level constness
int &amp;ref2 = const_cast&lt;int &amp;&gt;(cref); // OK
int *ptr = const_cast&lt;int *&gt;(&amp;cref); // OK
</code></pre>


However, modifying a `const` object through a non-`const` access path (possibly formed by `const_cast`) results in **undefined behavior**!


<pre><code class="language-cpp">const int cival = 42;
int &amp;ref = const_cast&lt;int &amp;&gt;(cival); // compiles, but dangerous
++ref; // undefined behavior (may crash)
</code></pre>


---

## `reinterpret_cast`

Often used to perform conversion between different pointer types **(DANGEROUS)**:


<pre><code class="language-cpp">int ival = 42;
char *pc = reinterpret_cast&lt;char *&gt;(&amp;ival);
</code></pre>


We must never forget that the actual object addressed by `pc` is an `int`, not a character! Any use of `pc` that assumes it's an ordinary character pointer **is likely to fail** at run time, e.g.:


<pre><code class="language-cpp">std::string str(pc); // undefined behavior
</code></pre>


**Wherever possible, do not use it!**

---

## `static_cast`

Other types of conversions (which often look "harmless"):


<pre><code class="language-cpp">double average = static_cast&lt;double&gt;(sum) / n;
int pos = static_cast&lt;int&gt;(std::sqrt(n));
</code></pre>


Some typical usage: $\Rightarrow$ We will talk about them in later lectures.


<pre><code class="language-cpp">static_cast&lt;std::string &amp;&amp;&gt;(str) // converts to a xvalue
static_cast&lt;Derived *&gt;(base_ptr) // downcast without runtime checking
</code></pre>


---

## Minimize casting

**[Best practice]** <u>Minimize casting. (*Effective C++* Item 27)</u>

Type systems work as a **guard** against possible errors: Type mismatch often indicates a logical error.

**[Best practice]** <u>When casting is necessary, **prefer C++-style casts to old C-style casts**.</u>

- With old C-style casts, you can't even tell whether it is dangerous or not!

---

## Type deduction

C++ is very good at **type computations**:


<pre><code class="language-cpp">std::vector v(10, 42);
</code></pre>


- It should be `std::vector<int> v(10, 42);`, but the compiler can deduce that `int` from `42`.


<pre><code class="language-cpp">int x = 42; double d = 3.14; std::string s = &quot;hello&quot;;
std::cout &lt;&lt; x &lt;&lt; d &lt;&lt; s;
</code></pre>


- The compiler can detect the types of `x`, `d` and `s` and select the correct printing functions.

---

## `auto`

When declaring a variable with an initializer, we can use the keyword `auto` to let the compiler deduce the type.


<pre><code class="language-cpp">auto x = 42;    // `int`, because 42 is an `int`.
auto y = 3.14;  // `double`, because 3.14 is a `double`.
auto z = x + y; // `double`, because the type of `x + y` is `double`.
auto m;         // Error: cannot deduce the type. An initializer is needed.
</code></pre>


`auto` can also be used to produce compound types:


<pre><code class="language-cpp">auto &amp;r = x;        // `int &amp;`, because `x` is an `int`.
const auto &amp;rc = r; // `const int &amp;`.
auto *p = &amp;rc;      // `const int *`, because `&amp;rc` is `const int *`.
</code></pre>


---

## `auto`

What about this?


<pre><code class="language-cpp">auto str = &quot;hello&quot;;
</code></pre>


---

## `auto`

What about this?


<pre><code class="language-cpp">auto str = &quot;hello&quot;; // `const char *`
</code></pre>


- Recall that the type of `"hello"` is **`const char [6]`**, not `std::string`. This is for compatibility with C.
- When using `auto`, the array-to-pointer conversion ("decay") is performed automatically.

---

## `auto`

Deduction of return type is also allowed (since C++14):


<pre><code class="language-cpp">auto sum(int x, int y) {
  return x + y;
}
</code></pre>


- The return type is deduced to `int`.

Since C++20, `auto` can also be used for function parameters! Such a function is actually a function template.

- This is beyond the scope of CS100.


<pre><code class="language-cpp">auto sum(auto x, auto y) {
  return x + y;
}
</code></pre>


---

## `auto`

`auto` lets us enjoy the benefits of the static type system.

Some types in C++ are very long:


<pre><code class="language-cpp">std::vector&lt;std::string&gt;::const_iterator it = vs.begin();
</code></pre>


Use `auto` to simplify it:


<pre><code class="language-cpp">auto it = vs.begin();
</code></pre>


---

## `auto`

`auto` lets us enjoy the benefits of the static type system.

Some types in C++ are not known to anyone but the compiler:


<pre><code class="language-cpp">auto lam = [](int x, int y) { return x + y; } // A lambda expression.
</code></pre>


Every lambda expression has its own type, whose name is only known by the compiler.

---

## `decltype`

`decltype(expr)` will deduce the type of the expression `expr` **without evaluating it**.


<pre><code class="language-cpp">auto fun(int a, int b) { // The return type is deduced to be `int`.
  std::cout &lt;&lt; &quot;fun() is called.\n&quot;
  return a + b;
}
int x = 10, y = 15;
decltype(fun(x, y)) z; // Same as `int z;`.
                       // Unlike `auto`, no initializer is required here.
                       // The type is deduced from the return type of `fun`.
</code></pre>


- `decltype(fun(x, y))` only deduces the return type of `fun` without actually calling it. Therefore, **no output is produced**.

---

## Note on `auto` and `decltype`

The detailed rules of `auto` and `decltype` (as well as their differences) are complicated, and require some deeper understanding of C++ types and templates. You don't have to remember them.

Learn about them mainly through experiments.

- A good IDE should be of great help: Place your mouse on it, and your IDE should tell you the deduction result.

C23 also has `auto` type deduction.

---

# Functions

---

## Default arguments

Some functions have parameters that are given a particular value in most, but not all, calls. In such cases, we can declare that common value as a **default argument**.


<pre><code class="language-cpp">std::string get_screen(std::size_t height = 24, std::size_t width = 80,
                       char background = ' ');
</code></pre>


- By default, the screen is $24\times 80$ filled with `' '`.

  ```cpp
  auto default_screen = get_screen();
  ```

- To override the default arguments:

  ```cpp
  auto large_screen   = get_screen(66);           // 66x80, filled with ' '
  auto larger_screen  = get_screen(66, 256);      // 66x256, filled with ' '
  auto special_screen = get_screen(66, 256, '#'); // 66x256, filled with '#'
  ```

---

## Default arguments

Arguments in the call are resolved by position.


<pre><code class="language-cpp">auto scr = get_screen('#'); // Passing the ASCII value of '#' to `height`.
                            // `width` and `background` are set to
                            // default values (`80` and `' '`).
</code></pre>


- Some other languages have named parameters:

  ```python
  print(a, b, sep=", ", end="") # Python
  ```

  There is no such syntax in C++.

Default arguments are only allowed for the last (right-most) several parameters:


<pre><code class="language-cpp">std::string get_screen(std::size_t height = 24, std::size_t width,
                       char background); // Error.
</code></pre>


---

## Function overloading

In C++, a group of functions can have the same name, as long as they can be differentiated when called.


<pre><code class="language-cpp">int max(int a, int b) {
  return a &lt; b ? b : a;
}
double max(double a, double b) {
  return a &lt; b ? b : a;
}
const char *max(const char *a, const char *b) {
  return std::strcmp(a, b) &lt; 0 ? b : a;
}
</code></pre>



<pre><code class="language-cpp">auto x = max(10, 20);           // Calls max(int, int)
auto y = max(3.14, 2.5);        // Calls max(double, double)
auto z = max(&quot;hello&quot;, &quot;world&quot;); // Calls max(const char *, const char *)
</code></pre>


---

## Overloaded functions

Overloaded functions should be distinguished in the way they are called.


<pre><code class="language-cpp">int fun(int);
double fun(int);  // Error: functions that differ only in
                  // their return type cannot be overloaded.
</code></pre>



<pre><code class="language-cpp">void move_cursor(Coord to);
void move_cursor(int r, int c); // OK, differ in the number of arguments
</code></pre>


---

## Overloaded functions

Overloaded functions should be distinguished in the way they are called.

- The following are declaring **the same function**. They are not overloading.

  ```cpp
  void fun(int *);
  void fun(int [10]);
  ```

- The following are the same for an array argument:

  ```cpp
  void fun(int *a);
  void fun(int (&a)[10]);
  int ival = 42; fun(&ival); // OK, calls fun(int *)
  int arr[10];   fun(arr);   // Error: ambiguous call
  ```

  Why?

---

## Overloaded functions

Overloaded functions should be distinguished in the way they are called.

- The following are the same for an array argument:

  ```cpp
  void fun(int *a);
  void fun(int (&a)[10]);
  int arr[10];   fun(arr);   // Error: ambiguous call
  ```

  - For `fun(int (&)[10])`, this is **an exact match**.
  - For `fun(int *)`, this involves an array-to-pointer implicit conversion. We will see that this is **also considered an exact match**.

---

## Basic overload resolution

Suppose we have the following overloaded functions.


<pre><code class="language-cpp">void fun(int);
void fun(double);
void fun(int *);
void fun(const int *);
</code></pre>


Which will be the best match for a call `fun(a)`?

---

## Basic overload resolution

Suppose we have the following overloaded functions.


<pre><code class="language-cpp">void fun(int);
void fun(double);
void fun(int *);
void fun(const int *);
</code></pre>


<div style="display: grid; grid-template-columns: 1fr 1fr;">
  <div>


Obvious: The arguments and the parameters match perfectly.


<pre><code class="language-cpp">fun(42);   // fun(int)
fun(3.14); // fun(double)
const int arr[10];
fun(arr);  // fun(const int *)
</code></pre>


  </div>

  <div>


Not so obvious:


<pre><code class="language-cpp">int ival = 42;
// fun(int *) or fun(const int *)?
fun(&amp;ival);
fun('a');   // fun(int) or fun(double)?
fun(3.14f); // fun(int) or fun(double)?
fun(NULL);  // fun(int) or fun(int *)?
</code></pre>


  </div>
</div>

---

## Basic overload resolution


<pre><code class="language-cpp">void fun(int);
void fun(double);
void fun(int *);
void fun(const int *);
</code></pre>


- `fun(&ival)` matches `fun(int *)`
- `fun('a')` matches `fun(int)`
- `fun(3.14f)` matches `fun(double)`
- `fun(NULL)` ? We will see this later.

There are detailed rules that define these behaviors. **But our program should avoid such confusing overload sets.**

---

## Basic overload resolution

1. An exact match, including the following cases:
   - identical types
   - **match through decay of array** *(or function)* **type**
   - match through top-level `const` conversion
2. **Match through adding low-level `const`**
3. Match through [integral or floating-point promotion](https://en.cppreference.com/w/cpp/language/implicit_conversion#Numeric_promotions)
4. Match through [numeric conversion](https://en.cppreference.com/w/cpp/language/implicit_conversion#Numeric_conversions)
5. Match through a class-type conversion (in later lectures).

No need to remember all the details. But pay attention to some cases that are very common.

---

## The null pointer

`NULL` is a **macro** defined in standard library header files.

- In C, it may be defined as `(void *)0`, `0`, `(long)0` or other forms.

In C++, `NULL` cannot be `(void *)0` since the implicit conversion from `void *` to other pointer types is **not allowed**.

- It is most likely to be an integer literal with value zero.

- With the following overload declarations, `fun(NULL)` may call `fun(int)` on some platforms, and may be **ambiguous** on other platforms!

  <div style="display: grid; grid-template-columns: 1fr 1fr;">
    <div>


    ```cpp
  void fun(int);
  void fun(int *);
    ```

    </div>

    <div>


    ```cpp
  fun(NULL); // May call fun(int),
             // or may be ambiguous.
    ```

    </div>
  </div>

---

## Better null pointer: `nullptr`

In short, `NULL` is a "fake" pointer.

Since C++11, a better null pointer is introduced: `nullptr` (also available in C23)

- `nullptr` has a unique type `std::nullptr_t` (defined in `<cstddef>`), which is neither `void *` nor an integer.

- `fun(nullptr)` will definitely match `fun(int *)`.

  <div style="display: grid; grid-template-columns: 1fr 1fr;">
    <div>


    ```cpp
  void fun(int);
  void fun(int *);
    ```

    </div>

    <div>


    ```cpp
  fun(NULL); // May call fun(int),
             // or may be ambiguous.
  fun(nullptr); // Calls fun(int *).
    ```

    </div>
  </div>

**[Best practice]** <u>Use `nullptr` as the null pointer constant in C++.</u>

---

## Avoid abuse of function overloading

Only overload operations that actually do similar things. A bad example:


<pre><code class="language-cpp">Screen &amp;moveHome(Screen &amp;);
Screen &amp;moveAbs(Screen &amp;, int, int);
Screen &amp;moveRel(Screen &amp;, int, int, std::string direction);
</code></pre>


If we overload this set of functions under the name `move`, some information is lost.


<pre><code class="language-cpp">Screen &amp;move(Screen &amp;);
Screen &amp;move(Screen &amp;, int, int);
Screen &amp;move(Screen &amp;, int, int, std::string direction);
</code></pre>


Which one is easier to understand?

<div style="display: grid; grid-template-columns: 1fr 1fr;">
  <div>



<pre><code class="language-cpp">moveHome(scrn); // OK, moves to home.
</code></pre>


  </div>

  <div>



<pre><code class="language-cpp">move(scrn); // Unclear: How to move?
</code></pre>


  </div>
</div>

---

# Range-based `for` loops revisited

---

## Range-based `for` loops

Traverse a `std::string`


<pre><code class="language-cpp">int str_to_int(const std::string &amp;str) {
  int value = 0;
  for (auto c : str) // char
    value = value * 10 + c - '0';
  return value;
}
</code></pre>


Note: This function can be replaced by `std::stol`.

---

## Range-based `for` loops

Traverse a `std::vector`


<pre><code class="language-cpp">bool is_all_digits(const std::string &amp;str) {
  for (auto c : str)
    if (!std::isdigit(c))
      return false;
  return true;
}
int count_numbers(const std::vector&lt;std::string&gt; &amp;strs) {
  int cnt = 0;
  for (const auto &amp;s : strs) // const std::string &amp;s
    if (is_all_digits(s))
      ++cnt;
  return cnt;
}
</code></pre>


---

## Traverse an array

An array can also be traversed by range-`for`:


<pre><code class="language-cpp">int arr[100] = {}; // OK in C++ and C23.
// The following loop will read 100 integers.
for (auto &amp;x : arr) // int &amp;
  std::cin &gt;&gt; x;
</code></pre>


- Note: The range-based `for` loop will traverse **the entire array**.

What else can be traversed using a range-`for`? $\Rightarrow$ We will learn about this when introducing **iterators**.

---

## Pass an array by reference


<pre><code class="language-cpp">void print(int *arr) {
  for (auto x : arr) // Error: `arr` is a pointer, not an array.
    std::cout &lt;&lt; x &lt;&lt; ' ';
  std::cout &lt;&lt; '\n';
}
</code></pre>


We can declare `arr` to be a **reference to array**:


<pre><code class="language-cpp">void print(const int (&amp;arr)[100]) {
  for (auto x : arr) // OK. `arr` is an array.
    std::cout &lt;&lt; x &lt;&lt; ' ';
  std::cout &lt;&lt; '\n';
}
</code></pre>


- `arr` is of type `const int (&)[100]`: a reference to an array of `100` elements, where each element is of type `const int`.

---

## Pass an array by reference

We can declare `arr` to be a **reference to array**:


<pre><code class="language-cpp">void print(const int (&amp;arr)[100]) {
  for (auto x : arr) // OK. `arr` is an array.
    std::cout &lt;&lt; x &lt;&lt; ' ';
  std::cout &lt;&lt; '\n';
}
</code></pre>


- `arr` is of type `const int (&)[100]`: a reference to an array of `100` elements, where each element is of type `const int`.

Note that only arrays of `100` `int`s can fit here.


<pre><code class="language-cpp">int a[100] = {}; print(a); // OK.
int b[101] = {}; print(b); // Error.
double c[100] = {}; print(c); // Error.
</code></pre>


---

## Pass an array by reference

To allow arrays of any type, any length: Use a template function.


<pre><code class="language-cpp">template &lt;typename Type, std::size_t N&gt;
void print(const Type (&amp;arr)[N]) {
  for (const auto &amp;x : arr)
    std::cout &lt;&lt; x &lt;&lt; ' ';
  std::cout &lt;&lt; '\n';
}
</code></pre>


We will learn about this in the end of this semester.

# CS100 Lecture 14

Class Basics <span style="color: black; font-family: Times New Roman; font-size: 1.05em;">I</span>

---

## Contents

Class basics

- Members of a class
  - Access
  - The `this` pointer
- Constructors
  - Constructor initializer list
  - Default constructors

---

# Members of a class

---

## A simple `class` 

The initial idea: A `class` is a new kind of `struct` that can have member functions:


<pre><code class="language-cpp">class Student {
  std::string name; 
  std::string id;
  int entranceYear;
  void setName(const std::string &amp;newName) {
    name = newName;
  }
  void printInfo() const {
    std::cout &lt;&lt; &quot;I am &quot; &lt;&lt; name &lt;&lt; &quot;, id &quot; &lt;&lt; id  
              &lt;&lt; &quot;, entrance year: &quot; &lt;&lt; entranceYear &lt;&lt; std::endl;
  }
  bool graduated(int year) const {
    return year - entranceYear &gt;= 4; 
  }
};
</code></pre>


---

## Member access

Member access: `a.mem`, where `a` is an **object** of the class type.

- Every member ${}^{\textcolor{red}{1}}$ belongs to an object: each student has a name, id, entrance year, etc.
  - You need to specify *whose* name / id / ... you want to obtain.

To call a member function on an object: `a.memfun(args)`.


<pre><code class="language-cpp">Student s = someValue();
s.printInfo(); // call its printInfo() to print related info  
if (s.graduated(2023)) {
  // ...
}
</code></pre>


---

## Access control


<pre><code class="language-cpp">class Student {
private:
  std::string name; 
  std::string id;
  int entranceYear;
public:
  void setName(const std::string &amp;newName) { name = newName; }
  void printInfo() const {
    std::cout &lt;&lt; &quot;I am &quot; &lt;&lt; name &lt;&lt; &quot;, id &quot; &lt;&lt; id  
              &lt;&lt; &quot;, entrance year: &quot; &lt;&lt; entranceYear &lt;&lt; std::endl;
  }
  bool graduated(int year) const { return year - entranceYear &gt;= 4; }
};
</code></pre>


- `private` members: Only accessible to code inside the class and `friend`s.
  - $\Rightarrow$ We will introduce `friend`s in later lectures.
- `public` members: Accessible to all parts of the program.

---

## Access control 


<pre><code class="language-cpp">class Student {
private:
  std::string name;
  std::string id; 
  int entranceYear;

public:
  void setName(const std::string &amp;newName);
  void printInfo() const;
  bool graduated(int year) const;  
};
</code></pre>


Unlike some other languages (e.g. Java), an access specifier controls the access of all members after it, until the next access specifier or the end of the class definition.

---

## Access control 


<pre><code class="language-cpp">class Student {
// private:
  std::string name;
  std::string id; 
  int entranceYear;
public:
  void setName(const std::string &amp;newName);
  void printInfo() const;
  bool graduated(int year) const;  
};
</code></pre>


What if there is a group of members with no access specifier at the beginning?

- If it's `class`, they are `private`.  
- If it's `struct`, they are `public`.

This is one of the **only two differences** between `struct` and `class` in C++.

---

## The `this` pointer


<pre><code class="language-cpp">class Student {
  // ...  
public:
  bool graduated(int year) const;
};

Student s = someValue();
if (s.graduated(2023))
  // ...
</code></pre>


How many parameters does `graduated` have?

---

## The `this` pointer


<pre><code class="language-cpp">class Student {
  // ...
public:
  bool graduated(int year) const; 
};

Student s = someValue();
if (s.graduated(2023)) // ...
</code></pre>


How many parameters does `graduated` have?

- **Seemingly one, but actually two:** `s` is also information that must be known when calling this function!

---

## The `this` pointer

<div style="display: grid; grid-template-columns: 0.9fr 1fr;">
  <div>



<pre><code class="language-cpp">class Student {
public:
  void setName(const std::string &amp;n) {
    name = n;
  }

  bool graduated(int year) const {
    return year - entranceYear &gt;= 4;
  }  
};

Student s = someValue();
if (s.graduated(2023)) 
  // ...
s.setName(&quot;Alice&quot;);
</code></pre>


  </div>

  <div>


- The code on the left can be viewed as:


<pre><code class="language-cpp">void setName
    (Student *this, const std::string &amp;n) {
  this-&gt;name = n;
}
bool graduated
    (const Student *this, int year) {
  return year - this-&gt;entranceYear &gt;= 4;
}

Student s = someValue();
if (graduated(&amp;s, 2023))
  // ...  
setName(&amp;s, &quot;Alice&quot;);
</code></pre>


  </div>
</div>

---

## The `this` pointer

There is a pointer called `this` in each member function of class `X` which has type `X *` or `const X *`, pointing to the object on which the member function is called.

Inside a member function, access of any member `mem` is actually `this->mem`.

We can also write `this->mem` explicitly.


<pre><code class="language-cpp">class Student {
public:
  bool graduated(int year) const {
    return year - this-&gt;entranceYear &gt;= 4;
  }
};
</code></pre>


Many languages have similar constructs, e.g. `self` in Python. [(C++23 has `self` too!)](https://en.cppreference.com/w/cpp/language/member_functions#Explicit_object_parameter)

---

## `const` member functions

The `const` keyword after the parameter list and before the function body `{` is used to declare a **`const` member function**.

- A `const` member function cannot modify its data members ${}^{\textcolor{red}{2}}$.
- A `const` member function **guarantees** that no data member will be modified.
  - A non-`const` member function does not provide such guarantee.
  - In a `const` member function, calling a non-`const` member function on `*this` is not allowed.
- For a `const` object, **only `const` member functions can be called on it**.

**[Best practice]** <u>If, logically, a member function should not modify the object's state, it should be made a `const` member function.</u> Otherwise, it cannot be called on `const` objects.

---

## `const` member functions and the `this` pointer

This `const` is essentially applied to the `this` pointer:

- In `const` member functions of class `X`, `this` has type `const X *`.
- In non-`const` member functions of class `X`, `this` has type `X *`.

If `ptr` is of type `const T *`, the expression `ptr->mem` is also `const`-qualified.

- Recall that in a member function, access of a member `mem` is actually `this->mem`.
- Therefore, `mem` is also `const`-qualified in a `const` member function.


<pre><code class="language-cpp">class Student {
public:
  void foo() const {
    name += 'a'; // Error: `name` is `const std::string` in a const member
                 // function. It cannot be modified.
  }
};
</code></pre>


---

## `const` member functions

*Effective C++* Item 3: **Use `const` whenever possible.**

Decide whether the following member functions need a `const` qualification:


<pre><code class="language-cpp">class Student {
  std::string name, id;
  int entranceYear;
public:
  const std::string &amp;getName(); // returns the name of the student.
  const std::string &amp;getID();   // returns the id of the student.
  bool valid();    // verifies whether the leading four digits in `id`
                   // is equal to `entranceYear`.
  void adjustID(); // adjust `id` according to `entranceYear`.
};
</code></pre>


---

## `const` member functions

*Effective C++* Item 3: **Use `const` whenever possible.**

Decide whether the following member functions need a `const` qualification:


<pre><code class="language-cpp">class Student {
  std::string name, id;
  int entranceYear;
public:
  const std::string &amp;getName() const; // returns the name of the student.
  const std::string &amp;getID() const;   // returns the id of the student.
  bool valid() const;    // verifies whether the leading four digits in `id`
                         // is equal to `entranceYear`.
  void adjustID(); // adjust `id` according to `entranceYear`.
};
</code></pre>


The `const`ness of member functions should be determined **logically**.

---

## `const` member functions


<pre><code class="language-cpp">class Student {
  std::string name, id;
  int entranceYear;
public:
  const std::string &amp;getName() const { return name; }
  const std::string &amp;getID() const { return id; }
  bool valid() const { return id.substr(0, 4) == std::to_string(entranceYear); }
  void adjustID() { id = std::to_string(entranceYear) + id.substr(4); }
};
</code></pre>


`str.substr(pos, len)` returns the substring of `str` starting from the position indexed `pos` with length `len`.

- If `len` is not provided, it returns the **suffix** starting from the position indexed `pos`.

---

# Constructors

Often abbreviated as "ctors".

---

## Constructors

**Constructors** define how an object can be initialized.

- Constructors are often **overloaded**, because an object may have multiple reasonable ways of initialization.


<pre><code class="language-cpp">class Student {
  std::string name;
  std::string id;
  int entranceYear;
public:
  Student(const std::string &amp;name_, const std::string &amp;id_, int ey) 
    : name(name_), id(id_), entranceYear(ey) {}
  Student(const std::string &amp;name_, const std::string &amp;id_)
    : name(name_), id(id_), entranceYear(std::stoi(id_.substr(0, 4))) {}   
};

Student a(&quot;Alice&quot;, &quot;2020123123&quot;, 2020);
Student b(&quot;Bob&quot;, &quot;2020123124&quot;); // entranceYear = 2020
Student c; // Error: No default constructor. (to be discussed later)
</code></pre>


---

## Constructors


<pre><code class="language-cpp">class Student {
  std::string name;
  std::string id;
  int entranceYear;

public:
  Student(const std::string &amp;name_, const std::string &amp;id_) 
    : name(name_), id(id_), entranceYear(std::stoi(id_.substr(0, 4))) {}
};
</code></pre>


- The constructor name is the class name: `Student`.
- Constructors do not have a return type (not even `void` ${}^{\textcolor{red}{3}}$). The constructor body can contain a `return;` statement, which should not return a value.
- The function body of this constructor is empty: `{}`.

---

## Constructor initializer list

Constructors initialize **all data members** of the object.

The initialization of **all data members** is done **before entering the function body**.

How they are initialized is (partly) determined by the **constructor initializer list**:


<pre><code class="language-cpp">class Student {
  // ...
public:
  Student(const std::string &amp;name_, const std::string &amp;id_) 
    : name(name_), id(id_), entranceYear(std::stoi(id_.substr(0, 4))) {} 
};
</code></pre>


The initializer list starts with `:`, and contains initializers for each data member, separated by `,`. The initializers must be of the form `(...)` or `{...}`, not `= ...`.

---

## Order of initialization

Data members are initialized in order **in which they are declared**, not the order in the initializer list.

- If the initializers appear in an order different from the declaration order, the compiler will generate a warning.

Typical mistake: `entranceYear` is initialized in terms of `id`, but `id` is not initialized yet!


<pre><code class="language-cpp">class Student {
  std::string name;
  int entranceYear; // !!!
  std::string id;

public:
  Student(const std::string &amp;name_, const std::string &amp;id_)
    : name(name_), id(id_), entranceYear(std::stoi(id.substr(0, 4))) {}
};
</code></pre>


---

## Constructor initializer list

Data members are initialized in order **in which they are declared**, not the order in the initializer list.

- If the initializers appear in an order different from the declaration order, the compiler will generate a warning.  
- For a data member that do not appear in the initializer list:
  - If there is an **in-class initializer** (see next page), it is initialized using the in-class initializer.
  - Otherwise, it is **default-initialized**.

What does **default-initialization** mean for class types? $\Rightarrow$ To be discussed later.

---

## In-class initializers

A member can have an in-class initializer. It must be in the form `{...}` or `= ...`.${}^{\textcolor{red}{4}}$


<pre><code class="language-cpp">class Student {
  std::string name = &quot;Alice&quot;;
  std::string id;
  int entranceYear{2024}; // equivalent to `int entranceYear = 2024;`.
public:
  Student() {} // `name` is initialized to `&quot;Alice&quot;`,
               // `id` is initialized to an empty string,
               // and `entranceYear` is initialized to 2024.
  Student(int ey) : entranceYear(ey) {} // `name` is initialized to `&quot;Alice&quot;`,
                                    // `id` is initialized to an empty string,
                                    // and `entranceYear` is initialized to `ey`.
};
</code></pre>


The in-class initializer provides the "default" way of initializing a member in this class, as a substitute for default-initialization.

---

## Constructor initializer list

Below is a typical way of writing this constructor without an initializer list:


<pre><code class="language-cpp">class Student {
  // ...
public:
  Student(const std::string &amp;name_, const std::string &amp;id_) {
    name = name_;
    id = id_;
    entranceYear = std::stoi(id_.substr(0, 4));
  }
}; 
</code></pre>


How are these members actually initialized in this constructor?

---

## Constructor initializer list

Below is a typical way of writing this constructor without an initializer list:


<pre><code class="language-cpp">class Student {
  // ...
public:
  Student(const std::string &amp;name_, const std::string &amp;id_) {
    name = name_;
    id = id_;
    entranceYear = std::stoi(id_.substr(0, 4));
  }
}; 
</code></pre>


How are these members actually initialized in this constructor?

- First, before entering the function body, `name`, `id` and `entranceYear` are default-initialized. `name` and `id` are initialized to empty strings.
- Then, the assignments in the function body take place.

---

## Constructor initializer list

**[Best practice]** <u>Always use an initializer list in a constructor.</u>

- Not all types can be default-initialized. Not all types can be assigned to. (Any counterexamples?)

---

## Constructor initializer list

**[Best practice]** <u>Always use an initializer list in a constructor.</u>

Not all types can be default-initialized. Not all types can be assigned to.

- References `T &` cannot be default-initialized, and cannot be assigned to.
- `const` objects of built-in types cannot be default-initialized.
- `const` objects cannot be assigned to.
- A class can choose to allow or disallow default initialization or assignment. It depends on the design. $\Rightarrow$ See next page.

Moreover, if a data member is default-initialized and then assigned when could have been initialized directly, it may lead to low efficiency.

---

## Default constructors

A special constructor that takes no parameters.

- Guess what it's for?

---

## Default Constructors

A special constructor that takes no parameters.

- It defines the behavior of **default-initialization** of objects of that class type, since no arguments need to be passed when calling it.


<pre><code class="language-cpp">class Point2d {
  double x, y;
public:
  Point2d() : x(0), y(0) {} // default constructor
  Point2d(double x_, double y_) : x(x_), y(y_) {}  
};

Point2d p1;       // calls default ctor, (0, 0) 
Point2d p2(3, 4); // calls Point2d(double, double), (3, 4)
Point2d p3();     // Is this calling the default ctor?
</code></pre>


---

## Default constructors

A special constructor that takes no parameters.

- It defines the behavior of **default-initialization** of objects of that class type, since no arguments need to be passed when calling it.


<pre><code class="language-cpp">class Point2d {
  double x, y;
public:
  Point2d() : x(0), y(0) {} // default constructor
  Point2d(double x_, double y_) : x(x_), y(y_) {}  
};

Point2d p1;       // calls default ctor, (0, 0) 
Point2d p2(3, 4); // calls Point2d(double, double), (3, 4)
Point2d p3();     // Is this calling the default ctor?
</code></pre>


Be careful! `p3` is a **function** that takes no parameters and returns `Point2d`.

---

## Is a default constructor needed?

First, if you need to use arrays, you almost certainly need a default constructor:


<pre><code class="language-cpp">Student s[1000]; // All elements are default-initialized
                 // by the default constructor.
Student s2[1000] = {a, b}; // The first two elements are initialized to
                           // `a` and `b`. The rest are initialized by the
                           // default constructor.
</code></pre>


A `std::vector` does not require that:


<pre><code class="language-cpp">// In this code, the default constructor of `Student` is not called.
std::vector&lt;Student&gt; students;
for (auto i = 0; i != n; ++i)
  students.push_back(some_student());
</code></pre>


---

## Is a default constructor needed? 

If a class has no user-declared constructors, the compiler will try to synthesize a default constructor.


<pre><code class="language-cpp">class X {}; // No user-declared constructors.
X x; // OK: calls the compiler-synthesized default constructor
</code></pre>


The synthesized default constructor initializes the data members as follows:

- If a data member has an in-class initializer, it is initialized according to the in-class initializer.
- Otherwise, default-initialize that member. If it cannot be default-initialized, the compiler will give up -- no default constructor is generated.

---

## Is a default constructor needed?

If a class has any user-declared constructors but no default constructor, the compiler **will not** synthesize a default constructor.

You may ask for a default constructor with `= default;`:


<pre><code class="language-cpp">class Student {
public:
  Student(const std::string &amp;name_, const std::string &amp;id_, int ey)  
    : name(name_), id(id_), entranceYear(ey) {}

  Student(const std::string &amp;name_, const std::string &amp;id_)
    : name(name_), id(id_), entranceYear(std::stoi(id_.substr(0, 4))) {}

  Student() = default;
};
</code></pre>


---

## Is a default constructor needed?

It depends on the **design**:

- If the class has a default constructor, what should be the behavior of it? Is there a reasonable "default state" for your class type?

For `Student`: What is a "default student"?

---

## Is a default constructor needed?

It depends on the **design**:

- If the class has a default constructor, what should be the behavior of it? Is there a reasonable "default state" for your class type?

For `Student`: What is a "default student"?

- There seems to be no such thing as a "default student" (in a normal design). Therefore, `Student` should not have a default constructor.

---

## Is a default constructor needed?

**[Best practice]** <u>**When in doubt, leave it out.** If the class does not have a "default state", it should not have a default constructor!</u>

- Do not define one arbitrarily or letting it `= default`. This leads to pitfalls.
- Calling the default constructor of something that has no "default state" should result in a **compile error**, instead of being allowed arbitrarily.

---

## Summary

Members of a class

- A class can have data members and member functions.
- Access control: `private`, `public`.
  - One difference between `class` and `struct`: Default access.
- The `this` pointer: has type `X *` (`const X *` in `const` member functions). It points to the object on which the member function is called.
- `const` member function: guarantees that no modification will happen.

---

## Summary

The followings hold for **all constructors**, no matter how they are defined:

- A constructor initializes **all** data members in order in which they are declared.
- The initialization of **all** data members is done before the function body of a constructor is executed.

In a constructor, a member is initialized as follows:

- If there is an initializer for it in the initializer list, use it.
- Otherwise, if it has an in-class initializer, use it.
- Otherwise, it is default-initialized. If it cannot be default-initialized, it leads to a compile-error.

---

## Summary

Default constructors

- The default constructor defines the behavior of default-initialization.
- The default constructor is the constructor with an empty parameter list.
- If we have not defined **any constructor**, the compiler will try to synthesize a **default constructor** as if it were defined as `ClassName() {}`.
  - The compiler may fail to do that if some member has no in-class initializer and is not default-initializable. In that case, the compiler gives up (without giving an error).
- We can use `= default` to ask for a synthesized default constructor explicitly.

---

# CS100 Lecture 15

Constructors, Destructors, Copy Control

---

## Contents

- Constructors and destructors
- Copy control

---

# Constructors and destructors

---

## Lifetime of an object

<div style="display: grid; grid-template-columns: 1fr 1fr;">
  <div>


**Lifetime** of a local non-`static` object:

- Starts on initialization
- Ends when control flow goes out of its **scope**


<pre><code class="language-cpp">for (int i = 0; i != n; ++i) {
  do_something(i);
  // Lifetime of `s` begins.
  std::string s = some_string();
  do_something_else(s, i);
/* end of lifetime of `s` */ }
</code></pre>


Every time the loop body is executed, `s` undergoes initialization and destruction.

- `std::string` **owns** some resources (memory where the characters are stored).
- `std::string` must *somehow* release that resources (deallocate that memory) at the end of its lifetime.

---

## Lifetime of an object

Lifetime of a global object:

- Starts on initialization (before the first statement of `main`)
- Ends when the program terminates.

Lifetime of a heap-based object:

- Starts on initialization: **A `new` expression will do this, but `malloc` does not!**
- Ends when it is destroyed: **A `delete` expression will do this, but `free` does not!**

$\Rightarrow$ `new` / `delete` expressions are in this week's recitation.

---

## Constructors and Destructors

Take `std::string` as an example:

- Its initialization (done by its constructors) must allocate some memory for its content.
- When it is destroyed, it must *somehow* deallocate that memory.

---

## Constructors and Destructors

Take `std::string` as an example:

- Its initialization (done by its constructors) must allocate some memory for its content.
- When it is destroyed, it must *somehow* deallocate that memory.

**A destructor of a class is the function that is automatically called when an object of that class type is destroyed.**

---

## Constructors and Destructors

Syntax: `~ClassName() { /* ... */ }`



<pre><code class="language-cpp">struct A {
  A() {
    std::cout &lt;&lt; 'c';
  }
  ~A() {
    std::cout &lt;&lt; 'd';
  }
};
</code></pre>




<pre><code class="language-cpp">for (int i = 0; i != 3; ++i) {
  A a;
  // do something ...
}
</code></pre>


Output:


<pre><code>cdcdcd
</code></pre>


---

## Destructor

Called **automatically** when the object is destroyed!

- How can we make use of this property?

---

## Destructor

Called **automatically** when the object is destroyed!

- How can we make use of this property?

We often do some **cleanup** in a destructor:

- If the object **owns some resources** (e.g. dynamic memory), destructors can be made use of to avoid leaking!


<pre><code class="language-cpp">class A {
  SomeResourceHandle resource;

public:
  A(/* ... */) : resource(obtain_resource(/* ... */)) {}
  ~A() {
    release_resource(resource);
  }
};
</code></pre>


---

## Example: A dynamic array

Suppose we want to implement a "dynamic array":

- It looks like a VLA (variable-length array), but it is heap-based, which is safer.
- It should take good care of the memory it uses.

Expected usage:


<pre><code class="language-cpp">int n; std::cin &gt;&gt; n;
Dynarray arr(n); // `n` is runtime determined
                 // `arr` should have allocated memory for `n` `int`s now.
for (int i = 0; i != n; ++i) {
  int x; std::cin &gt;&gt; x;
  arr.at(i) = x * x; // subscript, looks as if `arr[i] = x * x`
}
// ...
// `arr` should deallocate its memory itself.
</code></pre>


---

## Dynarray: members

- It should have a pointer that points to the memory, where elements are stored.
- It should remember its length.


<pre><code class="language-cpp">class Dynarray {
  int *m_storage;
  std::size_t m_length;
};
</code></pre>


- `m` stands for **member**.

**[Best practice]** <u>Make data members `private`, to achieve good encapsulation.</u>

---

## Dynarray: constructors

- We want `Dynarray a(n);` to construct a `Dynarray` that contains `n` elements.
  - To avoid troubles, we want the elements to be **value-initialized**!
    - **Value-initialization** is like "empty-initialization" in C. (In this week's recitation.)
  - `new int[n]{}`: Allocate a block of heap memory that stores `n` `int`s, and value-initialize them.
- Do we need a default constructor?
  - Review: What is a default constructor?
    - The constructor with no parameters.
  - What should be the correct behavior of it?

---

## Dynarray: constructors

- We want `Dynarray a(n);` to construct a `Dynarray` that contains `n` elements.
  - To avoid troubles, we want the elements to be **value-initialized**!
- Suppose we don't want a default constructor.


<pre><code class="language-cpp">class Dynarray {
  int *m_storage;
  std::size_t m_length;
 public:
  Dynarray(std::size_t n) : m_storage(new int[n]{}), m_length(n) {}
};
</code></pre>


**If the class has a user-declared constructor, the compiler will not generate a default constructor.**

---

## Dynarray: constructors


<pre><code class="language-cpp">class Dynarray {
  int *m_storage;
  std::size_t m_length;
 public:
  Dynarray(std::size_t n) : m_storage(new int[n]{}), m_length(n) {}
};
</code></pre>


Since `Dynarray` has a user-declared constructor, it does not have a default constructor:


<pre><code class="language-cpp">Dynarray a; // Error.
</code></pre>


---

## Dynarray: destructor

- Remember: The destructor is (automatically) called when the object is "dead".
- The memory is obtained in the constructor, and released in the destructor.


<pre><code class="language-cpp">class Dynarray {
  int *m_storage;
  std::size_t m_length;
 public:
  Dynarray(std::size_t n)
    : m_storage(new int[n]{}), m_length(n) {}
  ~Dynarray() {
    delete[] m_storage; // Pay attention to `[]`!
  }
};
</code></pre>


---

## Dynarray: destructor

Is this correct?


<pre><code class="language-cpp">class Dynarray {
  // ...
  ~Dynarray() {
    if (m_length != 0)
      delete[] m_storage;
  }
};
</code></pre>


**NO!** `new [0]` may also allocate some memory (implementation-defined, like `malloc`), which should also be deallocated.

---

## Dynarray: destructor

Is this correct?


<pre><code class="language-cpp">class Dynarray {
  // ...
  ~Dynarray() {
    delete[] m_storage;
    m_length = 0;
  }
};
</code></pre>


It is correct, but `m_length = 0;` is not needed. The destructor is executed **right before the `Dynarray` object "dies"**, so the value of `m_length` does not matter!

---

## Dynarray: some member functions

Design some useful member functions.

- A function to obtain its length (size).
- A function telling whether it is empty.


<pre><code class="language-cpp">class Dynarray {
  // ...
 public:
  std::size_t size() const {
    return m_length;
  }
  bool empty() const {
    return m_length == 0;
  }
};
</code></pre>


---

## Dynarray: some member functions

Design some useful member functions.

- A function returning **reference** to an element.


<pre><code class="language-cpp">class Dynarray {
  // ...
 public:
  int &amp;at(std::size_t i) {
    return m_storage[i];
  }
  const int &amp;at(std::size_t i) const {
    return m_storage[i];
  }
};
</code></pre>


Why do we need this "`const` vs non-`const`" overloading? $\Rightarrow$ Learn it in recitations.

---

## Dynarray: Usage



<pre><code class="language-cpp">void print(const Dynarray &amp;a) {
  for (std::size_t i = 0;
       i != a.size(); ++i)
    std::cout &lt;&lt; a.at(i) &lt;&lt; ' ';
  std::cout &lt;&lt; std::endl;
}
void reverse(Dynarray &amp;a) {
  for (std::size_t i = 0,
    j = a.size() - 1; i &lt; j; ++i, --j)
    std::swap(a.at(i), a.at(j));
}
</code></pre>




<pre><code class="language-cpp">int main() {
  int n; std::cin &gt;&gt; n;
  Dynarray array(n);
  for (int i = 0; i != n; ++i)
    std::cin &gt;&gt; array.at(i);
  reverse(array);
  print(array);
  return 0;
  // Dtor of `array` is called here,
  // which deallocates the memory
}
</code></pre>


---

# Copy control

---

## Copy-initialization

We can easily construct a `std::string` to be a copy of another:


<pre><code class="language-cpp">std::string s1 = some_value();
std::string s2 = s1; // s2 is initialized to be a copy of s1
std::string s3(s1); // equivalent
std::string s4{s1}; // equivalent, but modern
</code></pre>


Can we do this for our `Dynarray`?

---

## Copy-initialization

Before we add anything, let's try what will happen:


<pre><code class="language-cpp">Dynarray a(3);
a.at(0) = 2; a.at(1) = 3; a.at(2) = 5;
Dynarray b = a; // It compiles.
print(b); // 2 3 5
a.at(0) = 70;
print(b); // 70 3 5
</code></pre>


Ooops! Although it compiles, the pointers `a.m_storage` and `b.m_storage` are pointing to the same address!

---

## Copy-initialization

Before we add anything, let's try what will happen:


<pre><code class="language-cpp">Dynarray a(3);
Dynarray b = a;
</code></pre>


Although it compiles, the pointers `a.m_storage` and `b.m_storage` are pointing to the same address!

This will cause disaster: consider the case if `b` "dies" before `a`:


<pre><code class="language-cpp">Dynarray a(3);
if (some_condition) {
  Dynarray b = a; // `a.m_storage` and `b.m_storage` point to the same memory!
  // ...
} // At this point, dtor of `b` is invoked, which deallocates the memory.
std::cout &lt;&lt; a.at(0); // Invalid memory access!
</code></pre>


---

## Copy constructor

Let `a` be an object of type `Type`. The behaviors of **copy-initialization** (in one of the following forms)


<pre><code class="language-cpp">Type b = a;
Type b(a);
Type b{a};
</code></pre>


are determined by a constructor: **the copy constructor**.

- Note! The `=` in `Type b = a;` **is not an assignment operator**!

---

## Copy constructor

The copy constructor of a class `X` has a parameter of type `const X &`:


<pre><code class="language-cpp">class Dynarray {
 public:
  Dynarray(const Dynarray &amp;other);
};
</code></pre>


Why `const`?

- Logically, it should not modify the object being copied.

Why `&`?

- **Avoid copying.** Pass-by-value is actually **copy-initialization** of the parameter, which will cause infinite recursion here!

---

## Dynarray: copy constructor

What should be the correct behavior of it?


<pre><code class="language-cpp">class Dynarray {
 public:
  Dynarray(const Dynarray &amp;other);
};
</code></pre>


---

## Dynarray: copy constructor

- We want a copy of the content of `other`.


<pre><code class="language-cpp">class Dynarray {
 public:
  Dynarray(const Dynarray &amp;other)
    : m_storage(new int[other.size()]{}), m_length(other.size()) {
    for (std::size_t i = 0; i != other.size(); ++i)
      m_storage[i] = other.at(i);
  }
};
</code></pre>


Now the copy-initialization of `Dynarray` does the correct thing:

- The new object allocates a new block of memory.
- The **contents** are copied, not just the address.

---

## Synthesized copy constructor

If the class does not have a user-declared copy constructor, the compiler will try to synthesize one:

- The synthesized copy constructor will **copy-initialize** all the members, as if

  ```cpp
  class Dynarray {
   public:
    Dynarray(const Dynarray &other)
      : m_storage(other.m_storage), m_length(other.m_length) {}
  };
  ```

- If the synthesized copy constructor does not behave as you expect, **define it on your own!**

---

## Defaulted copy constructor

If the synthesized copy constructor behaves as we expect, we can explicitly require it:


<pre><code class="language-cpp">class Dynarray {
 public:
  Dynarray(const Dynarray &amp;) = default;
  // Explicitly defaulted: Explicitly requires the compiler to synthesize
  // a copy constructor, with default behavior.
};
</code></pre>




---

## Deleted copy constructor

What if we don't want a copy constructor?


<pre><code class="language-cpp">class ComplicatedDevice {
  // some members
  // Suppose this class represents some complicated device, 
  // for which there is no correct and suitable behavior for &quot;copying&quot;.
};
</code></pre>


Simply not defining the copy constructor does not work:

- The compiler will synthesize one for you.

---

## Deleted copy constructor

What if we don't want a copy constructor?


<pre><code class="language-cpp">class ComplicatedDevice {
  // some members
  // Suppose this class represents some complicated device, 
  // for which there is no correct and suitable behavior for &quot;copying&quot;.
 public:
  ComplicatedDevice(const ComplicatedDevice &amp;) = delete;
};
</code></pre>


By saying `= delete`, we define a **deleted** copy constructor:


<pre><code class="language-cpp">ComplicatedDevice a = something();
ComplicatedDevice b = a; // Error: calling deleted function
</code></pre>


---

## Copy-assignment operator

Apart from copy-initialization, there is another form of copying:


<pre><code class="language-cpp">std::string s1 = &quot;hello&quot;, s2 = &quot;world&quot;;
s1 = s2; // s1 becomes a copy of s2, representing &quot;world&quot;
</code></pre>


In `s1 = s2`, `=` is the **assignment operator**.

`=` is the assignment operator **only when it is in an expression.**

- `s1 = s2` is an expression.
- `std::string s1 = s2` is in a **declaration statement**, not an expression. `=` here is a part of the initialization syntax.

---

## Dynarray: copy-assignment operator

The copy-assignent operator is defined in the form of **operator overloading**:

- `a = b` is equivalent to `a.operator=(b)`.
- We will talk about more on operator overloading in a few weeks.


<pre><code class="language-cpp">class Dynarray {
 public:
  Dynarray &amp;operator=(const Dynarray &amp;other);
};
</code></pre>


- The function name is `operator=`.
- In consistent with built-in assignment operators, `operator=` returns **reference to the left-hand side object** (the object being assigned).
  - It is `*this`.

---

## Dynarray: copy-assignment operator

We also want the copy-assignment operator to copy the contents, not only an address.


<pre><code class="language-cpp">class Dynarray {
 public:
  Dynarray &amp;operator=(const Dynarray &amp;other) {
    m_storage = new int[other.size()];
    for (std::size_t i = 0; i != other.size(); ++i)
      m_storage[i] = other.at(i);
    m_length = other.size();
    return *this;
  }
};
</code></pre>


Is this correct?

---

## Dynarray: copy-assignment operator

**Avoid memory leaks! Deallocate the memory you don't use!**


<pre><code class="language-cpp">class Dynarray {
 public:
  Dynarray &amp;operator=(const Dynarray &amp;other) {
    delete[] m_storage; // !!!
    m_storage = new int[other.size()];
    for (std::size_t i = 0; i != other.size(); ++i)
      m_storage[i] = other.at(i);
    m_length = other.size();
    return *this;
  }
};
</code></pre>


Is this correct?

---

## Dynarray: copy-assignment operator

What if **self-assignment** happens?


<pre><code class="language-cpp">class Dynarray {
 public:
  Dynarray &amp;operator=(const Dynarray &amp;other) {
    // If `other` and `*this` are actually the same object,
    // the memory is deallocated and the data are lost! (DISASTER)
    delete[] m_storage;
    m_storage = new int[other.size()];
    for (std::size_t i = 0; i != other.size(); ++i)
      m_storage[i] = other.at(i);
    m_length = other.size();
    return *this;
  }
};
</code></pre>


---

## Dynarray: copy-assignment operator

Assignment operators should be **self-assignment-safe**.


<pre><code class="language-cpp">class Dynarray {
 public:
  Dynarray &amp;operator=(const Dynarray &amp;other) {
    int *new_data = new int[other.size()];
    for (std::size_t i = 0; i != other.size(); ++i)
      new_data[i] = other.at(i);
    delete[] m_storage;
    m_storage = new_data;
    m_length = other.size();
    return *this;
  }
};
</code></pre>


This is self-assignment-safe. (Think about it.)

---

## Synthesized, defaulted and deleted copy-assignment operator

Like the copy constructor:

- The copy-assignment operator can also be **deleted**, by declaring it as `= delete;`.

- If you don't define it, the compiler will generate one that copy-assigns all the members, as if it is defined as:

  ```cpp
  class Dynarray {
   public:
    Dynarray &operator=(const Dynarray &other) {
      m_storage = other.m_storage;
      m_length = other.m_length;
      return *this;
    }
  };
  ```

- You can also require a synthesized one explicitly by saying `= default;`.

---

## [IMPORTANT] The rule of three: Reasoning

Among the **copy constructor**, the **copy-assignment operator** and the **destructor**:

- If a class needs a user-provided version of one of them, **usually**, it needs a user-provided version of **each** of them.
- Why?

---

## [IMPORTANT] The rule of three: Reasoning

Among the **copy constructor**, the **copy-assignment operator** and the **destructor**:

- If a class needs a user-provided version of one of them,
- **usually**, it is a class that **manages some resources**,
- for which **the default behavior of the copy-control members does not suffice**.
- Therefore, all of the three special functions need a user-provided version.
  - Define them in a correct, well-defined manner.
  - If a class should not be copy-constructible or copy-assignable, **delete that function**.

---

## [IMPORTANT] The rule of three: Rules

Let $S=\{$ copy constructor $,$ copy assignment operator $,$ destructor $\}$.

If for a class, $\exists x,y\in S$ such that

- $x$ is user-declared, and $y$ is not user-declared,

then the compiler *should not* generate $y$, according to the idea of "the rule of three".

---

## [IMPORTANT] The rule of three: Rules

Let $S=\{$ copy constructor $,$ copy assignment operator $,$ destructor $\}$.

If for a class, $\exists x,y\in S$ such that

- $x$ is user-declared, and $y$ is not user-declared,

then the compiler **still generates $y$**, but **this behavior has been deprecated since C++11**.

- This is a problem left over from history: At the time C++98 was adopted, the significance of the rule of three was not fully appreciated.

---

## [IMPORTANT] The rule of three

Into modern C++: **The Rule of Five**.

- $\Rightarrow$ We will talk about it in later lectures.

Read *Effective Modern C++* Item 17 for a thorough understanding of this.

---

## Summary

Lifetime of an object:

- depends on its **storage**: local non-`static`, global, allocated, ...
- **Initialization** marks the beginning of the lifetime of an object.
  - Classes can control the way of initialization using **constructors**.
- When the lifetime of an object ends, it is **destroyed**.
  - If it is an object of class type, its **destructor** is called right before it is destroyed.

---

## Summary

Copy control

- Usually, the **copy control members** refer to the copy constructor, the copy assignment operator and the destructor.
- Copy constructor: `ClassName(const ClassName &)`
- Copy assignment operator: `ClassName &operator=(const ClassName &)`
  - It needs to be **self-assignment safe**.
- Destructor: `~ClassName()`
- `=default`, `=delete`
- The rule of three.

# CS100 Lecture 16

Class Basics <span style="color: black; font-family: Times New Roman; font-size: 1.05em;">II</span>

---

## Contents

- Type alias members
- `static` members
- `friend`
- Definition and declaration
- Destructors revisited

---

# Type alias members

---

## Type aliases in C++: `using`.

A better way of declaring type aliases:


<pre><code class="language-cpp">// C-style
typedef long long LL;
// C++-style
using LL = long long;
</code></pre>


It is more readable when dealing with compound types:



<pre><code class="language-cpp">// C-style
typedef int intarray_t[1000];
// C++-style
using intarray_t = int[1000];
</code></pre>




<pre><code class="language-cpp">// C-style
typedef int (&amp;ref_to_array)[1000];
// C++-style
using ref_to_array = int (&amp;)[1000];
</code></pre>


`using` can also declare *alias templates* (in later lectures), while `typedef` cannot.

**[Best practice]** <u>In C++, Use `using` to declare type aliases.</u>

---

## Type alias members

A class can have **type alias members**.


<pre><code class="language-cpp">class Dynarray {
 public:
  using size_type = std::size_t;
  size_type size() const { return m_length; }
};
</code></pre>


Usage: `ClassName::TypeAliasName`


<pre><code class="language-cpp">for (Dynarray::size_type i = 0; i != a.size(); ++i)
  // ...
</code></pre>


Note: Here we use `ClassName::` instead of `object.`, because such members belong to **the class**, not one single object.

---

## Type alias members

The class also has control over the accessibility of type alias members.


<pre><code class="language-cpp">class A {
  using type = int;
};
A::type x = 42; // Error: Accessing private member of `A`.
</code></pre>


The class has control over the accessibility of **anything that is called a *member* of it**.

---

## Type alias members in the standard library

All standard library containers (and `std::string`) define the type alias member `size_type` as the return type of `.size()`:


<pre><code class="language-cpp">std::string::size_type i = s.size();
std::vector&lt;int&gt;::size_type j = v.size(); // Not `std::vector::size_type`!
                                          // The template argument `&lt;int&gt;`
                                          // is necessary here.
std::list&lt;int&gt;::size_type k = l.size();
</code></pre>


Why?

---

## Type alias members in the standard library

All standard library containers (and `std::string`) define the type alias member `size_type` as the return type of `.size()`:


<pre><code class="language-cpp">std::string::size_type i = s.size();
std::vector&lt;int&gt;::size_type j = v.size();
std::list&lt;int&gt;::size_type k = l.size();
</code></pre>


- This type is **container-dependent**: Different containers may choose different types suitable for representing sizes.
  - The Qt containers often use `int` as `size_type`.
- Define `Container::size_type` to achieve good **consistency** and **generality**.

---

# `static` members

---

## `static` data members

A `static` data member:


<pre><code class="language-cpp">class A {
  static int something;
  // other members ...
};
</code></pre>


Just consider it as a **global variable**, except that

- its name is in the **class scope**: `A::something`, and that
- the accessibility may be restricted. Here `something` is `private`.

---

## `static` data members

A `static` data member:


<pre><code class="language-cpp">class A {
  static int something;
  // other members ...
};
</code></pre>


There is **only one** `A::something`: it does not belong to any object of `A`. It belongs to the **class** `A`.

- Like type alias members, we use `ClassName::` instead of `object.` to access them.

---

## `static` data members

A `static` data member:


<pre><code class="language-cpp">class A {
  static int something;
  // other members ...
};
</code></pre>


It can also be accessed by `a.something` (where `a` is an object of type `A`), but `a.something` and `b.something` refer to the same variable.

- If `f` is a function that returns an object of type `A`, `f().something` always accesses the same variable no matter what `f()` returns.
- In the very first externally available C++ compiler (Cfront 1.0, 1985), `f` in the expression `f().something` is not even called! This bug has been fixed soon.

---

## `static` data members: Example

Suppose we want to assign a unique id to each object of our class.


<pre><code class="language-cpp">int cnt = 0;

class Dynarray {
  int *m_storage;
  std::size_t m_length;
  int m_id;
public:
  Dynarray(std::size_t n)
      : m_storage(new int[n]{}), m_length(n), m_id(cnt++) {}
  Dynarray() : m_storage(nullptr), m_length(0), m_id(cnt++) {}
  // ...
};
</code></pre>


We use a global variable `cnt` as the "counter". Is this a good design?

---

## `static` data members: Example

The name `cnt` is confusing: A "counter" of what?



<pre><code class="language-cpp">int X_cnt = 0, Y_cnt = 0, Z_cnt = 0;
struct X {
  int m_id;
  X() : m_id(X_cnt++) {}
};
struct Y {
  int m_id;
  Y() : m_id(Y_cnt++) {}
};
struct Z {
  int m_id;
  Z() : m_id(Z_cnt++) {}
};
</code></pre>



- The program is in a mess with global variables all around.

- No prevention from potential mistakes:

  ```cpp
  struct Y {
    Y() : m_id(X_cnt++) {}
  };
  ```

  The mistake happens silently.

---

## `static` data members: Example

**Restrict the name of this counter in the scope of the corresponding class**, by declaring it as a `static` data member.

- This is exactly the idea behind `static` data members: A "global variable" restricted in class scope.


<pre><code class="language-cpp">class Dynarray {
  static int s_cnt; // !!!
  int *m_storage;
  std::size_t m_length;
  int m_id;

public:
  Dynarray(/* ... */) : /* ... */, m_id(s_cnt++) {}
};
</code></pre>


- `s` stands for `static`.

---

## `static` data members


<pre><code class="language-cpp">class Dynarray {
  static int s_cnt; // !!!
  int *m_storage;
  std::size_t m_length;
  int m_id;

public:
  Dynarray(/* ... */) : /* ... */, m_id(s_cnt++) {}
};
</code></pre>


You also need to give it a definition outside the class, according to some rules.


<pre><code class="language-cpp">int Dynarray::s_cnt; // Zero-initialize, because it is `static`.
</code></pre>


Or initialize it with some value explicitly:


<pre><code class="language-cpp">int Dynarray::s_cnt = 42;
</code></pre>


---

## `static` data members

Exercise: `std::string` has a `find` member function:


<pre><code class="language-cpp">std::string s = something();
auto pos = s.find('a');
if (pos == std::string::npos) { // This means that `'a'` is not found.
  // ...
} else {
  std::cout &lt;&lt; s[pos] &lt;&lt; '\n'; // If executed, it should print `a`.
}
</code></pre>


[`std::string::npos`](https://en.cppreference.com/w/cpp/string/basic_string/npos) is returned when the required character is not found.

Define `npos` and `find` for your `Dynarray` class, whose behavior should be similar to those of `std::string`.

---

## `static` member functions

A `static` member function:


<pre><code class="language-cpp">class A {
 public:
  static void fun(int x, int y);
};
</code></pre>


Just consider it as a normal non-member function, except that

- its name is in the **class scope**: `A::fun(x, y)`, and that
- the accessibility may be restricted. Here `fun` is `public`.

---

## `static` member functions

A `static` member function:


<pre><code class="language-cpp">class A {
 public:
  static void fun(int x, int y);
};
</code></pre>


`A::fun` does not belong to any object of `A`. It belongs to the **class** `A`.

- There is no `this` pointer inside `fun`.

It can also be called by `a.fun(x, y)` (where `a` is an object of type `A`), but here `a` will not be bound to a `this` pointer, and `fun` has no way of accessing any non-`static` member of `a`.

---

# `friend`

---

## `friend` functions

Recall the `Student` class:


<pre><code class="language-cpp">class Student {
  std::string m_name;
  std::string m_id;
  int m_entranceYear;
public:
  Student(const std::string &amp;name, const std::string &amp;id)
      : m_name(name), m_id(id), m_entranceYear(std::stol(id.substr(0, 4))) {}
  auto graduated(int year) const { return year - m_entranceYear &gt;= 4; }
  // ...
};
</code></pre>


Suppose we want to write a function to display the information of a `Student`.

---

## `friend` functions


<pre><code class="language-cpp">void print(const Student &amp;stu) {
  std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; stu.m_name &lt;&lt; &quot;, id: &quot; &lt;&lt; stu.m_id
            &lt;&lt; &quot;entrance year: &quot; &lt;&lt; stu.m_entranceYear &lt;&lt; '\n';
}
</code></pre>


This won't compile, because `m_name`, `m_id` and `m_entranceYear` are `private` members of `Student`.

- One workaround is to define `print` as a member of `Student`.
- However, there do exist some functions that cannot be defined as a member.

---

## `friend` functions

Add a `friend` declaration, so that `print` can access the private members of `Student`.


<pre><code class="language-cpp">class Student {
  friend void print(const Student &amp;); // The parameter name is not used in this
                                      // declaration, so it is omitted.

  std::string m_name;
  std::string m_id;
  int m_entranceYear;
public:
  Student(const std::string &amp;name, const std::string &amp;id)
      : m_name(name), m_id(id), m_entranceYear(std::stol(id.substr(0, 4))) {}
  auto graduated(int year) const { return year - m_entranceYear &gt;= 4; }
  // ...
};
</code></pre>


---

## `friend` functions

Add a `friend` declaration.


<pre><code class="language-cpp">class Student {
  friend void print(const Student &amp;);

  // ...
};
</code></pre>


A `friend` is **not** a member! You can put this `friend` delcaration **anywhere in the class body**. The access modifiers have **no effect** on it.

- We often declare all the `friend`s of a class in the beginning or at the end of class definition.

---

## `friend` classes

A class can also declare another class as its `friend`.


<pre><code class="language-cpp">class X {
  friend class Y;
  // ...
};
</code></pre>


In this way, any code from the class `Y` can access the private members of `X`.

---

# Definition and declaration

---

## Definition and declaration

For a function:


<pre><code class="language-cpp">// Only a declaration: The function body is not present.
void foo(int, const std::string &amp;);
// A definition: The function body is present.
void foo(int x, const std::string &amp;s) {
  // ...
}
</code></pre>


---

## Class definition

For a class, a **definition** consists of **the declarations of all its members**.


<pre><code class="language-cpp">class Widget {
public:
  Widget();
  Widget(int, int);
  void set_handle(int);

  // `const` is also a part of the function type, which should be present
  // in its declaration.
  const std::vector&lt;int&gt; &amp;get_gadgets() const;

  // ...
private:
  int m_handle;
  int m_length;
  std::vector&lt;int&gt; m_gadgets;  
};
</code></pre>


---

## Define a member function outside the class body

A member function can be declared in the class body, and then defined outside.


<pre><code class="language-cpp">class Widget {
public:
  const std::vector&lt;int&gt; &amp;get_gadgets() const; // A declaration only.
  // ...
}; // Now the definition of `Widget` is complete.

// Define the function here. The function name is `Widget::get_gadgets`.
const std::vector&lt;int&gt; &amp;Widget::get_gadgets() const {
  return m_gadgets; // Just like how you do it inside the class body.
                    // The implicit `this` pointer is still there.
}
</code></pre>


---

## The `::` operator


<pre><code class="language-cpp">class Widget {
public:
  using gadgets_list = std::vector&lt;int&gt;;
  static int special_member;
  const gadgets_list &amp;get_gadgets() const;
  // ...
};
const Widget::gadgets_list &amp;Widget::get_gadgets() const {
  return m_gadgets;
}
</code></pre>


- The members `Widget::gadgets_list` and `Widget::special_member` are accessed through `ClassName::`.
- The name of the member function `get_gadgets` is `Widget::get_gadgets`.

---

## Class declaration and incomplete type

To declare a class without providing a definition:


<pre><code class="language-cpp">class A;
struct B;
</code></pre>


If we only see the **declaration** of a class, we have no knowledge about its members, how many bytes it takes, how it can be initialized, ...

- Such class type is an **incomplete type**.
- We cannot create an object of such type, nor can we access any of its members.
- The only thing we can do is to declare a pointer or a reference to it.

---

## Class declaration and incomplete type

If we only see the **declaration** of a class, we have no knowledge about its members, how many bytes it takes, how it can be initialized, ...

- Such class type is an **incomplete type**.
- We cannot create an object of such type, nor can we access any of its members.
- The only thing we can do is to declare a pointer or a reference to it.


<pre><code class="language-cpp">class Student; // We only have this declaration.

void print(const Student &amp;stu) { // OK. Declaring a reference to it is OK.
  std::cout &lt;&lt; stu.getName(); // Error. We don't know anything about its members.
}

class Student {
public:
  const std::string &amp;getName() const { /* ... */ }
  // ...
};
</code></pre>


---

# Destructors revisited

---

## Destructors revisited

A **destructor** (dtor) is a member function that is called automatically when an object of that class type is "dead".

- For global and `static` objects, on termination of the program.
- For local objects, when control reaches the end of its scope.
- For objects created by `new`/`new[]`, when their address is passed to `delete`/`delete[]`.

The destructor is often responsible for doing some **cleanup**: Release the resources it owns, do some logging, cut off its connection with some external objects, ...

---

## Destructors


<pre><code class="language-cpp">class Student {
  std::string m_name;
  std::string m_id;
  int m_entranceYear;
public:
  Student(const std::string &amp;, const std::string &amp;);
  const std::string &amp;getName() const;
  bool graduated(int) const;
  void setName(const std::string &amp;);
  void print() const;
};
</code></pre>


Does our `Student` class have a destructor?

---

## Destructors

Does our `Student` class have a destructor?

- It **must** have. Whenever you create an object of type `Student`, its destructor needs to be invoked somewhere in this program. ${}^{\textcolor{red}{1}}$

What does `Student::~Student` need to do? Does `Student` own any resources?

---

## Destructors

Does our `Student` class have a destructor?

- It **must** have. Whenever you create an object of type `Student`, its destructor needs to be invoked somewhere in this program. ${}^{\textcolor{red}{1}}$

What does `Student::~Student` need to do? Does `Student` own any resources?

- It seems that a `Student` has no resources, so nothing special needs to be done.
- However, it has two `std::string` members! Their destructors must be called, otherwise the memory is leaked!

---

## Destructors

To define the destructor of `Student`: Just write an empty function body, and everything is done.


<pre><code class="language-cpp">class Student {
  std::string m_name;
  std::string m_id;
  int m_entranceYear;
public:
  ~Student() {}
};
</code></pre>


---

## Destructors


<pre><code class="language-cpp">class Student {
  std::string m_name;
  std::string m_id;
  int m_entranceYear;
public:
  ~Student() {}
};
</code></pre>


- When the function body is executed, the object is *not yet* "dead".

  - You can still access its members.

    ```cpp
    ~Student() { std::cout << m_name << '\n'; }
    ```

- After the function body is executed, **all its data members** are destroyed automatically, **in reverse order** in which they are declared.

  - For members of class type, their destructors are invoked automatically.

---

## Constructors vs destructors



<pre><code class="language-cpp">Student(const std::string &amp;name)
    : m_name(name) /* ... */ {
  // ...
}
</code></pre>


- A class may have multiple ctors (overloaded).
- The data members are initialized **before** the execution of function body.
- The data members are initialized **in order** in which they are declared.


<pre><code class="language-cpp">~Student() {
  // ...
}
</code></pre>


- A class has only one dtor. ${}^{\textcolor{red}{1}}$
- The data members are destroyed **after** the execution of function body.
- The data members are destroyed **in reverse order** in which they are declared.

---

## Compiler-generated destructors

For most cases, a class needs a destructor.

Therefore, the compiler always generates one ${}^{\textcolor{red}{2}}$ if there is no user-declared destructor.

- The compiler-generated destructor is `public` by default.
- The compiler-generated destructor is as if it were defined with an empty function body `{}`.
- It does nothing but to destroy the data members.

We can explicitly require one by writing `= default;`, just as for other copy control members.

---

## Summary

Type alias members

- Type alias members belong to the class, not individual objects, so they are accessed via `ClassName::AliasName`.
- The class can controls the accessibility of type alias members.

`static` members

- `static` data members are like global variables, but in the class's scope.
- `static` member functions are like normal non-member functions, but in the class's scope. There is no `this` pointer in a `static` member function.
- A `static` member belongs to the class, instead of any individual object.

---

## Summary

`friend`

- A `friend` declaration allows a function or class to access private (and protected) members of another class.
- A `friend` is not a member.

Definitions and declarations

- A class definition includes declarations of all its members.
- A member function can be declared in the class body and then defined outside.
- A class type is an incomplete type if only its declaration (without a definition) is present.

---

## Summary

Destructors

- Destructors are called automatically when an object's lifetime ends. They often do some clean up.
- The members are destroyed **after** the function body is executed. They are destroyed in reverse order in which they are declared.
- The compiler generates a destructor (in most cases) if none is provided. It just destroys all its members.

# CS100 Lecture 17

Rvalue References and Move

---

## Contents

- Motivation: Copy is slow.
  - Rvalue references
- Move operations
  - Move constructor
  - Move assignment operator
  - The rule of five
- `std::move`
- NRVO, move and copy elision

---

## Motivation: Copy is slow.


<pre><code class="language-cpp">std::string a = some_value(), b = some_other_value();
std::string s;
s = a;
s = a + b;
</code></pre>


Consider the two assignments: `s = a` and `s = a + b`.

How is `s = a + b` evaluated?

---

## Motivation: Copy is slow.


<pre><code class="language-cpp">s = a + b;
</code></pre>


1. Evaluate `a + b` and store the result in a temporary object, say `tmp`.
2. Perform the assignment `s = tmp`.
3. The temporary object `tmp` is no longer needed, hence destroyed by its destructor.

Can we make this faster?

---

## Motivation: Copy is slow.


<pre><code class="language-cpp">s = a + b;
</code></pre>


1. Evaluate `a + b` and store the result in a temporary object, say `tmp`.
2. Perform the assignment `s = tmp`.
3. The temporary object `tmp` is no longer needed, hence destroyed by its destructor.

Can we make this faster?

- The assignment `s = tmp` is done by **copying** the contents of `tmp`?
- But `tmp` is about to "die"! Why can't we just *steal* the contents from it?

---

## Motivation: Copy is slow.

Let's look at the other assignment:


<pre><code class="language-cpp">s = a;
</code></pre>


- **Copy** is necessary here, because `a` lives long. It is not destroyed immediately after this statement is executed.
- You cannot just "steal" the contents from `a`. The contents of `a` must be preserved.

---

## Distinguish between the different kinds of assignments



<pre><code class="language-cpp">s = a;
</code></pre>




<pre><code class="language-cpp">s = a + b;
</code></pre>


What is the key difference between them?

- `s = a` is an assignment from an **lvalue**,
- while `s = a + b` is an assignment from an **rvalue**.

If we only have the copy assignment operator, there is no way of distinguishing them.

**\* Define two different assignment operators, one accepting an lvalue and the other accepting an rvalue?**

---

## Rvalue References

A kind of reference that is bound to **rvalues**:


<pre><code class="language-cpp">int &amp;r = 42;             // Error: Lvalue reference cannot be bound to rvalue.
int &amp;&amp;rr = 42;           // Correct: `rr` is an rvalue reference.
const int &amp;cr = 42;      // Also correct:
                         // Lvalue reference-to-const can be bound to rvalue.
const int &amp;&amp;crr = 42;    // Correct, but useless:
                         // Rvalue reference-to-const is seldom used.

int i = 42;
int &amp;&amp;rr2 = i;           // Error: Rvalue reference cannot be bound to lvalue.
int &amp;r2 = i * 42;        // Error: Lvalue reference cannot be bound to rvalue.
const int &amp;cr2 = i * 42; // Correct
int &amp;&amp;rr3 = i * 42;      // Correct
</code></pre>


- Lvalue references (to non-`const`) can only be bound to lvalues.
- Rvalue references can only be bound to rvalues.

---

## Overload Resolution

Such overloading is allowed:


<pre><code class="language-cpp">void fun(const std::string &amp;);
void fun(std::string &amp;&amp;);
</code></pre>


- `fun(s1 + s2)` matches `fun(std::string &&)`, because `s1 + s2` is an rvalue.
- `fun(s)` matches `fun(const std::string &)`, because `s` is an lvalue.
- Note that if `fun(std::string &&)` does not exist, `fun(s1 + s2)` also matches `fun(const std::string &)`.

We will see how this kind of overloading benefit us soon.

---

# Move Operations

---

## Overview

The **move constructor** and the **move assignment operator**.


<pre><code class="language-cpp">struct Widget {
  Widget(Widget &amp;&amp;) noexcept;
  Widget &amp;operator=(Widget &amp;&amp;) noexcept;
  // Compared to the copy constructor and the copy assignment operator:
  Widget(const Widget &amp;);
  Widget &amp;operator=(const Widget &amp;);
};
</code></pre>


- Parameter type is **rvalue reference**, instead of lvalue reference-to-`const`.
- **`noexcept` is (almost always) necessary!** $\Rightarrow$ We will talk about it in later lectures.

---

## The Move Constructor

Take the `Dynarray` as an example.


<pre><code class="language-cpp">class Dynarray {
  int *m_storage;
  std::size_t m_length;
public:
  Dynarray(const Dynarray &amp;other) // copy constructor
    : m_storage(new int[other.m_length]), m_length(other.m_length) {
    for (std::size_t i = 0; i != m_length; ++i)
      m_storage[i] = other.m_storage[i];
  }
  Dynarray(Dynarray &amp;&amp;other) noexcept // move constructor
    : m_storage(other.m_storage), m_length(other.m_length) {
    other.m_storage = nullptr;
    other.m_length = 0;
  }
};
</code></pre>


---

## The Move Constructor


<pre><code class="language-cpp">class Dynarray {
  int *m_storage;
  std::size_t m_length;
public:
  Dynarray(Dynarray &amp;&amp;other) noexcept // move constructor
    : m_storage(other.m_storage), m_length(other.m_length) {


  }
};
</code></pre>


1. *Steal* the resources of `other`, instead of making a copy.

---

## The Move Constructor


<pre><code class="language-cpp">class Dynarray {
  int *m_storage;
  std::size_t m_length;
public:
  Dynarray(Dynarray &amp;&amp;other) noexcept // move constructor
    : m_storage(other.m_storage), m_length(other.m_length) {
    other.m_storage = nullptr;
    other.m_length = 0;
  }
};
</code></pre>


1. *Steal* the resources of `other`, instead of making a copy.
2. Make sure `other` is in a valid state, so that it can be safely destroyed.

**\* Take ownership of `other`'s resources!**

---

## The Move Assignment Operator

**Take ownership of `other`'s resources!**


<pre><code class="language-cpp">class Dynarray {
public:
  Dynarray &amp;operator=(Dynarray &amp;&amp;other) noexcept {


      m_storage = other.m_storage; m_length = other.m_length;


    return *this;
  }
};
</code></pre>


1. *Steal* the resources from `other`.

---

## The Move Assignment Operator


<pre><code class="language-cpp">class Dynarray {
public:
  Dynarray &amp;operator=(Dynarray &amp;&amp;other) noexcept {


      m_storage = other.m_storage; m_length = other.m_length;
      other.m_storage = nullptr; other.m_length = 0;

    return *this;
  }
};
</code></pre>


1. *Steal* the resources from `other`.
2. Make sure `other` is in a valid state, so that it can be safely destroyed.

Are we done?

---

## The Move Assignment Operator


<pre><code class="language-cpp">class Dynarray {
public:
  Dynarray &amp;operator=(Dynarray &amp;&amp;other) noexcept {

      delete[] m_storage;
      m_storage = other.m_storage; m_length = other.m_length;
      other.m_storage = nullptr; other.m_length = 0;

    return *this;
  }
};
</code></pre>


0. **Avoid memory leaks!**
1. *Steal* the resources from `other`.
2. Make sure `other` is in a valid state, so that it can be safely destroyed.

Are we done?

---

## The Move Assignment Operator


<pre><code class="language-cpp">class Dynarray {
public:
  Dynarray &amp;operator=(Dynarray &amp;&amp;other) noexcept {
    if (this != &amp;other) {
      delete[] m_storage;
      m_storage = other.m_storage; m_length = other.m_length;
      other.m_storage = nullptr; other.m_length = 0;
    }
    return *this;
  }
};
</code></pre>


0. **Avoid memory leaks!**
1. *Steal* the resources from `other`.
2. Make sure `other` is in a valid state, so that it can be safely destroyed.

**\* Self-assignment safe!**

---

## Lvalues are Copied; Rvalues are Moved

Before we move on, let's define a function for demonstration.

Suppose we have a function that concatenates two `Dynarray`s:


<pre><code class="language-cpp">Dynarray concat(const Dynarray &amp;a, const Dynarray &amp;b) {
  Dynarray result(a.size() + b.size());
  for (std::size_t i = 0; i != a.size(); ++i)
    result.at(i) = a.at(i);
  for (std::size_t i = 0; i != b.size(); ++i)
    result.at(a.size() + i) = b.at(i);
  return result;
}
</code></pre>


Which assignment operator should be called?


<pre><code class="language-cpp">a = concat(b, c);
</code></pre>


---

## Lvalues are Copied; Rvalues are Moved

Lvalues are copied; rvalues are moved ...


<pre><code class="language-cpp">a = concat(b, c); // calls move assignment operator,
                  // because `concat(b, c)` is an rvalue.
a = b; // calls copy assignment operator
</code></pre>


---

## Lvalues are Copied; Rvalues are Moved

Lvalues are copied; rvalues are moved ...


<pre><code class="language-cpp">a = concat(b, c); // calls move assignment operator,
                  // because `concat(b, c)` generates an rvalue.
a = b; // copy assignment operator
</code></pre>


... but rvalues are copied if there is no move operation.


<pre><code class="language-cpp">// If Dynarray has no move assignment operator, this is a copy assignment.
a = concat(b, c)
</code></pre>


---

## Synthesized Move Operations

Like copy operations, we can use `=default` to require a synthesized move operation that has the default behaviors.


<pre><code class="language-cpp">struct X {
  X(X &amp;&amp;) = default;
  X &amp;operator=(X &amp;&amp;) = default;
};
</code></pre>


- The synthesized move operations call the corresponding move operations of each member in the order in which they are declared.
- The synthesized move operations are `noexcept`.

Move operations can also be deleted by `=delete`, but be careful ... ${}^{\textcolor{red}{1}}$

---

## The Rule of Five: Idea

The updated *copy control members*:

- <font color="#dd0000">copy constructor</font>
- <font color="#dd0000">copy assignment operator</font>
- <font color="#00dd00">move constructor</font>
- <font color="#00dd00">move assignment operator</font>
- <font color="#0000dd">destructor</font>

If one of them has a user-provided version, the copy control of the class is thought of to have special behaviors. (Recall "the rule of three".)

---

## The Rule of Five: Rules

- The <font color="#00dd00">move constructor</font> or the <font color="#00dd00">move assignment operator</font> will not be generated ${}^{\textcolor{red}{2}}$ if any of the rest four members have a user-declared version.

- The <font color="#dd0000">copy constructor</font> or <font color="#dd0000">copy assignment operator</font>, if not provided by the user, will be implicitly `delete`d if the class has a user-provided <font color="#00dd00">move operation</font>.

- The generation of the <font color="#dd0000">copy constructor</font> or <font color="#dd0000">copy assignment operator</font> is **deprecated** (since C++11) when the class has a user-declared <font color="#dd0000">copy operation</font> or a <font color="#0000dd">destructor</font>.

  - This is why some of you see this error:

    ```
    Implicitly-declared copy assignment operator is deprecated, because the
    class has a user-provided copy constructor.
    ```

---

## The Rule of Five

The *copy control members* in modern C++:

- <font color="#dd0000">copy constructor</font>
- <font color="#dd0000">copy assignment operator</font>
- <font color="#00dd00">move constructor</font>
- <font color="#00dd00">move assignment operator</font>
- <font color="#0000dd">destructor</font>

**The Rule of Five**: Define zero or five of them.

---

## How to Invoke a Move Operation?

Suppose we give our `Dynarray` a label:


<pre><code class="language-cpp">class Dynarray {
  int *m_storage;
  std::size_t m_length;
  std::string m_label;
};
</code></pre>


The move assignment operator should invoke the **move assignment operator** on `m_label`. But how?


<pre><code class="language-cpp">m_label = other.m_label; // calls copy assignment operator,
                         // because `other.m_label` is an lvalue.
</code></pre>


---

# `std::move`

---

## `std::move`

Defined in `<utility>`

`std::move(x)` performs an **lvalue to rvalue cast**:


<pre><code class="language-cpp">int ival = 42;
int &amp;&amp;rref = ival; // Error
int &amp;&amp;rref2 = std::move(ival); // Correct
</code></pre>


Calling `std::move(x)` tells the compiler that:

- `x` is an lvalue, but
- we want to treat `x` as an **rvalue**.

---

## `std::move`

`std::move(x)` indicates that we want to treat `x` as an **rvalue**, which means that `x` will be *moved from*.

The call to `std::move` **promises** that we do not intend to use `x` again,

- except to assign to it or to destroy it.

A call to `std::move` is usually followed by a call to some function that moves the object, after which **we cannot make any assumptions about the value of the moved-from object.**


<pre><code class="language-cpp">void foo(X &amp;&amp;x);      // moves `x`
void foo(const X &amp;x); // copies `x`
foo(std::move(x)); // matches `foo(X&amp;&amp;)`, so that `x` is moved.
</code></pre>


"`std::move` does not *move* anything. It just makes a *promise*."

---

## Use `std::move`

Suppose we give every `Dynarray` a special "label", which is a string.


<pre><code class="language-cpp">class Dynarray {
  int *m_storage;
  std::size_t m_length;
  std::string m_label;
public:
  Dynarray(Dynarray &amp;&amp;other) noexcept
      : m_storage(other.m_storage), m_length(other.m_length),
        m_label(std::move(other.m_label)) { // !!
    other.m_storage = nullptr;
    other.m_length = 0;
  }
};
</code></pre>


The standard library facilities ought to define efficient and correct move operations.

---

## Use `std::move`

Suppose we give every `Dynarray` a special "label", which is a string.


<pre><code class="language-cpp">class Dynarray {
  int *m_storage;
  std::size_t m_length;
  std::string m_label;
public:
  Dynarray &amp;operator=(Dynarray &amp;&amp;other) noexcept {
    if (this != &amp;other) {
      delete[] m_storage;
      m_storage = other.m_storage; m_length = other.m_length;
      m_label = std::move(other.m_label);
      other.m_storage = nullptr; other.m_length = 0;
    }
    return *this;
  }
};
</code></pre>


The standard library facilities ought to define efficient and correct move operations.

---

## Use `std::move`

Why do we need `std::move`?


<pre><code class="language-cpp">class Dynarray {
public:
  Dynarray(Dynarray &amp;&amp;other) noexcept
      : m_storage(other.m_storage), m_length(other.m_length),
        m_label(other.m_label) { // Isn't this correct?
    other.m_storage = nullptr;
    other.m_length = 0;
  }
};
</code></pre>


`other` is an rvalue reference, so ... ?

---

## An rvalue reference is an lvalue.

`other` is an rvalue reference, **which is an lvalue**.

- To move the object that the rvalue reference is bound to, we must call `std::move`.


<pre><code class="language-cpp">class Dynarray {
public:
  Dynarray(Dynarray &amp;&amp;other) noexcept
      : m_storage(other.m_storage), m_length(other.m_length),
        m_label(other.m_label) { // `other.m_label` is copied, not moved.
    other.m_storage = nullptr;
    other.m_length = 0;
  }
};
</code></pre>


An rvalue reference is an lvalue! Does that make sense?

---

## Lvalues persist; Rvalues are ephemeral.

The lifetime of rvalues is often very short, compared to that of lvalues.

- Lvalues have persistent state, whereas rvalues are either **literals** or **temporary objects** created in the course of evaluating expressions.

An rvalue reference **extends** the lifetime of the rvalue that it is bound to.


<pre><code class="language-cpp">std::string s1 = something(), s2 = some_other_thing();
std::string &amp;&amp;rr = s1 + s2; // The state of the temporary object is &quot;captured&quot;
                            // by the rvalue reference, without which the
                            // temporary object will be destroyed.
std::cout &lt;&lt; rr &lt;&lt; '\n'; // Now we can use `rr` just like a normal string.
</code></pre>


Golden rule: **Anything that has a name is an lvalue.**

- The rvalue reference has a name, so it is an lvalue.

---

# NRVO, Move and Copy Elision

---

## Returning a Temporary (pure rvalue)


<pre><code class="language-cpp">std::string foo(const std::string &amp;a, const std::string &amp;b) {
  return a + b; // a temporary
}
std::string s = foo(a, b);
</code></pre>


- First, a temporary is generated to store the result of `a + b`.
- How is this temporary returned?

---

## Returning a Temporary (pure rvalue)


<pre><code class="language-cpp">std::string foo(const std::string &amp;a, const std::string &amp;b) {
  return a + b; // a temporary
}
std::string s = foo(a, b);
</code></pre>


Since C++17, **no copy or move** is made here. The initialization of `s` is the same as


<pre><code class="language-cpp">std::string s(a + b);
</code></pre>


This is called **copy elision**.

---

## Returning a Named Object


<pre><code class="language-cpp">Dynarray concat(const Dynarray &amp;a, const Dynarray &amp;b) {
  Dynarray result(a.size() + b.size());
  for (std::size_t i = 0; i != a.size(); ++i)
    result.at(i) = a.at(i);
  for (std::size_t i = 0; i != b.size(); ++i)
    result.at(a.size() + i) = b.at(i);
  return result;
}
a = concat(b, c);
</code></pre>


- `result` is a local object of `concat`.
- Since C++11, `return result` performs a **move initialization** of a temporary object, say `tmp`.
- Then a **move assignment** to `a` is performed.

---

## Named Return Value Optimization, NRVO


<pre><code class="language-cpp">Dynarray concat(const Dynarray &amp;a, const Dynarray &amp;b) {
  Dynarray result(a.size() + b.size());
  // ...
  return result;
}
Dynarray a = concat(b, c); // Initialization
</code></pre>


NRVO transforms this code to


<pre><code class="language-cpp">// Pseudo C++ code.
void concat(Dynarray &amp;result, const Dynarray &amp;a, const Dynarray &amp;b) {
  // Pseudo C++ code. For demonstration only.
  result.Dynarray::Dynarray(a.size() + b.size()); // construct in-place
  // ...
}
Dynarray a@; // Uninitialized.
concat(a@, b, c);
</code></pre>


so that no copy or move is needed.

---

## Named Return Value Optimization, NRVO

Note:

- NRVO was invented decades ago (even before C++98).
- NRVO is an **optimization**, but not mandatory.
- Even if NRVO is performed, the move constructor should still be available.
  - Because the compiler can choose not to perform NRVO.
  - The program should be syntactically correct ("well-formed"), no matter how the compiler treats it.

---

## Summary

Rvalue references

- are bound to rvalues, and extends the lifetime of the rvalue.
- Functions accepting `X &&` and `const X &` can be overloaded.
- An rvalue reference is an lvalue.

Move operations

- take ownership of resources from the other object.
- After a move operation, the moved-from object should be in a valid state that can be safely assigned to or destroyed.
- `=default`
- The rule of five: Define zero or five of the special member functions.

---

## Summary

`std::move`

- does not move anything. It only performs an lvalue-to-rvalue cast.
- `std::move(x)` makes a promise that `x` can be safely moved from.

In modern C++, unnecessary copies are greatly avoided by:

- copy-elision, which avoids the move or copy of temporary objects, and
- move, with the `return`ed lvalue treated as an rvalue, and
- NRVO, which constructs in-place the object to be initialized.

# CS100 Lecture 18

Smart Pointers

---

## Contents

- Ideas
- `std::unique_ptr`
- `std::shared_ptr`

---

# Ideas

---

## Memory management is difficult!

For raw pointers obtained from `new` / `new[]` expressions, a manual `delete` / `delete[]` is required.


<pre><code class="language-cpp">void runGame(const std::vector&lt;Option&gt; &amp;options, const Settings &amp;settings) {
  auto pWindow = new Window(settings.width, settings.height, settings.mode);
  auto pGame = new Game(options, settings, pWindow);
  // Run the game ...
  while (true) {
    auto key = getUserKeyAction();
    // ...
  }
  delete pGame;   // You must not forget this.
  delete pWindow; // You must not forget this.
}
</code></pre>


Will you always remember to `delete`?

---

## Will you always remember to `delete`?


<pre><code class="language-cpp">void runGame(const std::vector&lt;Option&gt; &amp;options, const Settings &amp;settings) {
  auto pWindow = new Window(settings.width, settings.height, settings.mode);
  auto pGame = new Game(options, settings, pWindow);
  if (/* condition1 */) {
    // ...
    return; // `pWindow` and `pGame` should also be `delete`d here!
  }
  // Run the game ...
  while (true) {
    auto key = getUserKeyAction();
    // ...
    if (/* condition2 */) {
      // ...
      return; // `pWindow` and `pGame` should also be `delete`d here!
    }
  }
  delete pGame;
  delete pWindow;
}
</code></pre>


---

## Idea: Make use of destructors.


<pre><code class="language-cpp">struct WindowPtr { // A &quot;smart pointer&quot;.
  Window *ptr;
  WindowPtr(Window *p) : ptr(p) {}
  ~WindowPtr() { delete ptr; } // The destructor will `delete` the object.
};
</code></pre>


When the control reaches the end of the scope in which the `WindowPtr` lives, the destructor of `WindowPtr` will be called automatically.


<pre><code class="language-cpp">void runGame(const std::vector&lt;Option&gt; &amp;options, const Settings &amp;settings) {
  WindowPtr pWindow(new Window(settings.width, settings.height, settings.mode));
  if (/* condition1 */) {
    // ...
    return; // `pWindow` is destroyed automatically, with its destructor called.
  }
  // ...
  // `pWindow` is destroyed automatically, with its destructor called.
}
</code></pre>


---

## What if `WindowPtr` is copied?

Now `WindowPtr` only has a compiler-generated copy constructor, which copies the value of `ptr`.


<pre><code class="language-cpp">{
  WindowPtr pWindow(new Window(settings.width, settings.height, settings.mode));
  auto copy = pWindow; // `copy.ptr` and `pWindow.ptr` point to the same object!
} // The object is deleted twice! Disaster!
</code></pre>


What should be the behavior of `auto copy = pWindow;`? Possible designs are:

1. Copy the object, as if `WindowPtr copy(new Window(*pWindow.ptr));`.
2. Copy the pointer, as if `WindowPtr copy(pWindow.ptr);`.
   - To avoid disasters caused by multiple `delete`s, some special design is needed.
3. Disable it. If there is no unique reasonable design, disable that operation.

---

## What if `WindowPtr` is copied?

What should be the behavior of `auto copy = pWindow;`? Possible designs are:

1. Copy the object, as if `WindowPtr copy(new Window(*pWindow.ptr));`.
   - **"Value semantics"**
   - Typical example: Standard library containers. When you copy a `std::string`, a new string is created, with the **contents** copied.
   - May be referred to as "deep copy" in some other languages.
2. Copy the pointer, as if `WindowPtr copy(pWindow.ptr);`.
   - To avoid disasters caused by multiple `delete`s, some special design is needed.
   - **"Pointer semantics"**, or **"Reference semantics"**
   - "shallow copy" in some other languages.
3. Disable it. If there is no unique reasonable design, disable that operation.
   - In this case, `pWindow` **exclusively owns** the `Window` object.

---

## Overview of smart pointers

A "smart pointer" is a pointer that manages its resources.

Possible behaviors of copy of a smart pointer:

1. Copy the object. (Value semantics)
   - **Standard library containers.** e.g. `std::string`, `std::vector`, `std::set`, ...
2. Copy the pointer, but with some special design. (Pointer semantics)
   - **`std::shared_ptr<T>`.** Defined in standard library file `<memory>`.
3. Disable it. (Unique ownership)
   - **`std::unique_ptr<T>`.** Defined in standard library file `<memory>`.

The smart pointers `std::shared_ptr<T>`, `std::unique_ptr<T>` and `std::weak_ptr<T>` are **the C++'s answer to garbage collection**.

- `std::weak_ptr` is not covered in CS100.

---

## Overview of smart pointers

The smart pointers `std::shared_ptr<T>`, `std::unique_ptr<T>` and `std::weak_ptr<T>` are **the C++'s answer to garbage collection**.

Smart pointers support the similar operations as raw pointers:

- `*sp` returns reference to the pointed-to object.
- `sp->mem` is equivalent to `(*sp).mem`.
- `sp` is *contextually convertible* to `bool`: It can be treated as a "condition".
  - It can be placed at the "condition" part of `if`, `for`, `while`, `do` statements.
  - It can be used as operands of `&&`, `||`, `!` or the first operand of `?:`.
  - In all cases, the conversion result is `true` **iff** `sp` holds an object (not "null").

**[Best practice]** <u>In modern C++, prefer smart pointers to raw pointers.</u>

---

# `std::unique_ptr`

---

## Design: Unique ownership of the object

A "unique-pointer" saves a raw pointer internally, pointing to the object it owns.

When the unique-pointer is destroyed, it disposes of the object it owns.


<pre><code class="language-cpp">class WindowPtr {
  Window *ptr;
public:
  WindowPtr(Window *p = nullptr) : ptr(p) {}
  ~WindowPtr() { delete ptr; }
  WindowPtr(const WindowPtr &amp;) = delete;
  WindowPtr &amp;operator=(const WindowPtr &amp;) = delete;
  WindowPtr(WindowPtr &amp;&amp;other) noexcept : ptr(other.ptr) { other.ptr = nullptr; }
  WindowPtr &amp;operator=(WindowPtr &amp;&amp;other) noexcept {
    if (&amp;other != this) {
      delete ptr; ptr = other.ptr; other.ptr = nullptr;
    }
    return *this;
  }
};
</code></pre>


**Move** of a unique-pointer: **transfer of ownership**.

- **Move-only type**

---

## `std::unique_ptr`

Like `std::vector`, `std::unique_ptr` is also a class template. It is not a type itself.

- `std::unique_ptr<PointeeType>` is the complete type name, where `PointeeType` is the type of the object that it points to.
- For `T` $\neq$ `U`, `std::unique_ptr<T>` and `std::unique_ptr<U>` are **two different and independent types**.

Same for `std::shared_ptr`, which we will talk about later.

---

## Creating a `std::unique_ptr`: Two common ways

- Pass a pointer created by `new` to the constructor:

  ```cpp
  std::unique_ptr<Student> p(new Student("Bob", 2020123123));
  ```

  - Here `<Student>` can be omitted. The compiler is able to deduce it.

- Use `std::make_unique<T>`, and pass the initializers to it.

  ```cpp
  std::unique_ptr<Student> p1 = std::make_unique<Student>("Bob", 2020123123);
  auto p2 = std::make_unique<Student>("Alice", 2020321321);
  ```

  - `std::make_unique<T>(args...)` *perfectly forwards* the arguments `args...` to the constructor of `T`, as if the object were created by `new T(args...)`.
  - `std::make_unique<T>` returns a `std::unique_ptr<T>` to the created object.

---

## Default initialization of a `std::unique_ptr`


<pre><code class="language-cpp">std::unique_ptr&lt;T&gt; up;
</code></pre>


The default constructor of `std::unique_ptr<T>` initializes `up` to be a "null pointer".

`up` is in the state that does not own any object.

- This is a defined and deterministic behavior! It is **not** holding some indeterminate value.
  - The standard library hates indeterminate values, just as we do.

---

## `std::unique_ptr`: Automatic memory management


<pre><code class="language-cpp">void foo() {
  auto pAlice = std::make_unique&lt;Student&gt;(&quot;Alice&quot;, 2020321321);
  // Do something...
  if (some_condition()) {
    auto pBob = std::make_unique&lt;Studnet&gt;(&quot;Bob&quot;, 2020123123);
    // ...
  } // `Student::~Student()` is called for Bob,
    // because the lifetime of `pBob` ends.
} // `Student::~Student()` is called for Alice,
  // because the lifetime of `pAlice` ends.
</code></pre>


A `std::unique_ptr` automatically calls the destructor once it gets destroyed or assigned a new value.

- No manual `delete` needed!

---

## `std::unique_ptr`: Move-only


<pre><code class="language-cpp">auto p = std::make_unique&lt;std::string&gt;(5, 'c');
std::cout &lt;&lt; *p &lt;&lt; std::endl;                  // Prints &quot;ccccc&quot;.
auto q = p;                                    // Error. Copy is not allowed.
auto r = std::move(p);                         // Correct.
// Now the ownership of this string has been transferred to `r`.
std::cout &lt;&lt; *r &lt;&lt; std::endl; // Prints &quot;ccccc&quot;.
if (!p) // true
  std::cout &lt;&lt; &quot;p is \&quot;null\&quot; now.&quot; &lt;&lt; std::endl;
</code></pre>


`std::unique_ptr` is not copyable, but only movable.

- Remember, only one `std::unique_ptr` can point to the managed object.
- Move of a `std::unique_ptr` is the transfer of ownership of the managed object.

---

## `std::unique_ptr`: Move-only


<pre><code class="language-cpp">auto p = std::make_unique&lt;std::string&gt;(5, 'c');
std::cout &lt;&lt; *p &lt;&lt; std::endl;                  // Prints &quot;ccccc&quot;.
auto q = p;                                    // Error. Copy is not allowed.
auto r = std::move(p);                         // Correct.
// Now the ownership of this string has been transferred to `r`.
std::cout &lt;&lt; *r &lt;&lt; std::endl; // Prints &quot;ccccc&quot;.
if (!p) // true
  std::cout &lt;&lt; &quot;p is \&quot;null\&quot; now.&quot; &lt;&lt; std::endl;
</code></pre>


After `auto up2 = std::move(up1);`, `up1` becomes "null". The object that `up1` used to manage now belongs to `up2`.

The assignment `up2 = std::move(up1)` destroys the object that `up2` used to manage, and lets `up2` take over the object managed by `up1`. After that, `up1` becomes "null".

---

## Express your intent precisely.

You may accidentally write the following code:


<pre><code class="language-cpp">// Given that `pWindow` is a `std::unique_ptr&lt;Window&gt;`.
auto p = pWindow; // Oops, attempting to copy a `std::unique_ptr`.
</code></pre>


The compiler gives an error, complaining about the use of deleted copy constructor.

What are you going to do?

A. Change it to `auto p = std::move(pWindow);`.
B. Give up on smart pointers, and switch back to raw pointers.
C. Copy-and-paste the compiler output and ask ChatGPT.

---

## Express your intent precisely.

You may accidentally write the following code:


<pre><code class="language-cpp">// Given that `pWindow` is a `std::unique_ptr&lt;Window&gt;`.
auto p = pWindow; // Oops, attempting to copy a `std::unique_ptr`.
</code></pre>


The compiler gives an error, complaining about the use of deleted copy constructor.

1. Syntactically, a `std::unique_ptr` is not copyable, but you are copying it. **(Direct cause of the error)**
2. Logically, a `std::unique_ptr` must exclusively manage the pointed-to object. Why would you copy a `std::unique_ptr`?
   - The **root cause of the error** is related to your intent: What are you going to do with `p`?

---

## Express your intent precisely.


<pre><code class="language-cpp">// Given that `pWindow` is a `std::unique_ptr&lt;Window&gt;`.
auto p = pWindow; // Oops, attempting to copy a `std::unique_ptr`.
</code></pre>


What are you going to do with `p`?

- If you want to copy the pointed-to object, change it to `auto p = std::make_unique<Window>(*pWindow);`.
- If you want `p` to be just an ***observer***, write `auto p = pWindow.get();`.
  - `pWindow.get()` returns a **raw pointer** to the object, which is of type `Window *`.
  - Be careful! As an observer, `p` should never interfere in the lifetime of the object. A simple `delete p;` will cause disaster.

---

## Express your intent precisely.


<pre><code class="language-cpp">// Given that `pWindow` is a `std::unique_ptr&lt;Window&gt;`.
auto p = pWindow; // Oops, attempting to copy a `std::unique_ptr`.
</code></pre>


What are you going to do with `p`?

- If you want `p` to take over the object managed by `pWindow`, change it to `auto p = std::move(pWindow);`.
  - Be careful! `pWindow` will no longer own that object.
- If you want to `p` to be another smart pointer that ***shares*** the ownership with `pWindow`, `std::unique_ptr` is not suitable here. $\Rightarrow$ See `std::shared_ptr` later.

---

## Returning a `std::unique_ptr`


<pre><code class="language-cpp">struct Window {
  // A typical &quot;factory&quot; function.
  static std::unique_ptr&lt;Window&gt; create(const Settings &amp;settings) {
    auto pW = std::make_unique&lt;Window&gt;(/* some arguments */);
    logWindowCreation(pW);
    // ...
    return pW;
  }
};
auto state = Window::create(my_settings);
</code></pre>


A temporary is move-constructed from `pW`, and then is used to move-construct `state`.

- These two moves can be optimized out by NRVO.

---

## Other operations on `std::unique_ptr`

`up.reset()`, `up.release()`, `up1.swap(up2)`, `up1 == up2`, etc.

[Full list](https://en.cppreference.com/w/cpp/memory/unique_ptr) of operations supported on a `std::unique_ptr`.

---

## `std::unique_ptr` for array type

By default, the destructor of `std::unique_ptr<T>` uses a `delete` expression to destroy the object it holds.

What happens if `std::unique_ptr<T> up(new T[n]);`?

---

## `std::unique_ptr` for array type

By default, the destructor of `std::unique_ptr<T>` uses a `delete` expression to destroy the object it holds.

What happens if `std::unique_ptr<T> up(new T[n]);`?

- The memory is obtained using `new[]`, but deallocated by `delete`! **Undefined behavior.**

---

## `std::unique_ptr` for array type

A *template specialization*: `std::unique_ptr<T[]>`.

- Specially designed to represent pointers that point to a "dynamic array" of objects.
- It has some array-specific operators, e.g. `operator[]`. In contrast, it does not support `operator*` and `operator->`.
- It uses `delete[]` instead of `delete` to destroy the objects.


<pre><code class="language-cpp">auto up = std::make_unique&lt;int[]&gt;(n);
std::unique_ptr&lt;int[]&gt; up2(new int[n]{}); // equivalent
for (auto i = 0; i != n; ++i)
  std::cout &lt;&lt; up[i] &lt;&lt; ' ';
</code></pre>


---

## ~~`std::unique_ptr` for array type~~

~~A *template specialization*: `std::unique_ptr<T[]>`.~~

~~- Specially designed to represent pointers that point to a "dynamic array" of objects.~~
~~- It has some array-specific operators, e.g. `operator[]`. In contrast, it does not support `operator*` and `operator->`.~~
~~- It uses `delete[]` instead of `delete` to destroy the objects.~~

## Use standard library containers instead!

They almost always do a better job. `std::unique_ptr<T[]>` is seldom needed.

---

## `std::unique_ptr` is zero-overhead.

`std::unique_ptr` stores nothing more than a raw pointer. ${}^{\textcolor{red}{1}}$

It does nothing more than better copy / move control and automatic object destruction.

**Zero-overhead**: Using a `std::unique_ptr` does not cost more time or space than using raw pointers.

**[Best practice]** <u>Use `std::unique_ptr` for exclusive-ownership resource management.</u>

---

# `std::shared_ptr` 

---

## Motivation

A `std::unique_ptr` exclusively owns an object, but sometimes this is not convenient.


<pre><code class="language-cpp">struct WindowManager {
  void addWindow(const std::unique_ptr&lt;Window&gt; &amp;pW) {
    mWindows.push_back(pW); // Error. Attempts to copy a `std::unique_ptr`.
  }
private:
  std::vector&lt;std::unique_ptr&lt;Window&gt;&gt; mWindows;
};

struct Window {
  static std::unique_ptr&lt;Window&gt; create(const Settings &amp;settings) {
    auto pW = std::make_unique&lt;Window&gt;(/* some arguments */);
    logWindowCreation(pW);
    settings.getWindowManager().addWindow(pW);
    return pW;
  }
};
</code></pre>


---

## Motivation

Design a "shared-pointer" that allows the object it manages to be ***shared***.

When should the object be destroyed?

- A `std::unique_ptr` destroys the object it manages when the pointer itself is destroyed.
- If we allow many shared-pointers to point to the same object, how can we know when to destroy that object?

---

## Idea: Reference counting


<pre><code class="language-cpp">class WindowPtr {
  WindowWithCounter *ptr;
public:
  WindowPtr(WindowPtr &amp;&amp;other) noexcept : ptr(other.ptr) { other.ptr = nullptr; }
  WindowPtr &amp;operator=(WindowPtr &amp;&amp;other) noexcept {
    if (this != &amp;other) {
      if (--ptr-&gt;refCount == 0)
        delete ptr;
      ptr = other.ptr; other.ptr = nullptr;
    }
    return *this;
  }
};
</code></pre>


---

## Reference counting

By maintaining a variable that counts how many shared-pointers are pointing to the object, we can know when to destroy the object.

This strategy is adopted by Python.

It can prevent memory leak in many cases, but not all cases! $\Rightarrow$ See the question in the end of this lecture's slides.

---

## `std::shared_ptr`

A smart pointer that uses **reference counting** to manage shared objects.

Create a `shared_ptr`:


<pre><code class="language-cpp">std::shared_ptr&lt;Type&gt; sp2(new Type(args));
auto sp = std::make_shared&lt;Type&gt;(args); // equivalent, but better
</code></pre>


For example:


<pre><code class="language-cpp">// sp points to a string &quot;cccccccccc&quot;.
auto sp = std::make_shared&lt;std::string&gt;(10, 'c');

auto pWindow = std::make_shared&lt;Window&gt;(80, 24, my_settings.mode);
</code></pre>


---

## Create a `shared_ptr`

Note: For `std::unique_ptr`, both of the following ways are ok (since C++17):


<pre><code class="language-cpp">auto up = std::make_unique&lt;Type&gt;(args);
std::unique_ptr&lt;Type&gt; up2(new Type(args));
</code></pre>


For `std::shared_ptr`, **`std::make_shared` is preferable to directly using `new`**.


<pre><code class="language-cpp">auto sp = std::make_shared&lt;Type&gt;(args);    // preferred
std::shared_ptr&lt;Type&gt; sp2(new Type(args)); // ok, but less preferred
</code></pre>


Read *Effective Modern C++* Item 21. (Note that this book is based on C++14.)

**[Best practice]** <u>Prefer `std::make_shared` to directly using `new` when creating a `std::shared_ptr`.</u>

---

## Operations

`*` and `->` can be used as if it is a raw pointer:


<pre><code class="language-cpp">auto sp = std::make_shared&lt;std::string&gt;(10, 'c');
std::cout &lt;&lt; *sp &lt;&lt; std::endl;        // &quot;cccccccccc&quot;
std::cout &lt;&lt; sp-&gt;size() &lt;&lt; std::endl; // &quot;10&quot;
</code></pre>


`sp.use_count()`: The value of the reference counter.


<pre><code class="language-cpp">auto sp = std::make_shared&lt;std::string&gt;(10, 'c');
{
  auto sp2 = sp;
  std::cout &lt;&lt; sp.use_count() &lt;&lt; std::endl; // 2
} // `sp2` is destroyed, but the managed object is not destroyed.
std::cout &lt;&lt; sp.use_count() &lt;&lt; std::endl;   // 1
</code></pre>


---

## Operations

[Full list of supported operations on `std::shared_ptr`.](https://en.cppreference.com/w/cpp/memory/shared_ptr)

`std::shared_ptr` is relatively easy to use, since you are free to create many `std::shared_ptr`s pointing to one object.

However, `std::shared_ptr` **has time and space overhead**. Copy of a `std::shared_ptr` requires maintenance of reference counter.

---

## Summary

`std::unique_ptr`

- Exclusive-ownership.
- Move-only. Move is the transfer of ownership.
- Zero-overhead.

`std::shared_ptr`

- Shared-ownership.
- Uses reference counting.
  - Copy increments the reference counter.
  - When the counter is decremented to zero, the object is destroyed.

---

## Question

Does `std::shared_ptr` prevent memory leak in all cases? Think about what happens in the following code.


<pre><code class="language-cpp">struct Node {
  int value;
  std::shared_ptr&lt;Node&gt; next;
  Node(int x, std::shared_ptr&lt;Node&gt; p) : value{x}, next{std::move(p)} {}
};
void foo() {
  auto p = std::make_shared&lt;Node&gt;(1, nullptr);
  p-&gt;next = std::make_shared&lt;Node&gt;(2, p);
  p.reset();
}
/*
这段代码中确实存在内存泄漏的问题。问题在于foo函数中创建的std::shared_ptr&lt;Node&gt;对象p和p-&gt;next。
p是一个std::shared_ptr&lt;Node&gt;，它指向一个Node对象，该对象的value是1，并且next指针是nullptr。
然后，p-&gt;next被赋值为一个新的std::shared_ptr&lt;Node&gt;，这个新的Node对象的value是2，并且它的next指针指向p（即第一个节点）。
这里，第一个节点的shared_ptr引用计数是1，因为只有p指向它。
第二个节点的shared_ptr引用计数也是1，因为它是独立创建的。
当执行p.reset()时，p所指向的节点的引用计数减1，变为0，因此第一个节点会被销毁。
但是，第二个节点的shared_ptr引用计数还是1，因为它的shared_ptr是通过p-&gt;next间接引用的，并没有直接通过p.reset()释放。所以第二个节点不会被销毁，导致内存泄漏。
*/
</code></pre>


# CS100 Lecture 19

Operator Overloading

---

## Contents

- Basics
- Example: `Rational`
  - Arithmetic and relational operators
  - Increment and decrement operators (`++`, `--`)
  - IO operators (`<<`, `>>`)
- Example: `Dynarray`
  - Subscript operator (`[]`)
- Example: `WindowPtr`
  - Dereference (indirection) operator (`*`)
  - Member access through pointer (`->`)
- User-defined type conversions

---

## Basics

Operator overloading: Provide the behaviors of **operators** for class types.

We have already seen some:

- The **copy assignment operator** and the **move assignment operator** are two special overloads for `operator=`.
- The IOStream library provides overloaded `operator<<` and `operator>>` to perform input and output.
- The string library provides `operator+` for concatenation of strings, and `<`, `<=`, `>`, `>=`, `==`, `!=` for comparison in lexicographical order.
- Standard library containers and `std::string` have `operator[]`.
- Smart pointers have `operator*` and `operator->`.

---

## Basics

Overloaded operators can be defined in two forms:

- as a member function, in which the leftmost operand is bound to `this`:

  - `a[i]` $\Leftrightarrow$ `a.operator[](i)`
  - `a = b` $\Leftrightarrow$ `a.operator=(b)`
  - `*a` $\Leftrightarrow$ `a.operator*()`
  - `f(arg1, arg2, arg3, ...)` $\Leftrightarrow$ `f.operator()(arg1, arg2, arg3, ...)`

- as a non-member function:

  - `a == b` $\Leftrightarrow$ `operator==(a, b)`
  - `a + b` $\Leftrightarrow$ `operator+(a, b)`

---

## Basics

Some operators cannot be overloaded:

`obj.mem`, `::`, `?:`, `obj.*memptr` (not covered in CS100)

Some operators can be overloaded, but are strongly not recommended:

`cond1 && cond2`, `cond1 || cond2`

- Reason: Since `x && y` would become `operator&&(x, y)`, there is no way to overload `&&` (or `||`) that preserves the **short-circuit evaluation** property.

---

## Basics

- At least one operand should be a class type. Modifying the behavior of operators on built-in types is not allowed.

  ```cpp
  int operator+(int, int);   // Error.
  MyInt operator-(int, int); // Still error.
  ```

- Inventing new operators is not allowed.

  ```cpp
  double operator**(double x, double exp); // Error.
  ```

- Overloading does not modify the **associativity**, **precedence** and the **operands' evaluation order**.

  ```cpp
  std::cout << a + b; // Equivalent to `std::cout << (a + b)`.
  ```

---

# Example: `Rational`

---

## A class for rational numbers


<pre><code class="language-cpp">class Rational {
  int m_num;        // numerator
  unsigned m_denom; // denominator
  void simplify() { // Private, because this is our implementation detail.
    int gcd = std::gcd(m_num, m_denom); // std::gcd in &lt;numeric&gt; (since C++17)
    m_num /= gcd; m_denom /= gcd;
  }
public:
  Rational(int x = 0) : m_num{x}, m_denom{1} {} // Also a default constructor.
  Rational(int num, unsigned denom) : m_num{num}, m_denom{denom} { simplify(); }
  double to_double() const {
    return static_cast&lt;double&gt;(m_num) / m_denom;
  }
};
</code></pre>


We want to have arithmetic operators supported for `Rational`.

---

## `Rational`: arithmetic operators

A good way: define `operator+=` and the **unary** `operator-`, and then define other operators in terms of them.


<pre><code class="language-cpp">class Rational {
  friend Rational operator-(const Rational &amp;); // Unary `operator-` as in `-x`.
public:
  Rational &amp;operator+=(const Rational &amp;rhs) {
    m_num = m_num * static_cast&lt;int&gt;(rhs.m_denom) // Be careful with `unsigned`!
            + static_cast&lt;int&gt;(m_denom) * rhs.m_num;
    m_denom *= rhs.m_denom;
    simplify();
    return *this; // `x += y` should return a reference to `x`.
  }
};
Rational operator-(const Rational &amp;x) {
  return {-x.m_num, x.m_denom};
  // The above is equivalent to `return Rational(-x.m_num, x.m_denom);`.
}
</code></pre>


---

## `Rational`: arithmetic operators

Define the arithmetic operators in terms of the compound assignment operators.


<pre><code class="language-cpp">class Rational {
public:
  Rational &amp;operator-=(const Rational &amp;rhs) {
    // Makes use of `operator+=` and the unary `operator-`.
    return *this += -rhs;
  }
};
Rational operator+(const Rational &amp;lhs, const Rational &amp;rhs) {
  return Rational(lhs) += rhs; // Makes use of `operator+=`.
}
Rational operator-(const Rational &amp;lhs, const Rational &amp;rhs) {
  return Rational(lhs) -= rhs; // Makes use of `operator-=`.
}
</code></pre>


---

## **[Best practice]** <u>Avoid repetition.</u>


<pre><code class="language-cpp">class Rational {
public:
  Rational &amp;operator+=(const Rational &amp;rhs) {
    m_num = m_num * static_cast&lt;int&gt;(rhs.m_denom)
           + static_cast&lt;int&gt;(m_denom) * rhs.m_num;
    m_denom *= rhs.m_denom;
    simplify();
    return *this;
  }
};
</code></pre>


The arithmetic operators for `Rational` are simple yet requires carefulness.

- Integers with different signed-ness need careful treatment.
- Remember to `simplify()`.

Fortunately, we only need to pay attention to these things in `operator+=`. Everything will be right if `operator+=` is right.

---

## **[Best practice]** <u>Avoid repetition.</u>

The code would be very error-prone if you implement every function from scratch!



<pre><code class="language-cpp">class Rational {
public:
  Rational &amp;operator+=(const Rational &amp;rhs) {
    m_num = m_num * static_cast&lt;int&gt;(rhs.m_denom)
           + static_cast&lt;int&gt;(m_denom) * rhs.m_num;
    m_denom *= rhs.m_denom;
    simplify();
    return *this;
  }
  Rational &amp;operator-=(const Rational &amp;rhs) {
    m_num = m_num * static_cast&lt;int&gt;(rhs.m_denom)
           - static_cast&lt;int&gt;(m_denom) * rhs.m_num;
    m_denom *= rhs.m_denom;
    simplify();
    return *this;
  }
  friend Rational operator+(const Rational &amp;,
                            const Rational &amp;);
  friend Rational operator-(const Rational &amp;,
                            const Rational &amp;);
};
</code></pre>




<pre><code class="language-cpp">Rational operator+(const Rational &amp;lhs,
                   const Rational &amp;rhs) {
  return {
    lhs.m_num * static_cast&lt;int&gt;(rhs.m_denom)
        + static_cast&lt;int&gt;(lhs.m_denom) * rhs.lhs,
    lhs.m_denom * rhs.m_denom
  };
}
Rational operator-(const Rational &amp;lhs,
                   const Rational &amp;rhs) {
  return {
    lhs.m_num * static_cast&lt;int&gt;(rhs.m_denom)
        - static_cast&lt;int&gt;(lhs.m_denom) * rhs.lhs,
    lhs.m_denom * rhs.m_denom
  };
}
</code></pre>


---

## `Rational`: arithmetic operators

Exercise: Define `operator*` (multiplication) and `operator/` (division) as well as `operator*=` and `operator/=` for `Rational`.

---

## `Rational`: arithmetic and relational operators

What if we define them (say, `operator+`) as member functions?


<pre><code class="language-cpp">class Rational {
public:
  Rational(int x = 0) : m_num{x}, m_denom{1} {}
  Rational operator+(const Rational &amp;rhs) const {
    return {
      m_num * static_cast&lt;int&gt;(rhs.m_denom)
          + static_cast&lt;int&gt;(m_denom) * rhs.m_num,
      m_denom * rhs.m_denom
    };
  }
};
</code></pre>


---

## `Rational`: arithmetic and relational operators

What if we define them (say, `operator+`) as member functions?


<pre><code class="language-cpp">class Rational {
public:
  Rational(int x = 0) : m_num{x}, m_denom{1} {}
  Rational operator+(const Rational &amp;rhs) const {
    // ...
  }
};
</code></pre>



<pre><code class="language-cpp">Rational r = some_value();
auto s = r + 0; // OK, `r.operator+(0)`, effectively `r.operator+(Rational(0))`
auto t = 0 + r; // Error! `0.operator+(r)` ???
</code></pre>


---

## `Rational`: arithmetic and relational operators

To allow implicit conversions on both sides, the operator should be defined as **non-member functions**.


<pre><code class="language-cpp">Rational r = some_value();
auto s = r + 0; // OK, `operator+(r, 0)`, effectively `operator+(r, Rational(0))`
auto t = 0 + r; // OK, `operator+(0, r)`, effectively `operator+(Rational(0), r)`
</code></pre>


**[Best practice]** <u>The "symmetric" operators, whose operands are often exchangeable, often should be defined as non-member functions.</u>

---

## `Rational`: relational operators

Define `<` and `==`, and define others in terms of them. (Before C++20)

- Since C++20: Define `==` and `<=>`, and the compiler will generate others.

A possible way: Use `to_double` and compare the floating-point values.


<pre><code class="language-cpp">bool operator&lt;(const Rational &amp;lhs, const Rational &amp;rhs) {
  return lhs.to_double() &lt; rhs.to_double();
}
</code></pre>


- This does not require `operator<` to be a `friend`.
- However, this is subject to floating-point errors.

---

## `Rational`: ralational operators

Another way (possibly better):


<pre><code class="language-cpp">class Rational {
  friend bool operator&lt;(const Rational &amp;, const Rational &amp;);
  friend bool operator==(const Rational &amp;, const Rational &amp;);
};
bool operator&lt;(const Rational &amp;lhs, const Rational &amp;rhs) {
  return static_cast&lt;int&gt;(rhs.m_denom) * lhs.m_num
        &lt; static_cast&lt;int&gt;(lhs.m_denom) * rhs.m_num;
}
bool operator==(const Rational &amp;lhs, const Rational &amp;rhs) {
  return lhs.m_num == rhs.m_num &amp;&amp; lhs.m_denom == rhs.m_denom;
}
</code></pre>


If there are member functions to obtain the numerator and the denominator, these functions don't need to be `friend`.

---

## `Rational`: relational operators

**[Best practice]** <u>Avoid repetition.</u>

Define others in terms of `<` and `==`:


<pre><code class="language-cpp">bool operator&gt;(const Rational &amp;lhs, const Rational &amp;rhs) {
  return rhs &lt; lhs;
}
bool operator&lt;=(const Rational &amp;lhs, const Rational &amp;rhs) {
  return !(lhs &gt; rhs);
}
bool operator&gt;=(const Rational &amp;lhs, const Rational &amp;rhs) {
  return !(lhs &lt; rhs);
}
bool operator!=(const Rational &amp;lhs, const Rational &amp;rhs) {
  return !(lhs == rhs);
}
</code></pre>


---

## Relational operators

Define relational operators in a consistent way:

- `a != b` should mean `!(a == b)`
- `!(a < b)` and `!(a > b)` should imply `a == b`

C++20 has devoted some efforts to the design of **consistent comparison**: [P0515r3](https://open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0515r3.pdf).

---

## Relational operators

Avoid abuse of relational operators:


<pre><code class="language-cpp">struct Point2d { double x, y; };
bool operator&lt;(const Point2d &amp;lhs, const Point2d &amp;rhs) {
  return lhs.x &lt; rhs.x; // Is this the unique, best behavior?
}
// Much better design: Use a named function.
bool less_in_x(const Point2d &amp;lhs, const Point2d &amp;rhs) {
  return lhs.x &lt; rhs.x;
}
</code></pre>


**[Best practice]** <u>Operators should be used for operations that are likely to be unambiguous to users.</u>

- If an operator has plausibly more than one interpretation, use named functions instead. Function names can convey more information.

**`std::string` has `operator+` for concatenation. Why doesn't `std::vector` have one?**

---

## `++` and `--`

`++` and `--` are often defined as **members**, because they modify the object.

To differentiate the postfix version `x++` and the prefix version `++x`: **The postfix version has a parameter of type `int`.**

- The compiler will translate `++x` to `x.operator++()`, `x++` to `x.operator++(0)`.


<pre><code class="language-cpp">class Rational {
public:
  Rational &amp;operator++() { ++m_num; simplify(); return *this; }
  Rational operator++(int) { // This `int` parameter is not used.
    // The postfix version is almost always defined like this.
    auto tmp = *this;
    ++*this; // Makes use of the prefix version.
    return tmp;
  }
};
</code></pre>


---

## `++` and `--`


<pre><code class="language-cpp">class Rational {
public:
  Rational &amp;operator++() { ++m_num; simplify(); return *this; }
  Rational operator++(int) { // This `int` parameter is not used.
    // The postfix version is almost always defined like this.
    auto tmp = *this;
    ++*this; // Make use of the prefix version.
    return tmp;
  }
};
</code></pre>


The prefix version returns reference to `*this`, while the postfix version returns a copy of `*this` before incrementation.

- Same as the built-in behaviors.

---

## IO operators

Implement `std::cin >> r` and `std::cout << r`.

Input operator:


<pre><code class="language-cpp">std::istream &amp;operator&gt;&gt;(std::istream &amp;, Rational &amp;);
</code></pre>


Output operator:


<pre><code class="language-cpp">std::ostream &amp;operator&lt;&lt;(std::ostream &amp;, const Rational &amp;);
</code></pre>


- `std::cin` is of type `std::istream`, and `std::cout` is of type `std::ostream`.

- The left-hand side operand should be returned, so that we can write

  ```cpp
  std::cin >> a >> b >> c; std::cout << a << b << c;
  ```

---

## `Rational`: output operator


<pre><code class="language-cpp">class Rational {
  friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;, const Rational &amp;);
};
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Rational &amp;r) {
  return os &lt;&lt; r.m_num &lt;&lt; '/' &lt;&lt; r.m_denom;
}
</code></pre>


If there are member functions to obtain the numerator and the denominator, it don't have to be a `friend`.


<pre><code class="language-cpp">std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Rational &amp;r) {
  return os &lt;&lt; r.get_numerator() &lt;&lt; '/' &lt;&lt; r.get_denominator();
}
</code></pre>


---

## `Rational`: input operator

Suppose the input format is `a b` for the rational number $\dfrac ab$, where `a` and `b` are integers.


<pre><code class="language-cpp">std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Rational &amp;r) {
  int x, y; is &gt;&gt; x &gt;&gt; y;
  if (!is) { // Pay attention to input failures!
    x = 0;
    y = 1;
  }
  if (y &lt; 0) { y = -y; x = -x; }
  r = Rational(x, y);
  return is;
}
</code></pre>


---

# Example: `Dynarray`

---

## `operator[]`


<pre><code class="language-cpp">class Dynarray {
public:
  int &amp;operator[](std::size_t n) {
    return m_storage[n];
  }
  const int &amp;operator[](std::size_t n) const {
    return m_storage[n];
  }
};
</code></pre>


The use of `a[i]` is interpreted as `a.operator[](i)`.

[(C++23 allows `a[i, j, k]`!)](https://en.cppreference.com/w/cpp/language/operator_member_access#Built-in_subscript_operator)

Homework: Define `operator[]` and relational operators for `Dynarray`.

---

# Example: `WindowPtr`

---

## `WindowPtr`: indirection (dereference) operator

Recall the `WindowPtr` class we defined in the previous lecture.


<pre><code class="language-cpp">struct WindowWithCounter {
  Window theWindow;
  int refCount = 1;
};
class WindowPtr {
  WindowWithCounter *m_ptr;
public:
  Window &amp;operator*() const { // Why should it be const?
    return m_ptr-&gt;theWindow;
  }
};
</code></pre>


We want `*sp` to return reference to the managed object.

---

## `WindowPtr`: indirection (derefernce) operator

Why should `operator*` be `const`?


<pre><code class="language-cpp">class WindowPtr {
  WindowWithCounter *m_ptr;
public:
  Window &amp;operator*() const {
    return m_ptr-&gt;theWindow;
  }
};
</code></pre>


On a `const WindowPtr` ("top-level" `const`), obtaining a non-`const` reference to the managed object may still be allowed.

- The (smart) pointer is `const`, but the managed object is not.
- `this` is `const WindowPtr *`, so `m_ptr` is `WindowWithCounter *const`.

---

## `WindowPtr`: member access through pointer

To make `operator->` consistent with `operator*` (make `ptr->mem` equivalent to `(*ptr).mem`), `operator->` is almost always defined like this:


<pre><code class="language-cpp">class WindowPtr {
public:
  Window *operator-&gt;() const {
    return std::addressof(operator*());
  }
};
</code></pre>


`std::addressof(x)` is almost always equivalent to `&x`, but the latter may not return the address of `x` if `operator&` for `x` has been overloaded!

---

# User-defined type conversions

---

## Type conversions

A **type conversion** is a function $f:T\mapsto U$ for two different types $T$ and $U$.

Type conversions can happen either **implicitly** or **explicitly**. A conversion is **explicit** if and only if the target type `U` is written explicitly in the conversion expression.

Explicit conversions can happen in one of the following forms:


| expression           | explanation                   | example                          |
| -------------------- | ----------------------------- | -------------------------------- |
| `what_cast<U>(expr)` | through named casts           | `static_cast<int>(3.14)`         |
| `U(expr)`            | looks like a constructor call | `std::string("xx")`, `int(3.14)` |
| `(U)expr`            | old C-style conversion        | Not recommended. Don't use it.   |

---

## Type conversions

A **type conversion** is a function $f:T\mapsto U$ for two different types $T$ and $U$.

Type conversions can happen either **implicitly** or **explicitly**. A conversion is **explicit** if and only if the target type `U` is written explicitly in the conversion expression.

- Arithmetic conversions are often allowed to happen implicitly:

  ```cpp
  int sum = /* ... */, n = /* ... */;
  auto average = 1.0 * sum / n; // `sum` and `n` are converted to `double`,
                                // so `average` has type `double`.
  ```

- The dangerous conversions for built-in types must be explicit:

  ```cpp
  const int *cip = something();
  auto ip = const_cast<int *>(cip);       // int *
  auto cp = reinterpret_cast<char *>(ip); // char *
  ```

---

## Type conversions

A **type conversion** is a function $f:T\mapsto U$ for two different types $T$ and $U$.

Type conversions can happen either **implicitly** or **explicitly**. A conversion is **explicit** if and only if the target type `U` is written explicitly in the conversion expression.

- This is also a type conversion, isn't it?

  ```cpp
  std::string s = "hello"; // from `const char [6]` to `std::string`
  ```

- This is also a type conversion, isn't it?

  ```cpp
  std::size_t n = 1000;
  std::vector<int> v(n); // from `std::size_t` to `std::vector<int>`
  ```

How do these type conversions happen? Are they implicit or explicit?

---

## Type conversions

We can define a type conversion for our class `X` in one of the following ways:

1. A constructor with exactly one parameter of type `T` is a conversion from `T` to `X`.

   - Example: `std::string` has a constructor accepting a `const char *`. `std::vector` has a constructor accepting a `std::size_t`.

2. A **type conversion operator**: a conversion from `X` to some other type.

   ```cpp
   class Rational {
   public:
     // conversion from `Rational` to `double`.
     operator double() const { return 1.0 * m_num / m_denom; }
   };
   Rational r(3, 4);
   double dval = r;  // 0.75
   ```

---

## Type conversion operator

A type conversion operator is a member function of class `X`, which defines the type conversion from `X` to some other type `T`.


<pre><code class="language-cpp">class Rational {
public:
  // conversion from `Rational` to `double`.
  operator double() const { return 1.0 * m_num / m_denom; }
};
Rational r(3, 4);
double dval = r;  // 0.75
</code></pre>


- The name of the function is `operator T`.
- The return type is `T`, which is not written before the name.
- A type conversion is usually a **read-only** operation, so it is usually `const`.

---

## Explicit type conversion

Some conversions should be allowed to happen implicitly:


<pre><code class="language-cpp">void foo(const std::string &amp;str) { /* ... */ }
foo(&quot;hello&quot;); // implicit conversion from `const char [6]` to `const char *`,
              // and then to `std::string`.
</code></pre>


Some should never happen implicitly!


<pre><code class="language-cpp">void bar(const std::vector&lt;int&gt; &amp;vec) { /* ...*/ }
bar(1000);                  // ??? Too weird!
bar(std::vector&lt;int&gt;(1000)) // OK.
std::vector&lt;int&gt; v1(1000);  // OK.
std::vector&lt;int&gt; v2 = 1000; // No! This should never happen. Too weird!
</code></pre>


---

## Explicit type conversion

To disallow the implicit use of a constructor as a type conversion, write `explicit` before the return type:


<pre><code class="language-cpp">class string { // Suppose this is the `std::string` class.
public:
  string(const char *cstr); // Not marked `explicit`. Implicit use is allowed.
};

template &lt;typename T&gt; class vector { // Suppose this is the `std::vector` class.
public:
  explicit vector(std::size_t n); // Implicit use is not allowed.
};

class Dynarray {
public:
  explicit Dynarray(std::size_t n) : m_length{n}, m_storage{new int[n]{}} {}
};
</code></pre>


---

## Explicit type conversion

To disallow the implicit use of a type conversion operator, also write `explicit`:


<pre><code class="language-cpp">class Rational {
public:
  explicit operator double() const { return 1.0 * m_num / m_denom; }
};
Rational r(3, 4);
double d = r;                     // Error.
void foo(double x) { /* ... */ }
foo(r);                           // Error.
foo(double(r));                   // OK.
foo(static_cast&lt;double&gt;(r));      // OK.
</code></pre>


---

## **[Best practice]** <u>Avoid the abuse of type conversion operators.</u>

Type conversion operators can lead to unexpected results!


<pre><code class="language-cpp">class Rational {
public:
  operator double() const { return 1.0 * m_num / m_denom; }
  operator std::string() const {
    return std::to_string(m_num) + &quot; / &quot; + std::to_string(m_denom);
  }
};
int main() {
  Rational r(3, 4);
  std::cout &lt;&lt; r &lt;&lt; '\n'; // Ooops! Is it `0.75` or `3 / 4`?
}
</code></pre>


In the code above, either **mark the type conversions as `explicit`**, or remove them and **define named functions** like `to_double()` and `to_string()` instead.

---

## Contextual conversion to `bool`

A special rule for conversion to `bool`.

Suppose `expr` is an expression of a class type `X`, and suppose `X` has an `explicit` type conversion operator to `bool`. In the following contexts, that conversion is applicable even if it is not written as `bool(expr)` or `static_cast<bool>(expr)`:

- `if (expr)`, `while (expr)`, `for (...; expr; ...)`, `do ... while (expr)`
- as the operand of `!`, `&&`, `||`
- as the first operand of `?:`: `expr ? something : something_else`

---

## Contextual conversion to `bool`

Exercise: We often test whether a pointer is non-null like this:


<pre><code class="language-cpp">if (ptr) {
  // ...
}
auto val = ptr ? ptr-&gt;some_value : 0;
</code></pre>


Define a conversion from `WindowPtr` to `bool`, so that we can test whether a `WindowPtr` is non-null in the same way.

- Should this conversion be allowed to happen implicitly? If not, mark it `explicit`.

---

## Summary

Operator overloading

- As a non-member function: `@a` $\Leftrightarrow$ `operator@(a)`,  `a @ b` $\Leftrightarrow$ `operator@(a, b)`
- As a member function: `@a` $\Leftrightarrow$ `a.operator@()`, `a @ b` $\Leftrightarrow$ `a.operator@(b)`
  - The postfix `++` and `--` are special: They have a special `int` parameter to make them different from the prefix ones.
  - The arrow operator `->` is special: Although it looks like a binary operator in `ptr->mem`, it is unary and involves special rules.
    - You don't need to understand the exact rules for `->`.
- Avoid repetition.
- Avoid abuse of operator overloading.

---

## Summary

Type conversions

- Implicit vs explicit
- User-defined type conversions: either through a constructor or through a type conversion operator.
- To disable the implicit use of the user-defined type conversion: `explicit`
- Avoid abuse of type conversion operators.
- Conversion to `bool` has some special rules (*contextual conversion*).

# CS100 Lecture 20

Iterators and Algorithms

---

## Contents

- Iterators
- Algorithms

---

## Iterators

A generalized "pointer" used for accessing elements in different containers.

Every container has its iterator, whose type is `Container::iterator`.

e.g. `std::vector<int>::iterator`, `std::forward_list<std::string>::iterator`

- `auto` comes to our rescue!

---

## Iterators

For any container object `c`,

- `c.begin()` returns the iterator to the first element of `c`.
- `c.end()` returns the iterator to **the position following the last element** of `c` ("off-the-end", "past-the-end").

<a align="center">
  <img src="img/range-begin-end.svg", width=800>
</a>

---

## Iterators

A pair of iterators (`b`, `e`) is often used to indicate a range `[b, e)`.

Such ranges are **left-inclusive**. Benefits:

- `e - b` is the **length** (**size**) of the range, i.e. the number of elements. There is no extra `+1` or `-1` in this expression.
- If `b == e`, the range is empty. In other words, to check whether the range is empty, we only need to do an equality test, which is easily supported by all kinds of iterators.

---

## Iterators

Basic operations, supported by almost all kinds of iterators:

- `*it`: returns a reference to the element that `it` refers to.
- `it->mem`: equivalent to `(*it).mem`.
- `++it`, `it++`: moves `it` one step forward, so that `it` refers to the "next" element.
  - `++it` returns a reference to `it`, while `it++` returns a copy of `it` before incrementation.
- `it1 == it2`: checks whether `it1` and `it2` refer to the same position in the container.
- `it1 != it2`: equivalent to `!(it1 == it2)`.

These are supported by the iterators of all sequence containers, as well as `std::string`.

---

## Iterators

Use the basic operations to traverse a sequence container:


<pre><code class="language-cpp">void swapcase(std::string &amp;str) {
  for (auto it = str.begin(); it != str.end(); ++it) {
    if (std::islower(*it))
      *it = std::toupper(*it);
    else if (std::isupper(*it))
      *it = std::tolower(*it);
  }
}
void print(const std::vector&lt;int&gt; &amp;vec) {
  for (auto it = vec.begin(); it != vec.end(); ++it)
    std::cout &lt;&lt; *it &lt;&lt; ' ';
}
</code></pre>


---

## Iterators

**Built-in pointers are also iterators**: They are the iterator for built-in arrays.

For an array `Type a[N]`:

- The "begin" iterator is `a`.
- The "end" (off-the-end) iterator is `a + N`.

The standard library functions `std::begin(c)` and `std::end(c)` (defined in `<iterator>` and many other header files):

- return `c.begin()` and `c.end()` if `c` is a container;
- return `c` and `c + N` if `c` is an array of length `N`.

---

## Range-for demystified

The range-based for loop


<pre><code class="language-cpp">for (@declaration : container)
  @loop_body
</code></pre>


is equivalent to 


<pre><code class="language-cpp">{
  auto b = std::begin(container);
  auto e = std::end(container);
  for (; b != e; ++b) {
    @declaration = *b;
    @loop_body
  }
}
</code></pre>


---

## Iterators: dereferenceable

Like pointers, an iterator can be dereferenced (`*it`) only when it refers to an existing element. (**"dereferenceable"**)

- `*v.end()` is undefined behavior.
- `++it` is undefined behavior if `it` is not dereferenceable. In other words, moving an iterator out of the range `[begin, off_the_end]` is undefined behavior.

---

## Iterators: invalidation


<pre><code class="language-cpp">Type *storage = new Type[n];
Type *iter = storage;
delete[] storage;
// Now `iter` does not refer to any existing element.
</code></pre>


Some operations on some containers will **invalidate** some iterators:

- make these iterators not refer to any existing element.

For example:

- `push_back(x)` on a `std::vector` may cause the reallocation of storage. All iterators obtained previously are invalidated.
- `pop_back()` on a `std::vector` will invalidate the iterators that points to the deleted element.

---

## Never use invalidated iterators or references!


<pre><code class="language-cpp">void foo(std::vector&lt;int&gt; &amp;vec) {
  auto it = vec.begin();
  while (some_condition(vec))
    vec.push_back(*it++); // Undefined behavior.
}
</code></pre>


After several calls to `push_back`, `vec` may reallocate a larger chunk of memory to store its elements. This will invalidate all pointers, references and iterators that point to somewhere in the previous memory block.

---

## More operations on iterators

The iterators of containers that support `*it`, `it->mem`, `++it`, `it++`, `it1 == it2` and `it1 != it2` are [**ForwardIterators**](https://en.cppreference.com/w/cpp/named_req/ForwardIterator).

[**BidirectionalIterator**](https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator): a ForwardIterator that can be moved in both directions

- supports `--it` and `it--`.

[**RandomAccessIterator**](https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator): a BidirectionalIterator that can be moved to any position in constant time.

- supports `it + n`, `n + it`, `it - n`, `it += n`, `it -= n` for an integer `n`.
- supports `it[n]`, equivalent to `*(it + n)`.
- supports `it1 - it2`, returns the **distance** of two iterators.
- supports `<`, `<=`, `>`, `>=`.

---

## More operations on iterators

The iterators of containers that support `*it`, `it->mem`, `++it`, `it++`, `it1 == it2` and `it1 != it2` are [**ForwardIterators**](https://en.cppreference.com/w/cpp/named_req/ForwardIterator).

[**BidirectionalIterator**](https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator): a ForwardIterator that can be moved in both directions

- supports `--it` and `it--`.

[**RandomAccessIterator**](https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator): a BidirectionalIterator that can be moved to any position in constant time.

- supports `it + n`, `n + it`, `it - n`, `it += n`, `it -= n`, `it[n]`, `it1 - it2`, `<`, `<=`, `>`, `>=`.
- `std::string::iterator` and `std::vector<T>::iterator` are in this category.

Which category is the built-in pointer in?

---

## More operations on iterators

The iterators of containers that support `*it`, `it->mem`, `++it`, `it++`, `it1 == it2` and `it1 != it2` are [**ForwardIterators**](https://en.cppreference.com/w/cpp/named_req/ForwardIterator).

[**BidirectionalIterator**](https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator): a ForwardIterator that can be moved in both directions

- supports `--it` and `it--`.

[**RandomAccessIterator**](https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator): a BidirectionalIterator that can be moved to any position in constant time.

- supports `it + n`, `n + it`, `it - n`, `it += n`, `it -= n`, `it[n]`, `it1 - it2`, `<`, `<=`, `>`, `>=`.
- `std::string::iterator` and `std::vector<T>::iterator` are in this category.

Which category is the built-in pointer in? - RandomAccessIterator.

---

## Initialization from iterator range

`std::string`, `std::vector`, as well as other standard library containers, support the initialization from an iterator range:


<pre><code class="language-cpp">std::vector&lt;char&gt; v = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'};
std::vector v2(v.begin() + 2, v.end() - 3);  // {'c', 'd', 'e', 'f'}
std::string s(v.begin(), v.end()); // &quot;abcdefghi&quot;
</code></pre>


---

# Algorithms

---

## Algorithms

Full list of standard library algorithms can be found [here](https://en.cppreference.com/w/cpp/algorithm).

No one can remember all of them, but some are quite commonly used.

---

## Algorithms: interfaces

**Parameters**: The STL algorithms accept pairs of iterators to represent "ranges":


<pre><code class="language-cpp">int a[N], b[N]; std::vector&lt;int&gt; v;
std::sort(a, a + N);
std::sort(v.begin(), v.end());
std::copy(a, a + N, b); // copies elements in [a, a+N) to [b, b+N)
std::sort(v.begin(), v.begin() + 10); // Only the first 10 elements are sorted.
</code></pre>


Since C++20, `std::ranges::xxx` can be used, which has more modern interfaces


<pre><code class="language-cpp">std::ranges::sort(a);
std::ranges::copy(a, b);
</code></pre>


---

## Algorithms: interfaces

**Parameters**: The algorithms suffixed `_n` use **a beginning iterator `begin` and an integer `n` to represent a range `[begin, begin + n)`**.

Example: Use STL algorithms to rewrite the constructors of `Dynarray`:


<pre><code class="language-cpp">Dynarray::Dynarray(const int *begin, const int *end)
    : m_storage{new int[end - begin]}, m_length(end - begin) {
  std::copy(begin, end, m_storage);
}
Dynarray::Dynarray(const Dynarray &amp;other)
    : m_storage{new int[other.size()]}, m_length{other.size()} {
  std::copy_n(other.m_storage, other.size(), m_storage);
}
Dynarray::Dynarray(std::size_t n, int x = 0)
    : m_storage{new int[n]}, m_length{n} {
  std::fill_n(m_storage, m_length, x);
}
</code></pre>


---

## Algorithms: interfaces

**Return values**: "Position" is typically represented by an iterator. For example:


<pre><code class="language-cpp">std::vector&lt;int&gt; v = someValues();
auto pos = std::find(v.begin(), v.end(), 42);
assert(*pos == 42);
auto maxPos = std::max_element(v.begin(), v.end());
</code></pre>


- `pos` is an **iterator** pointing to the first occurrence of `42` in `v`.
- `maxPos` is an **iterator** pointing to the max element in `v`.

"Not found" / "No such element" is often indicated by returning `end`.


<pre><code class="language-cpp">if (std::find(v.begin(), v.end(), something) != v.end()) {
  // ...
}
</code></pre>


---

## `if`: new syntax in C++17

"Not found" / "No such element" is often indicated by returning `end`.


<pre><code class="language-cpp">if (std::find(v.begin(), v.end(), something) != v.end()) { /* (*) */ }
</code></pre>


If we want to use the returned iterator in (*):


<pre><code class="language-cpp">if (auto pos = std::find(v.begin(), v.end(), something); pos != v.end())
  std::cout &lt;&lt; *pos &lt;&lt; '\n';
</code></pre>


The new syntax of `if` in C++17: `if (init_expr; condition)`.

- `init_expr` is just like the first part of the `for` statement.
- The scope of the variable declared in `init_expr` is within this `if` statement (containing the `else` clause, if present).

---

## Algorithms: requirements

An algorithm may have **requirements** on

- the iterator categories of the passed-in iterators, and
- the type of elements that the iterators point to.

Typically, `std::sort` requires *RandomAccessIterator*s, while `std::copy` allows any *InputIterator*s.

Typically, all algorithms that need to compare elements rely only upon `operator<` and `operator==` of the elements.

- You don't have to define all the six comparison operators of `X` in order to `sort` a `vector<X>`. `sort` only requires `operator<`.

---

## Algorithms

Since we pass **iterators** instead of **containers** to algorithms, **the standard library algorithms never modify the length of the containers**.

- STL algorithms never insert or delete elements in the containers (unless the iterator passed to them is some special *iterator adapter*).

For example: `std::copy` only **copies** elements, instead of inserting elements.


<pre><code class="language-cpp">std::vector&lt;int&gt; a = someValues();
std::vector&lt;int&gt; b(a.size());
std::vector&lt;int&gt; c{};
std::copy(a.begin(), a.end(), b.begin()); // OK
std::copy(a.begin(), a.end(), c.begin()); // Undefined behavior!
</code></pre>


---

## Some common algorithms (`<algorithm>`)

Non-modifying sequence operations:

- `count(begin, end, x)`, `find(begin, end, x)`, `find_end(begin, end, x)`, `find_first_of(begin, end, x)`, `search(begin, end, pattern_begin, pattern_end)`

Modifying sequence operations:

- `copy(begin, end, dest)`, `fill(begin, end, x)`, `reverse(begin, end)`, ...
- `unique(begin, end)`: drop duplicate elements.
  - requires the elements in the range `[begin, end)` to be **sorted** (in ascending order by default).
  - **It does not remove any elements!** Instead, it moves all the duplicated elements to the end of the sequence, and returns an iterator `pos`, so that `[begin, pos)` has no duplicate elements.

---

## Some common algorithms (`<algorithm>`)

Example: `unique`


<pre><code class="language-cpp">std::vector v{1, 1, 2, 2, 2, 3, 5};
auto pos = std::unique(v.begin(), v.end());
// Now [v.begin(), pos) contains {1, 2, 3, 5}.
// [pos, v.end()) has the values {1, 2, 2}, but the exact order is not known.
v.erase(pos, v.end()); // Typical use with the container's `erase` operation
// Now v becomes {1, 2, 3, 5}.
</code></pre>


`unique` does not remove the duplicate elements! To remove them, use the container's `erase` operation.

---

## Some common algorithms (`<algorithm>`)

Partitioning, sorting and merging algorithms:

- `partition`, `is_partitioned`, `stable_partition`
- `sort`, `is_sorted`, `stable_sort`
- `nth_element`
- `merge`, `inplace_merge`

Binary search on sorted ranges:

- `lower_bound`, `upper_bound`, `binary_search`, `equal_range`

Heap algorithms:

- `is_heap`, `make_heap`, `push_heap`, `pop_heap`, `sort_heap`

Learn the underlying algorithms and data structures of these functions in CS101!

---

## Some common algorithms

Min/Max and comparison algorithms: (`<algorithm>`)

- `min_element(begin, end)`, `max_element(begin, end)`, `minmax_element(begin, end)`
- `equal(begin1, end1, begin2)`, `equal(begin1, end1, begin2, end2)`
- `lexicographical_compare(begin1, end1, begin2, end2)`

Numeric operations: (`<numeric>`)

- `accumulate(begin, end, initValue)`: Sum of elements in `[begin, end)`, with initial value `initValue`.
  - `accumulate(v.begin(), v.end(), 0)` returns the sum of elements in `v`.
- `inner_product(begin1, end1, begin2, initValue)`: Inner product of two vectors $\mathbf{a}^T\mathbf{b}$, added with the initial value `initValue`.

---

## Predicates

Consider the `Point2d` class:


<pre><code class="language-cpp">struct Point2d {
  double x, y;
};
std::vector&lt;Point2d&gt; points = someValues();
</code></pre>


Suppose we want to sort `points` in ascending order of the `x` coordinate.

- `std::sort` requires `operator<` in order to compare the elements,
- but it is not recommended to overload `operator<` here! (What if we want to sort some `Point2d`s in another way?)

(C++20 modern way: `std::ranges::sort(points, {}, &Point2d::x);`)

---

## Predicates

`std::sort` has another version that accepts another argument `cmp`:


<pre><code class="language-cpp">bool cmp_by_x(const Point2d &amp;lhs, const Point2d &amp;rhs) {
  return lhs.x &lt; rhs.x;
}
std::sort(points.begin(), points.end(), cmp_by_x);
</code></pre>


`sort(begin, end, cmp)`

- `cmp` is a **Callable** object. When called, it accepts two arguments whose type is the same as the element type, and returns `bool`.
- `std::sort` will use `cmp(x, y)` instead of `x < y` to compare elements.
- After sorting, `cmp(v[i], v[i + 1])` is true for every `i` $\in$ `[0, v.size()-1)`.

---

## Predicates

To sort numbers in reverse (descending) order:


<pre><code class="language-cpp">bool greater_than(int a, int b) { return a &gt; b; }
std::sort(v.begin(), v.end(), greater_than);
</code></pre>


To sort them in ascending order of absolute values:


<pre><code class="language-cpp">bool abs_less(int a, int b) { return std::abs(a) &lt; std::abs(b); } // &lt;cmath&gt;
std::sort(v.begin(), v.end(), abs_less);
</code></pre>


---

## Predicates

Many algorithms accept a Callable object. For example, `find_if(begin, end, pred)` finds the first element in `[begin, end)` such that `pred(element)` is true.


<pre><code class="language-cpp">bool less_than_10(int x) {
  return x &lt; 10;
}
std::vector&lt;int&gt; v = someValues();
auto pos = std::find_if(v.begin(), v.end(), less_than_10);
</code></pre>


`for_each(begin, end, operation)` performs `operation(element)` for each element in the range `[begin, end)`.


<pre><code class="language-cpp">void print_int(int x) { std::cout &lt;&lt; x &lt;&lt; ' '; }
std::for_each(v.begin(), v.end(), print_int);
</code></pre>


---

## Predicates

Many algorithms accept a Callable object. For example, `find_if(begin, end, pred)` finds the first element in `[begin, end)` such that `pred(element)` is true.

What if we want to find the first element less than **`k`**, where `k` is determined at run-time?

---

## Predicates

What if we want to find the first element less than **`k`**, where `k` is determined at run-time?


<pre><code class="language-cpp">struct LessThan {
  int k_;
  LessThan(int k) : k_{k} {}
  bool operator()(int x) const {
    return x &lt; k_;
  }
};
auto pos = std::find_if(v.begin(), v.end(), LessThan(k));
</code></pre>


- `LessThan(k)` constructs an object of type `LessThan`, with the member `k_` initialized to `k`.
- This object has an `operator()` overloaded: **the function-call operator**.
  - `LessThan(k)(x)` is equivalent to `LessThan(k).operator()(x)`, which is `x < k`.

---

## Function objects

Modern way:


<pre><code class="language-cpp">struct LessThan {
  int k_; // No constructor is needed, and k_ is public.
  bool operator()(int x) const { return x &lt; k_; }
};
auto pos = std::find_if(v.begin(), v.end(), LessThan{k}); // {} instead of ()
</code></pre>


A **function object** (aka "functor") is an object `fo` with `operator()` overloaded.

- `fo(arg1, arg2, ...)` is equivalent to `fo.operator()(arg1, arg2, ...)`. Any number of arguments is allowed.

---

## Function objects

Exercise: use a function object to compare integers by their absolute values.


<pre><code class="language-cpp">struct AbsCmp {
  bool operator()(int a, int b) const {
    return std::abs(a) &lt; std::abs(b);
  }
};
std::sort(v.begin(), v.end(), AbsCmp{});
</code></pre>


---

## Lambda expressions

Defining a function or a function object is not good enough:

- These functions or function objects are almost used only once, but
- too many lines of code is needed, and
- you have to add names to the global scope.

Is there a way to define an **unnamed**, immediate callable object?

---

## Lambda expressions

To sort by comparing absolute values:


<pre><code class="language-cpp">std::sort(v.begin(), v.end(),
          [](int a, int b) -&gt; bool { return std::abs(a) &lt; std::abs(b); });
</code></pre>


To sort in reverse order:


<pre><code class="language-cpp">std::sort(v.begin(), v.end(),
          [](int a, int b) -&gt; bool { return a &gt; b; });
</code></pre>


To find the first element less than `k`:


<pre><code class="language-cpp">auto pos = std::find_if(v.begin(), v.end(),
                        [k](int x) -&gt; bool { return x &lt; k; });
</code></pre>


---

## Lambda expressions

The return type can be omitted and deduced by the compiler.


<pre><code class="language-cpp">std::sort(v.begin(), v.end(),
          [](int a, int b) { return std::abs(a) &lt; std::abs(b); });
</code></pre>



<pre><code class="language-cpp">std::sort(v.begin(), v.end(), [](int a, int b) { return a &gt; b; });
</code></pre>



<pre><code class="language-cpp">auto pos = std::find_if(v.begin(), v.end(), [k](int x) { return x &lt; k; });
</code></pre>


---

## Lambda expressions

A lambda expression has the following syntax:


<pre><code class="language-cpp">[capture_list](params) -&gt; return_type { function_body }
</code></pre>


The compiler will generate a function object according to it.


<pre><code class="language-cpp">int k = 42;
auto f = [k](int x) -&gt; bool { return x &lt; k; };
bool b1 = f(10); // true
bool b2 = f(100); // false
</code></pre>


---

## Lambda expressions


<pre><code class="language-cpp">[capture_list](params) -&gt; return_type { function_body }
</code></pre>


It is allowed to write complex statements in `function_body`, just as in a function.


<pre><code class="language-cpp">struct Point2d { double x, y; };
std::vector&lt;Point2d&gt; points = somePoints();
// prints the l2-norm of every point
std::for_each(points.begin(), points.end(),
              [](const Point2d &amp;p) {
                auto norm = std::sqrt(p.x * p.x + p.y * p.y);
                std::cout &lt;&lt; norm &lt;&lt; std::endl;
              });
</code></pre>


---

## Lambda expressions: capture

To capture more variables:


<pre><code class="language-cpp">auto pos = std::find_if(v.begin(), v.end(),
                    [lower, upper](int x) { return lower &lt;= x &amp;&amp; x &lt;= upper;});
</code></pre>


To capture by reference (so that copy is avoided)


<pre><code class="language-cpp">std::string str = someString();
std::vector&lt;std::string&gt; wordList;
// finds the first string that is lexicographically greater than `str`,
// but shorter than `str`.
auto pos = std::find_if(wordList.begin(), wordList.end(),
     [&amp;str](const std::string &amp;s) { return s &gt; str &amp;&amp; s.size() &lt; str.size();});
</code></pre>


Here `&str` indicates that `str` is captured by referece. **`&` here is not the address-of operator!**

---

## More on lambda expressions

- *C++ Primer* Section 10.3
- *Effective Modern C++* Chapter 6 (Item 31-34)

Note that *C++ Primer (5th edition)* is based on C++11 and *Effective Modern C++* is based on C++14. Lambda expressions are evolving at a very fast pace in modern C++, with many new things added and many limitations removed.

More fancy ways of writing lambda expressions are not covered in CS100.

---

## Back to algorithms

So many things in the algorithm library! How can we remember them?

- Remember the **conventions**:
  - No insertion/deletion of elements
  - Iterator range `[begin, end)`
  - Functions named with the suffix `_n` uses `[begin, begin + n)`
  - Pass functions, function objects, and lambdas for customized operations
  - Functions named with the suffix `_if` requires a boolean predicate
- Remember the common ones: `copy`, `find`, `for_each`, `sort`, ...
- Look them up in [cppreference](https://en.cppreference.com/w/cpp/algorithm) before use.

---

## Summary

Iterators

- A generalized "pointer" used for accessing elements in different containers.
- Iterator range: a left-inclusive interval `[b, e)`.
- `c.begin()`, `c.end()`
- Basic operations: `*it`, `it->mem`, `++it`, `it++`, `it1 == it2`, `it1 != it2`.
- Range-based `for` loops are in fact traversal using iterators.
- More operations: BidirectionalIterator supports `it--` and `--it`. RandomAccessIterator supports all pointer arithmetics.
- Initialization of standard library containers from an iterator range.

---

## Summary

Algorithms

- Normal functions accept iterator range `[b, e)`. Functions with `_n` accept an iterator and an integer, representing the range `[begin, begin + n)`.
- Position is represented by an iterator.
- STL algorithms never insert or delete elements in the containers.
- Some algorithms accept a predicate argument, which is a callable object. It can be a function, a pointer to function, an object of some type that has an overloaded `operator()`, or a lambda.
- Lambda: `[capture_list][params] -> return_type { function_body }`

# CS100 Lecture 21

Inheritance and Polymorphism <span style="color: black; font-family: Times New Roman; font-size: 1.05em;">I</span>

---

## Contents

- Inheritance
- Dynamic binding and polymorphism

---

# Inheritance

---

## Example: An item for sale


<pre><code class="language-cpp">class Item {
  std::string m_name;
  double m_price = 0.0;
public:
  Item() = default;
  Item(const std::string &amp;name, double price)
      : m_name(name), m_price(price) {}
  const auto &amp;getName() const { return m_name; }
  auto netPrice(int cnt) const {
    return cnt * m_price;
  }
};
</code></pre>


---

## Defining a subclass

A discounted item **is an** item, and has more information:

- `std::size_t m_minQuantity;`
- `double m_discount;`

The net price for such an item is

$$
\text{netPrice}(n)=\begin{cases}
n\cdot\text{price},&\text{if }n<\text{minQuantity},\\
n\cdot\text{discount}\cdot\text{price},&\text{otherwise}.
\end{cases}
$$

---

## Defining a subclass

Use **inheritance** to model the "is-a" relationship:

- A discounted item **is an** item.


<pre><code class="language-cpp">class DiscountedItem : public Item {
  int m_minQuantity = 0;
  double m_discount = 1.0;
public:
  // constructors
  // netPrice
};
</code></pre>


---

## `protected` members

A `protected` member is private, except that it is accessible in subclasses.

- `m_price` needs to be `protected`, of course.
- Should `m_name` be `protected` or `private`?
  - `private` is ok if the subclass does not modify it. It is accessible through the public `getName` interface.
  - `protected` is also reasonable.

---

## `protected` members


<pre><code class="language-cpp">class Item {
  std::string m_name;
protected:
  double m_price = 0.0;
public:
  Item() = default;
  Item(const std::string &amp;name, double price)
      : m_name(name), m_price(price) {}
  const auto &amp;getName() const { return m_name; }
  auto netPrice(int cnt) const {
    return cnt * m_price;
  }
};
</code></pre>


---

## Inheritance

<!-- TODO: There should be a diagram here. -->

By defining `DiscountedItem` to be a subclass of `Item`, **every `DiscountedItem` object contains a subobject of type `Item`.**

- Every data member and member function, except the ctors and dtors, is inherited, **no matter what access level they have**.

What can be inferred from this?

---

## Inheritance

By defining `DiscountedItem` to be a subclass of `Item`, **every `DiscountedItem` object contains a subobject of type `Item`.**

- Every data member and member function, except the ctors and dtors, is inherited, **no matter what access level they have**.

What can be inferred from this?

- A constructor of `DiscountedItem` must first initialize the base class subobject by calling a constructor of `Item`'s.
- The destructor of `DiscountedItem` must call the destructor of `Item` after having destroyed its own members (`m_minQuantity` and `m_discount`).
- `sizeof(Derived) >= sizeof(Base)`

---

## Inheritance

Key points of inheritance:

- Every object of the derived class (subclass) contains a base class subobject.
- Inheritance should not break the encapsulation of the base class.
  - e.g. To initialize the base class subobject, **we must call a constructor of the base class**. It is not allowed to initialize data members of the base class subobject directly.

---

## Constructor of `DiscountedItem`


<pre><code class="language-cpp">class DiscountedItem : public Item {
  int m_minQuantity = 0;
  double m_discount = 1.0;
public:
  DiscountedItem(const std::string &amp;name, double price,
                 int minQ, double disc)
      : Item(name, price), m_minQuantity(minQ), m_discount(disc) {}
};
</code></pre>


It is not allowed to write this:


<pre><code class="language-cpp">DiscountedItem(const std::string &amp;name, double price,
               int minQ, double disc)
    : m_name(name), m_price(price), m_minQuantity(minQ), m_discount(disc) {}
</code></pre>


---

## Constructor of derived classes

Before the initialization of the derived class's own data members, the base class subobject **must** be initialized by having one of its ctors called.

- What if we don't call the base class's ctor explicitly?

  ```cpp
  DiscountedItem(...)
    : /* ctor of Item is not called */ m_minQuantity(minQ), m_discount(d) {}
  ```

---

## Constructor of derived classes

Before the initialization of the derived class's own data members, the base class subobject **must** be initialized by having one of its ctors called.

- What if we don't call the base class's ctor explicitly?

  - The default constructor of the base class is called.
  - If the base class is not default-constructible, an error.

- What does this constructor do?

  ```cpp
  DiscountedItem() = default;
  ```

---

## Constructor of derived classes

Before the initialization of the derived class's own data members, the base class subobject **must** be initialized by having one of its ctors called.

- What if we don't call the base class's ctor explicitly?

  - The default constructor of the base class is called.
  - If the base class is not default-constructible, an error.

- What does this constructor do?

  ```cpp
  DiscountedItem() = default;
  ```

  - Calls `Item::Item()` to default-initialize the base class subobject before initializing `m_minQuantity` and `m_discount`.

---

## Constructor of derived classes

In the following code, does the constructor of `DiscountedItem` compile?


<pre><code class="language-cpp">class Item {
protected:
  std::string m_name;
  double m_price;
public:
  Item(const std::string &amp;name, double p) : m_name(name), m_price(p) {}
};
class DiscountedItem : public Item {
  int m_minQuantity;
  double m_discount;
public:
  DiscountedItem(const std::string &amp;name, double p, int mq, double disc) {
    m_name = name; m_price = p; m_minQuantity = mq; m_discount = disc;
  }
};
</code></pre>


---

## Constructor of derived classes

In the following code, does the constructor of `DiscountedItem` compile?


<pre><code class="language-cpp">class Item {
  // ...
public:
  // Since `Item` has a user-declared constructor, it does not have
  // a default constructor.
  Item(const std::string &amp;name, double p) : m_name(name), m_price(p) {}
};
class DiscountedItem : public Item {
  // ...
public:
  DiscountedItem(const std::string &amp;name, double p, int mq, double disc)
  // Before entering the function body, `Item::Item()` is called --&gt; Error!
  { /* ... */ }
};
</code></pre>


**[Best practice]** <u>Use constructor initializer lists whenever possible.</u>

---

# Dynamic binding

---

## Upcasting

If `D` is a subclass of `B`:

- A `B*` can point to a `D`, and
- A `B&` can be bound to a `D`.


<pre><code class="language-cpp">DiscountedItem di = someValue();
Item &amp;ir = di; // correct
Item *ip = &amp;di; // correct
</code></pre>


Reason: The **is-a** relationship! A `D` **is a** `B`.

But on such references or pointers, only the members of `B` can be accessed.

---

## Upcasting: Example


<pre><code class="language-cpp">void printItemName(const Item &amp;item) {
  std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; item.getName() &lt;&lt; std::endl;
}
DiscountedItem di(&quot;A&quot;, 10, 2, 0.8);
Item i(&quot;B&quot;, 15);
printItemName(i); // &quot;Name: B&quot;
printItemName(di); // &quot;Name: A&quot;
</code></pre>


`const Item &item` can be bound to either an `Item` or a `DiscountedItem`.

---

## Static type and dynamic type

- **static type** of an expression: The type known at compile-time.
- **dynamic type** of an expression: The real type of the object that the expression is representing. This is known at run-time.


<pre><code class="language-cpp">void printItemName(const Item &amp;item) {
  std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; item.getName() &lt;&lt; std::endl;
}
</code></pre>


The static type of the expression `item` is `const Item`, but its dynamic type is not known until run-time. (It may be `const Item` or `const DiscountedItem`.)

---

## `virtual` functions

`Item` and `DiscountedItem` have different ways of computing the net price.


<pre><code class="language-cpp">void printItemInfo(const Item &amp;item) {
  std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; item.getName()
            &lt;&lt; &quot;, price: &quot; &lt;&lt; item.netPrice(1) &lt;&lt; std::endl;
}
</code></pre>


- Which `netPrice` should be called?
- How do we define two different `netPrice`s?

---

## `virtual` functions


<pre><code class="language-cpp">class Item {
public:
  virtual double netPrice(int cnt) const {
    return m_price * cnt;
  }
  // other members
};
class DiscountedItem : public Item {
public:
  double netPrice(int cnt) const override {
    return cnt &lt; m_minQuantity ? cnt * m_price : cnt * m_price * m_discount;
  }
  // other members
};
</code></pre>


Note: `auto` cannot be used to deduce the return type of `virtual` functions.

---

## Dynamic binding


<pre><code class="language-cpp">void printItemInfo(const Item &amp;item) {
  std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; item.getName()
            &lt;&lt; &quot;, price: &quot; &lt;&lt; item.netPrice(1) &lt;&lt; std::endl;
}
</code></pre>


The dynamic type of `item` is determined at run-time.

Since `netPrice` is a `virtual` function, which version is called is also determined at run-time:

- If the dynamic type of `item` is `Item`, it calls `Item::netPrice`.
- If the dynamic type of `item` is `DiscountedItem`, it calls `DiscountedItem::netPrice`.

**late binding**, or **dynamic binding**

---

## `virtual`-`override`

To **override** (覆盖/覆写) a `virtual` function,

- The function parameter list must be the same as that of the base class's version.
- The return type should be **identical to** (or ***covariant with***) that of the corresponding function in the base class.
  - We will talk about "covariant with" in later lectures or recitations.
- **The `const`ness should be the same!**

To make sure you are truly overriding the `virtual` function (instead of making a overloaded version), use the `override` keyword.

**\* Not to be confused with "overloading"（重载）.**

---

## `virtual`-`override`

An overriding function is also `virtual`, even if not explicitly declared.


<pre><code class="language-cpp">class DiscountedItem : public Item {
  virtual double netPrice(int cnt) const override; // correct, explicitly virtual
};
class DiscountedItem : public Item {
  double netPrice(int cnt) const; // also correct, but not recommended
};
</code></pre>


The `override` keyword lets the compiler check and report if the function is not truly overriding.

**[Best practice]** <u>To override a virtual function, write the `override` keyword explicitly.</u> The `virtual` keyword can be omitted.

---

## `virtual` destructors


<pre><code class="language-cpp">Item *ip = nullptr;
if (some_condition)
  ip = new Item(/* ... */);
else
  ip = new DiscountedItem(/* ... */);
// ...
delete ip;
</code></pre>


Whose destructor should be called?

- Only looking at the static type of `*ip` is not enough.

---

## `virtual` destructors


<pre><code class="language-cpp">Item *ip = nullptr;
if (some_condition)
  ip = new Item(/* ... */);
else
  ip = new DiscountedItem(/* ... */);
// ...
delete ip;
</code></pre>


Whose destructor should be called? - It needs to be determined at run-time!

- **To use dynamic binding correctly, you almost always need a `virtual` destructor.**

---

## `virtual` destructors


<pre><code class="language-cpp">Item *ip = nullptr;
if (some_condition)
  ip = new Item(/* ... */);
else
  ip = new DiscountedItem(/* ... */);
// ...
delete ip;
</code></pre>


- The implicitly-defined (compiler-generated) destructor is **non-`virtual`**, but we can explicitly require a `virtual` one:

  ```cpp
  virtual ~Item() = default;
  ```

- If the dtor of the base class is `virtual`, the compiler-generated dtor for the derived class is also `virtual`.

---

## (Almost) completed `Item` and `DiscountedItem`


<pre><code class="language-cpp">class Item {
  std::string m_name;

protected:
  double m_price = 0.0;

public:
  Item() = default;
  Item(const std::string &amp;name, double price) : m_name(name), m_price(price) {}
  const auto &amp;getName() const { return name; }
  virtual double net_price(int n) const {
    return n * price;
  }
  virtual ~Item() = default;
};
</code></pre>


---

## (Almost) completed `Item` and `DiscountedItem`


<pre><code class="language-cpp">class DiscountedItem : public Item {
  int m_minQuantity = 0;
  double m_discount = 1.0;

public:
  DiscountedItem(const std::string &amp;name, double price,
                 int minQ, double disc)
      : Item(name, price), m_minQuantity(minQ), m_discount(disc) {}
  double netPrice(int cnt) const override {
    return cnt &lt; m_minQuantity ? cnt * m_price : cnt * m_price * m_discount;
  }
};
</code></pre>


---

## Usage with smart pointers

Smart pointers are implemented by wrapping the raw pointers, so they can also be used for dynamic binding.


<pre><code class="language-cpp">std::vector&lt;std::shared_ptr&lt;Item&gt;&gt; myItems;
for (auto i = 0; i != n; ++i) {
  if (someCondition) {
    myItems.push_back(std::make_shared&lt;Item&gt;(someParams));
  } else {
    myItems.push_back(std::make_shared&lt;DiscountedItem&gt;(someParams));
  }
}
</code></pre>


A `std::unique_ptr<Derived>` can be implicitly converted to a `std::unique_ptr<Base>`.

A `std::shared_ptr<Derived>` can be implicitly converted to a `std::shared_ptr<Base>`.

---

## Copy-control

Remember to copy/move the base subobject! One possible way:


<pre><code class="language-cpp">class Derived : public Base {
public:
  Derived(const Derived &amp;other)
      : Base(other), /* Derived's own members */ { /* ... */ }
  Derived &amp;operator=(const Derived &amp;other) {
    Base::operator=(other); // call Base's operator= explicitly
    // copy Derived's own members
    return *this;
  }
  // ...
};
</code></pre>


Why `Base(other)` and `Base::operator=(other)` work?

- The parameter type is `const Base &`, which can be bound to a `Derived` object.

---

## Synthesized copy-control members

Guess!

- What are the behaviors of the compiler-generated copy-control members?
- In what cases will they be `delete`d?

---

## Synthesized copy-control members

Remeber that the base class's subobject is always handled first.

These rules are quite natural:

- What are the behaviors of the compiler-generated copy-control members?
  - First, it calls the base class's corresponding copy-control member.
  - Then, it performs the corresponding operation on the derived class's own data members.
- In what cases will they be `delete`d?
  - If the base class's corresponding copy-control member is not accessible (e.g. non-existent, or `private`),
  - or if any of the data members' corresponding copy-control member is not accessible.

---

## Slicing

Dynamic binding only happens on references or pointers to base class.


<pre><code class="language-cpp">DiscountedItem di(&quot;A&quot;, 10, 2, 0.8);
Item i = di; // What happens?
auto x = i.netPrice(3); // Which netPrice?
</code></pre>


---

## Slicing

Dynamic binding only happens on references or pointers to base class.


<pre><code class="language-cpp">DiscountedItem di(&quot;A&quot;, 10, 2, 0.8);
Item i = di; // What happens?
auto x = i.netPrice(3); // Which netPrice?
</code></pre>


`Item i = di;` calls the **copy constructor of `Item`**

- but `Item`'s copy constructor handles only the base part.
- So `DiscountedItem`'s own members are **ignored**, or **"sliced down"**.
- `i.netPrice(3)` calls `Item::netPrice`.

---

## Downcasting


<pre><code class="language-cpp">Base *bp = new Derived{};
</code></pre>


If we only have a `Base` pointer, but we are quite sure that it points to a `Derived` object

- Accessing the members of `Derived` through `bp` is not allowed.
- How can we perform a **"downcasting"**?

---

## Polymorphic class

A class is said to be **polymorphic** if it has (declares or inherits) at least one virtual function.

- Either a `virtual` normal member function or a `virtual` dtor is ok.

If a class is polymorphic, all classes derived from it are polymorphic.

- There is no way to "refuse" to inherit any member functions, so `virtual` member functions must be inherited.
- The dtor must be `virtual` if the dtor of the base class is `virtual`.

---

## Downcasting: For polymorphic class only

`dynamic_cast<Target>(expr)`.


<pre><code class="language-cpp">Base *bp = new Derived{};
Derived *dp = dynamic_cast&lt;Derived *&gt;(bp);
Derived &amp;dr = dynamic_cast&lt;Derived &amp;&gt;(*bp);
</code></pre>


- `Target` must be a **reference** or a **pointer** type.
- `dynamic_cast` will perform **runtime type identification (RTTI)** to check the dynamic type of the expression.
  - If the dynamic type is `Derived`, or a derived class (direct or indirect) of `Derived`, the downcasting succeeds.
  - Otherwise, the downcasting fails. If `Target` is a pointer, returns a null pointer. If `Target` is a reference, throws an exception `std::bad_cast`.

---

## `dynamic_cast` can be very slow

`dynamic_cast` performs a runtime **check** to see whether the downcasting should succeed, which uses runtime type information.

This is **much slower** than other types of casting, e.g. `const_cast`, or arithmetic conversions.

**[Best practice]** <u>Avoid `dynamic_cast` whenever possible.</u>

### Guaranteed successful downcasting: Use `static_cast`.

If the downcasting is guaranteed to be successful, you may use `static_cast`


<pre><code class="language-cpp">auto dp = static_cast&lt;Derived *&gt;(bp); // quicker than dynamic_cast,
// but performs no checks. If the dynamic type is not Derived, UB.
</code></pre>


---

## Avoiding `dynamic_cast`

Typical abuse of `dynamic_cast`:



<pre><code class="language-cpp">struct A {
  virtual ~A() {}
};
struct B : A {};
struct C : A {};
</code></pre>




<pre><code class="language-cpp">std::string getType(const A *ap) {
  if (dynamic_cast&lt;const B *&gt;(ap))
    return &quot;B&quot;;
  else if (dynamic_cast&lt;const C *&gt;(ap))
    return &quot;C&quot;;
  else
    return &quot;A&quot;;
}
</code></pre>


---

## Avoiding `dynamic_cast`

Use a group of `virtual` functions!



<pre><code class="language-cpp">struct A {
  virtual ~A() {}
  virtual std::string name() const {
    return &quot;A&quot;;
  }
};
struct B : A {
  std::string name()const override{
    return &quot;B&quot;;
  }
};
struct C : A {
  std::string name()const override{
    return &quot;C&quot;;
  }
};
</code></pre>




<pre><code class="language-cpp">auto getType(const A *ap) {
  return ap-&gt;name();
}
</code></pre>


---

## Summary

Inheritance

- Every object of type `Derived` contains a subobject of type `Base`.
  - Every member of `Base` is inherited, no matter whether it is accessible or not.
- Inheritance should not break the base class's encapsulation.
  - The access control of inherited members is not changed.
  - Every constructor of `Derived` calls a constructor of `Base` to initialize the base class subobject **before** initializing its own data members.
  - The destructor of `Derived` calls the destructor of `Base` to destroy the base class subobject **after** destroying its own data members.

---

## Summary

Dynamic binding

- Upcasting: A pointer, reference or smart pointer to `Base` can be bound to an object of type `Derived`.
  - static type and dynamic type
- `virtual` functions: A function that can be overridden by derived classes.
  - The base class and the derived class can provide different versions of this function.
- Dynamic (late) binding
  - A call to a virtual function on a pointer or reference to `Base` will actually call the corresponding version of that function according to the dynamic type.
- Avoid downcasting if possible.

# CS100 Lecture 22

Inheritance and Polymorphism <span style="color: black; font-family: Times New Roman; font-size: 1.05em;">II</span>

---

## Contents

- Abstract base class
- More on the "is-a" relationship (*Effective C++* Item 32)
- Inheritance of interface vs inheritance of implementation (*Effective C++* Item 34)

---

# Abstract base class

---

## Shapes

Define different shapes: Rectangle, Triangle, Circle, ...

Suppose we want to draw things like this:


<pre><code class="language-cpp">void drawThings(ScreenHandle &amp;screen,
                const std::vector&lt;std::shared_ptr&lt;Shape&gt;&gt; &amp;shapes) {
  for (const auto &amp;shape : shapes)
    shape-&gt;draw(screen);
}
</code></pre>


and print information:


<pre><code class="language-cpp">void printShapeInfo(const Shape &amp;shape) {
  std::cout &lt;&lt; &quot;Area: &quot; &lt;&lt; shape.area()
            &lt;&lt; &quot;Perimeter: &quot; &lt;&lt; shape.perimeter() &lt;&lt; std::endl;
}
</code></pre>


---

## Shapes

Define a base class `Shape` and let other shapes inherit it.


<pre><code class="language-cpp">class Shape {
public:
  Shape() = default;
  virtual void draw(ScreenHandle &amp;screen) const;
  virtual double area() const;
  virtual double perimeter() const;
  virtual ~Shape() = default;
};
</code></pre>


Different shapes should define their own `draw`, `area`  and `perimeter`, so these functions should be `virtual`.

---

## Shapes


<pre><code class="language-cpp">class Rectangle : public Shape {
  Point2d mTopLeft, mBottomRight;

public:
  Rectangle(const Point2d &amp;tl, const Point2d &amp;br)
      : mTopLeft(tl), mBottomRight(br) {} // Base is default-initialized
  void draw(ScreenHandle &amp;screen) const override { /* ... */ }
  double area() const override {
    return (mBottomRight.x - mTopLeft.x) * (mBottomRight.y - mTopLeft.y);
  }
  double perimeter() const override {
    return 2 * (mBottomRight.x - mTopLeft.x + mBottomRight.y - mTopLeft.y);
  }
};
</code></pre>


---

## Pure `virtual` functions

How should we define `Shape::draw`, `Shape::area` and `Shape::perimeter`?

- For the general concept "Shape", there is no way to determine the behaviors of these functions.

---

## Pure `virtual` functions

How should we define `Shape::draw`, `Shape::area` and `Shape::perimeter`?

- For the general concept "Shape", there is no way to determine the behaviors of these functions.
- Direct call to `Shape::draw`, `Shape::area` and `Shape::perimeter` should be forbidden.
- We shouldn't even allow an object of type `Shape` to be instantiated! The class `Shape` is only used to **define the concept "Shape" and required interfaces**.

---

## Pure `virtual` functions

If a `virtual` function does not have a reasonable definition in the base class, it should be declared as **pure `virtual`** by writing `=0`.


<pre><code class="language-cpp">class Shape {
public:
  virtual void draw(ScreenHandle &amp;) const = 0;
  virtual double area() const = 0;
  virtual double perimeter() const = 0;
  virtual ~Shape() = default;
};
</code></pre>


Any class that has a **pure `virtual` function** is an **abstract class**. Pure `virtual` functions (usually) cannot be called ${}^{\textcolor{red}{1}}$, and abstract classes cannot be instantiated.

---

## Pure `virtual` functions and abstract classes

Any class that has a **pure `virtual` function** is an **abstract class**. Pure `virtual` functions (usually) cannot be called ${}^{\textcolor{red}{1}}$, and abstract classes cannot be instantiated.


<pre><code class="language-cpp">Shape shape; // Error.
Shape *p = new Shape; // Error.
auto sp = std::make_shared&lt;Shape&gt;(); // Error.
std::shared_ptr&lt;Shape&gt; sp2 = std::make_shared&lt;Rectangle&gt;(p1, p2); // OK.
</code></pre>


We can define pointer or reference to an abstract class, but never an object of that type!

---

## Pure `virtual` functions and abstract classes

An impure `virtual` function **must be defined**. Otherwise, the compiler will fail to generate necessary runtime information (the virtual table), which leads to an error.


<pre><code class="language-cpp">class X {
  virtual void foo(); // Declaration, without a definition
  // Even if `foo` is not used, this will lead to an error.
};
</code></pre>


Linkage error:


<pre><code>/usr/bin/ld: /tmp/ccV9TNfM.o: in function `main':
a.cpp:(.text+0x1e): undefined reference to `vtable for X'
</code></pre>


---

## Make the interface robust, not error-prone.

Is this good?


<pre><code class="language-cpp">class Shape {
public:
  virtual double area() const {
    return 0;
  }
};
</code></pre>


What about this?


<pre><code class="language-cpp">class Shape {
public:
  virtual double area() const {
    throw std::logic_error{&quot;area() called on Shape!&quot;};
  }
};
</code></pre>


---

## Make the interface robust, not error-prone.


<pre><code class="language-cpp">class Shape {
public:
  virtual double area() const {
    return 0;
  }
};
</code></pre>


If `Shape::area` is called accidentally, the error will happen ***silently***!

---

## Make the interface robust, not error-prone.


<pre><code class="language-cpp">class Shape {
public:
  virtual double area() const {
    throw std::logic_error{&quot;area() called on Shape!&quot;};
  }
};
</code></pre>


If `Shape::area` is called accidentally, an exception will be raised.

However, **a good design should make errors fail to compile**.

**[Best practice]** <u>If an error can be caught in compile-time, don't leave it until run-time.</u>

---

## Polymorphism (多态)

Polymorphism: The provision of a single interface to entities of different types, or the use of a single symbol to represent multiple different types.

- Run-time polymorphism: Achieved via **dynamic binding**.
- Compile-time polymorphism: Achieved via **function overloading**, **templates**, **concepts (since C++20)**, etc.


Run-time polymorphism:


<pre><code class="language-cpp">struct Shape {
  virtual void draw() const = 0;
};
void drawStuff(const Shape &amp;s) {
  s.draw();
}
</code></pre>



Compile-time polymorphism:


<pre><code class="language-cpp">template &lt;typename T&gt;
concept Shape = requires(const T x) {
  x.draw();
};
void drawStuff(Shape const auto &amp;s) {
  s.draw();
}
</code></pre>


---

# More on the "is-a" relationship

*Effective C++* Item 32

---

## Public inheritance: The "is-a" relationship

By writing that class `D` publicly inherits from class `B`, you are telling the compiler (as well as human readers of your code) that

- Every object of type `D` ***is*** also ***an*** object of type `B`, but not vice versa.
- `B` represents a **more general concept** than `D`, and that `D` represents a **more specialized concept** than `B`.

More specifically, you are asserting that **anywhere an object of type `B` can be used, an object of type `D` can be used just as well**.

- On the other hand, if you need an object of type `D`, an object of type `B` won't do.

---

## Example: Every student *is a* person.


<pre><code class="language-cpp">class Person { /* ... */ };
class Student : public Person { /* ... */ };
</code></pre>


- Every student ***is a*** person, but not every person is a student.
- Anything that is true of a person is also true of a student:

  - A person has a date of birth, so does a student.
- Something is true of a student, but not true of people in general.

  - A student is entrolled in a particular school, but a person may not.

The notion of a person is **more general** than is that of a student; a student is **a specialized type** of person.

---

## Example: Every student *is a* person.

The **is-a** relationship: Anywhere an object of type `Person` can be used, an object of type `Student` can be used just as well, **but not vice versa**.


<pre><code class="language-cpp">void eat(const Person &amp;p);    // Anyone can eat.
void study(const Student &amp;s); // Only students study.
Person p;
Student s;
eat(p);   // Fine. `p` is a person.
eat(s);   // Fine. `s` is a student, and a student is a person.
study(s); // Fine.
study(p); // Error! `p` isn't a student.
</code></pre>


---

## Your intuition can mislead you.

- A penguin **is a** bird.
- A bird can fly.

If we naively try to express this in C++, our effort yields:


<pre><code class="language-cpp">class Bird {
public:
  virtual void fly();         // Birds can fly.
  // ...
};
class Penguin : public Bird { // A penguin is a bird.
  // ...
};
</code></pre>



<pre><code class="language-cpp">Penguin p;
p.fly();    // Oh no!! Penguins cannot fly, but this code compiles!
</code></pre>


---

## No. Not every bird can fly.

***In general***, birds have the ability to fly.

- Strictly speaking, there are several types of non-flying birds.

Maybe the following hierarchy models the reality much better?


<pre><code class="language-cpp">class Bird { /* ... */ };
class FlyingBird : public Bird {
  virtual void fly();
};
class Penguin : public Bird {   // Not FlyingBird
  // ...
};
</code></pre>


---

## No. Not every bird can fly.

Maybe the following hierarchy models the reality much better?


<pre><code class="language-cpp">class Bird { /* ... */ };
class FlyingBird : public Bird {
  virtual void fly();
};
class Penguin : public Bird {   // Not FlyingBird
  // ...
};
</code></pre>


- **Not necessarily.** If your application has much to do with beaks and wings, and nothing to do with flying, the original two-class hierarchy might be satisfactory.
- **There is no one ideal design for every software.** The best design depends on what the system is expected to do.

---

## What about report a runtime error?


<pre><code class="language-cpp">void report_error(const std::string &amp;msg); // defined elsewhere
class Penguin : public Bird {
public:
  virtual void fly() {
    report_error(&quot;Attempt to make a penguin fly!&quot;);
  }
};
</code></pre>


---

## What about report a runtime error?


<pre><code class="language-cpp">void report_error(const std::string &amp;msg); // defined elsewhere
class Penguin : public Bird {
public:
  virtual void fly() { report_error(&quot;Attempt to make a penguin fly!&quot;); }
};
</code></pre>


**No.** This does not say "Penguins can't fly." This says **"Penguins can fly, but it is an error for them to actually try to do it."**

To actually express the constraint "Penguins can't fly", you should prevent the attempt from **compiling**.


<pre><code class="language-cpp">Penguin p;
p.fly(); // This should not compile.
</code></pre>


**[Best practice]** <u>Good interfaces prevent invalid code from **compiling**.</u>

---

## Example: A square *is a* rectangle.

Should class `Square` publicly inherit from class `Rectangle`?

---

## Example: A square *is a* rectangle.

Consider this code.



<pre><code class="language-cpp">class Rectangle {
public:
  virtual void setHeight(int newHeight);
  virtual void setWidth(int newWidth);
  virtual int getHeight() const;
  virtual int getWidth() const;
  // ...
};
void makeBigger(Rectangle &amp;r) {
  r.setWidth(r.getWidth() + 10);
}
</code></pre>




<pre><code class="language-cpp">class Square : public Rectangle {
  // A square is a rectangle,
  // where height == width.
  // ...
};

Square s(10);  // A 10x10 square.
makeBigger(s); // Oh no!
</code></pre>


---

## Is this really an "is-a" relationship?

We said before that the "is-a" relationship means that **anywhere an object of type `B` can be used, an object of type `D` can be used just as well**.

However, something applicable to a rectangle is not applicable to a square!

### Conclusion: Public inheritance means "is-a". Everything that applies to base classes must also apply to derived classes, because every derived class object is a base class object.

---

# Inheritance of interface vs inheritance of implementation

*Effective C++* Item 34

---

## Example: Airplanes for XYZ Airlines.

Suppose XYZ has only two kinds of planes: the Model A and the Model B, and both are flown in exactly the same way.


<pre><code class="language-cpp">class Airplane {
public:
  virtual void fly(const Airport &amp;destination) {
    // Default code for flying an airplane to the given destination.
  }
};
class ModelA : public Airplane { /* ... */ };
class ModelB : public Airplane { /* ... */ };
</code></pre>


- `Airplane::fly` is declared `virtual` because ***in principle***, different airplanes should be flown in different ways.
- `Airplane::fly` is defined, to avoid copy-and-pasting code in the `ModelA` and `ModelB` classes.

---

## Example: Airplanes for XYZ Airlines.

Now suppose that XYZ decides to acquire a new type of airplane, the Model C, **which is flown differently from the Model A and the Model B**.

XYZ's programmers add the class `ModelC` to the hierarchy, but forget to redefine the `fly` function!


<pre><code class="language-cpp">class ModelC : public Airplane {
  // `fly` is not overridden.
  // ...
};
</code></pre>


This surely leads to a disaster:


<pre><code class="language-cpp">auto pc = std::make_unique&lt;ModelC&gt;();
pc-&gt;fly(PVG); // No! Attempts to fly Model C in the Model A/B way!
</code></pre>


---

## Impure virtual function: Interface + default implementation

The problem here is not that `Airplane::fly` has default behavior, but that `ModelC` was allowed to inherit that behavior **without explicitly saying that it wanted to**.

### * By defining an impure virtual function, we have the derived class inherit a function *interface as well as a default implementation*.

- Interface: Every class inheriting from `Airplane` can `fly`.
- Default implementation: If `ModelC` does not override `Airplane::fly`, it will have the inherited implementation automatically.

---

## Separate default implementation from interface

To sever the connection between the *interface* of the virtual function and its *default implementation*:


<pre><code class="language-cpp">class Airplane {
public:
  virtual void fly(const Airport &amp;destination) = 0; // pure virtual
  // ...
protected:
  void defaultFly(const Airport &amp;destination) {
    // Default code for flying an airplane to the given destination.
  }
};
</code></pre>


- The pure virtual function `fly` provides the **interface**: Every derived class can `fly`.
- The **default implementation** is written in `defaultFly`.

---

## Separate default implementation from interface

If `ModelA` and `ModelB` want to adopt the default way of flying, they simply make a call to `defaultFly`.


<pre><code class="language-cpp">class ModelA : public Airplane {
public:
  virtual void fly(const Airport &amp;destination) {
    defaultFly(destination);
  }
  // ...
};
class ModelB : public Airplane {
public:
  virtual void fly(const Airport &amp;destination) {
    defaultFly(destination);
  }
  // ...
};
</code></pre>


---

## Separate default implementation from interface

For `ModelC`:

- Since `Airplane::fly` is pure virtual, `ModelC` must define its own version of `fly`.
- If it **does** want to use the default implementation, **it must say it explicitly** by making a call to `defaultFly`.


<pre><code class="language-cpp">class ModelC : public Airplane {
public:
  virtual void fly(const Airport &amp;destination) {
    // The &quot;Model C way&quot; of flying.
    // Without the definition of this function, `ModelC` remains abstract,
    // which does not compile if we create an object of such type.
  }
};
</code></pre>


---

## Still not satisfactory?

Some people object to the idea of having separate functions for providing the interface and the default implementation, such as `fly` and `defaultFly` above.

- For one thing, it pollutes the class namespace with closely related function names.

  - This really matters, especially in complicated projects. Extra mental effort might be required to distinguish the meaning of overly similar names.

Read the rest part of *Effective C++* Item 34 for another solution to this problem.

---

## Inheritance of interface vs inheritance of implementation

We have come to the conclusion that

- Pure virtual functions specify **inheritance of interface** only.
- Simple (impure) virtual functions specify **inheritance of interface + a default implementation**.
  - The default implementation can be overridden.

Moreover, non-virtual functions specify **inheritance of interface + a mandatory implementation**.

Note: In public inheritance, *interfaces are always inherited*.

---

## Summary

Pure virtual function and abstract class

- A pure virtual function is a virtual function declared `= 0`.
  - Call to a pure virtual function is not allowed. ${}^{\textcolor{red}{1}}$
  - Pure virtual functions define the interfaces and force the derived classes to override it.
- A class that has a pure virtual function is an abstract class.
  - We cannot create an object of an abstract class type.
  - Abstract classes are often used to represent abstract, general concepts.

---

## Summary

Public inheritance models the "is-a" relationship.

- Everything that applies to base classes must also apply to derived classes.
- The "Birds can fly, and a penguin is a bird" example.
- The "A square is a rectangle" example.

---

## Summary

Inheritance of interface vs inheritance of implementation

- In public inheritance, interfaces are always inherited.
- Pure virtual functions: inheritance of **interface** only.
- Simple (impure) virtual functions: inheritance of **interface + a default implementation**.
  - The default implementation can be overridden.
- non-virtual functions: inheritance of **interface + a mandatory implementation**.

---

## Notes

${}^{\textcolor{red}{1}}$ A pure virtual function can have a definition. In that case, it can be called via the syntax `ClassName::functionName(args)`, not via a virtual function call (dynamic binding).

In some cases, we want a class to be made abstract, but it does not have any pure virtual function. A possible workaround is to declare the destructor to be pure virtual, and then provide a definition for it:


<pre><code class="language-cpp">struct Foo {
  virtual ~Foo() = 0;
};
Foo::~Foo() = default; // Provide a definition outside the class.
</code></pre>


The "another solution" mentioned in page 36 is also related to this.












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.081f42fc.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      
        <script src="../javascripts/config.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>