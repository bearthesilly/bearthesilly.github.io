P7-9 标题是 stronger type checking ，我没有说 strong type system 。事实上所谓的“强类型语言”的定义是比较模糊的，有些人认为禁止一切类型转换才叫强类型，因此 C++ 是弱类型；也有些人认为 C++ 的类型转换本质上是调用了一个函数，所以可以认为 C++ 是强类型；还有人觉得只要暴露指针就不可能是强类型，因为你可以在指针层面上绕过类型系统；还有人觉得像 C++ 这样禁止危险的隐式类型转换的也可以视为强类型。

P8 “窄化” (narrowing) 类型转换在 C++ 里仍然是允许的，并且没有 warning 。只是在 modern C++ 的大括号初始化中不允许使用这种类型转换。这一页引用的内容来自 The Design and Evolution of C++ ， Stroustrup 当年曾经考虑过禁止隐式的窄化类型转换，但是他发现已经有无数的代码正在使用这种转换并且都运行得好好的，为了不破坏旧的代码只能作罢。他也曾考虑过某些运行时检查的方法，但是必然会影响效率， C/C++ 还是要以效率为重。这段就当讲故事就行。

P12 事实上 reinterpret_cast 几乎很少有用武之地，仅在某些极其特殊、极其底层的场合会用到。

P13 static_cast 能做的转换很多，这里比较模糊地用“那些看起来 harmless 的类型转换”概括了一下。事实上这四种类型转换运算符的规则都相对比较复杂，我们只是选取最具有代表性的（也是最能体现它们被发明的初衷的）使用方式。

P14 要使用 C++ 的这些有名字的类型转换运算符，而不是 C 风格的 `(Type)expr` 这种类型转换。 C++ 的这些类型转换运算符明确地标出了每一处类型转换是哪一类，是在擦除底层 const ，还是在向下转型，还是一些无伤大雅的转型，还是某种底层的指针转换等等，而 C 风格的类型转换看起来太过普通。举个例子，如果你坚持使用 C++ 的类型转换运算符，你可以直接在代码里 ctrl+f 查找 `_cast` 来找到所有类型转换，很快就能定位到出错的位置。

P21 C++ 的 lambda 表达式的类型是编译器自己设的，每个 lambda 表达式都具有独一无二的类型，这个类型名我们是写不出来的，只能用 auto 。

P34 这套规则不要求掌握，但是有一些十分典型的需要记住，特别是
- 数组向指针的退化也被认为是完美匹配。
- 添加底层 const 被认为是低于完美匹配的。我们经常使用 const vs non-const 的重载。
至于那些算术转换（包括这几页 slides 中的一些例子），仅仅是放在这里为了展示函数是如何被重载的。一般来说，很少有人真的会定义一组接受 char, int, long, double 的重载函数（除非你是在编写输入输出之类的函数），绝大多数时候我们都是拿不同的类类型以及不同的参数个数进行重载。
