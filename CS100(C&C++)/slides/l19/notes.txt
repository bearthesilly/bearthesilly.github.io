P8 简单解释一下这里的设计：分子是 `m_num` ，分母是 `m_denom` 。这里我们约定分母总是正的，整个有理数的符号是带在分子上的，并且我们约定 `m_num / m_denom` 应当总是一个既约分数。 `simplify()` 是用来约分的，是我们的一个辅助函数，属于实现细节，所以是 `private` 的。

`Rational(int x = 0)` 这个构造函数接受一个参数，而这个参数有一个默认实参，所以它也是一个默认构造函数。

P9 这里的 `operator+=` 在写的时候要非常小心，因为分母是 `unsigned` 而分子是 `int` ，当 `unsigned` 和 `int` 放在一起运算的时候 `int` 会被转换为 `unsigned` ，引发意想不到的结果。

P26 `if (!is)` 检测 `is` 是否处在一个正常的、未出错的状态下。

P32 在一元取地址运算符 `&` 被重载了的情况下， `&x` 可能就不再返回 `x` 的地址了。绝大多数时候我们不建议重载取地址运算符，但是的确有某些极其特殊的类型会这么做。所以我们使用 `std::addressof` 来获取一个对象的地址，它保证一定能获得那个对象的地址，不管 `&` 有没有被重载。