P6 常见的运算符中，规定了运算对象的求值顺序的运算符仅有 `&&`, `||`, `?:`, `,` 这四个。我打算在习题课上讲 `,` （逗号运算符），因为它比较特别，而且存在感很弱，一般我们不会去注意这个运算符。标准对于 "unspecified" 的解释是 "results in one of a set of valid results"，也就是说 unspecified behavior 是合法的 behavior，只是标准没有规定其具体行为。注意，undefined behavior 是“一切皆有可能”的行为。一个程序可以含有 unspecified behavior，但不应含有 undefined behavior。

P7 如果两个表达式 A 和 B 的求值顺序是 unspecified 的，而它们都修改某一个变量，或者对某一个变量一读一写，那就是 undefined behavior （这听起来有点像并发的 data race 的概念）。还是那句老话， undefined behavior 是“一切皆有可能”。像 `printf("%d, %d\n", i, i++);` 这样的语句，你甚至不能假定它有输出。程序完全有可能直接在这里崩溃，或者编译器直接把这行代码去掉，这些都是有可能的。不要去讨论像 `i = ++i + i++;` 这样的语句到底有几种可能，这没有任何意义。我在国内一些传统高校的相关课程中见过这样的内容，特别是一些学校/教材直接把 VC6 当“标准”，认为 VC6 的运行结果就是标准的行为，完全不顾 undefined behavior、unspecified behavior 和 implementation-defined behavior 的存在，这是不正确的。

P8 有时我们会说一个表达式或者一个运算符的“返回值”，初学者可能会产生一些误解，所以特别用这一页说明一下。比方说这样的代码
```c
int foo(int a) {
  int x = a++;
  return 42;
}
```
当我指着 `a++` 这个表达式说它“返回了 `a` 递增前的值”时，一些同学可能会误以为是 `foo` 返回了这个值。
注意，这一页的代码里 `operator_postfix_inc` 函数使用了一个 C++ 写法 `(int &x)` （传引用），这是因为我们需要修改外部的实参，而 C 里没有这个功能。C 里要达到类似的效果，只能把那个变量的地址传进来。

P9-19 值得注意的是，C 里所有涉及到“条件”、“真/假”的地方都是用 `int` 以及是否等于 `0` 来描述的，这大概也算是 C 的一个历史遗留问题，不过不是什么大问题。C++ 里这些地方都是 `bool`。事实上 C 对 `bool` 的支持一直比较有限，直到 C23 `bool` 和 `true`/`false` 才真正成为语言的关键字（在此之前它们都是 `#define` 定义出来的宏）并且不再需要 #include <stdbool.h>。但我估计内置的运算符和语句里对于“条件”的描述可能永远都不会改成 `bool` 了。

P27 "control" 作为一个名词经常出现，它的意思是“控制流”，就是指这个程序执行到哪了。

P29 constant expression 是一个专门的术语（通常翻译为“常量表达式”），而不是“值不变的表达式”。它特指编译时求值的表达式，而且特别是在 C 里常量表达式的定义非常局限。像 `int x = 42;` 这样声明的变量 `x` 绝不是常量表达式，哪怕声明成 `const int x = 42;` 也不好使。`const` 变量不一定是在编译时可知的，只是一经初始化就不能改变而已，所以它不被认为是 constant expression。C 认为的常量表达式大概只有字面值和枚举项，所以有时候我们会看到所谓的 "enum hack":
```c
const int maxn_1 = 100;
enum { maxn_2 = 100 };
int a[maxn_1]; // 错误，maxn_1 不是常量表达式
int b[maxn_2]; // 正确
```
C++ 常量表达式的规则就宽松很多了，而且 C++ 本身也在朝着更多编译时计算的方向发展。
