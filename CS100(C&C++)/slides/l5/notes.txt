P10 输出的第二个数是不一定的，每次运行可能输出都不同。第一个数和第三个数一定是 0。

P11 empty-initialization 翻译为“空初始化”。这个词在 C23 以前的标准里从未出现过，但是 cppreference 却没有给它标 "since C23"。虽然我们采用 C17 标准，但为了方便，也使用这个词。空初始化的结果是各种零，例如整数 `0`、浮点数 `+0.0`、空指针等等。注意，浮点数 `+0.0` 并不意味着每个二进制位都是 `0`，虽然现在最主流的浮点数表示形式 IEEE754 就是如此。空指针也并不意味着一定是 all-bits zero，详见末尾我放的链接。但是，在 C 语言的层面上我们是无法看到空指针的底层实现究竟是什么值的，因为标准规定空指针 compares equal to the integer zero，并且转换成 bool 的结果是 false。

P12-13 使用未初始化的值是 undefined behavior。还是那句话，不能认为“我们会得到一个值，只是不知道它是多少罢了”。未初始化的变量可能和自己不相等，其值可能每次读取都不一样，并且可能还含有 trap representation，即它的二进制位并没有表示一个合法的值。

P15 这里所说的 indirect modification 指的是下一节课将涉及的通过指针转换绕过 const 保护来实现的对 const 变量的修改。

P16 "non-stop ticket to undefined behavior" 通往未定义的行为的直达车票 这个说法出自 Scott Meyers 的著作 Effective C++

P22 `*expr` 这里的 `*` 称为 dereference operator 或者 indirection operator，中文译作“解引用运算符”。`&` 是“取地址运算符”。"lvalue" 译为“左值”，读作 ell-value。我们不在 C 的部分介绍左值和右值的概念，但需要让大家感觉到其中的区别：“变量”和“变量的值”是不同的，“指针”和“地址”是不同的。

P38 本质上，数组下标访问越界和解引用无效指针是一样的错误，都是试图访问非法的内存。

P42 总是有人看到 `int a[N] = {0};` 将 `a` 所有元素都初始化为 `0`，便认为 `= {x}` 是将所有元素初始化为 `x`。

P43 C 所谓“多维数组”就是“数组的数组”，或者叫“嵌套数组”。`Type a[4][3]` 是一个有 4 个元素的数组，每个元素的类型是 `Type [3]`，即每个元素都是一个有 3 个 `Type` 类型的元素的数组。

P44 带过即可，cppreference 页面上这一段非常简短易懂，不必费时间在课上仔细解释。